{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Pode is a Cross-Platform PowerShell framework to create web servers that host REST APIs, Web Sites, and TCP/SMTP Servers. It also allows you to render dynamic files using .pode files, which is effectively embedded PowerShell, or other Third-Party template engines. Pode also has support for middleware, sessions, and authentication; as well as access and rate limiting features. Features Cross-platform using PowerShell Core (with support for PS4.0+) Listen on a single or multiple IP address/hostnames Support for HTTP, HTTPS, TCP and SMTP Host REST APIs, Web Pages, and Static Content (with caching) Support for custom error pages Multi-thread support for incoming requests Inbuilt template engine, with support for third-parties Async timers for short-running repeatable processes Async scheduled tasks using cron expressions for short/long-running processes Supports request logging to CLI, Files, and custom loggers to other services like LogStash Cross-state variable access across multiple runspaces Restart the server via file monitoring, or defined periods/times Ability to allow/deny requests from certain IP addresses and subnets Basic rate limiting for IP addresses and subnets Middleware and Sessions on web servers, with Flash message support Authentication on requests, such as Basic and Windows Active Directory (Windows) Generate/bind self-signed certificates, and signed certificates (Windows) Open the hosted server as a desktop application Quick Look! Below is a quick example of using Pode to create a single REST API endpoint to return a JSON response. It will listen on an endpoint, create the route , and respond with JSON when http://localhost:8080/ping is hit: Server { listen localhost : 8080 http route get '/ping' { json @{ 'value' = 'pong' } } }","title":"Home"},{"location":"#welcome","text":"Pode is a Cross-Platform PowerShell framework to create web servers that host REST APIs, Web Sites, and TCP/SMTP Servers. It also allows you to render dynamic files using .pode files, which is effectively embedded PowerShell, or other Third-Party template engines. Pode also has support for middleware, sessions, and authentication; as well as access and rate limiting features.","title":"Welcome"},{"location":"#features","text":"Cross-platform using PowerShell Core (with support for PS4.0+) Listen on a single or multiple IP address/hostnames Support for HTTP, HTTPS, TCP and SMTP Host REST APIs, Web Pages, and Static Content (with caching) Support for custom error pages Multi-thread support for incoming requests Inbuilt template engine, with support for third-parties Async timers for short-running repeatable processes Async scheduled tasks using cron expressions for short/long-running processes Supports request logging to CLI, Files, and custom loggers to other services like LogStash Cross-state variable access across multiple runspaces Restart the server via file monitoring, or defined periods/times Ability to allow/deny requests from certain IP addresses and subnets Basic rate limiting for IP addresses and subnets Middleware and Sessions on web servers, with Flash message support Authentication on requests, such as Basic and Windows Active Directory (Windows) Generate/bind self-signed certificates, and signed certificates (Windows) Open the hosted server as a desktop application","title":"Features"},{"location":"#quick-look","text":"Below is a quick example of using Pode to create a single REST API endpoint to return a JSON response. It will listen on an endpoint, create the route , and respond with JSON when http://localhost:8080/ping is hit: Server { listen localhost : 8080 http route get '/ping' { json @{ 'value' = 'pong' } } }","title":"Quick Look!"},{"location":"release-notes/","text":"Release Notes v0.27.3 ### Bugs * #217: Binding to hostname throws error v0.27.2 ### Bugs * #212: Incorrect variable name used in html, csv, xml and json functions when referencing files v0.27.1 ### Bugs * #199: Fix issues with relative paths when running server as a service * #200: Fix issue with file monitor, where folder patterns fail to match on new files v0.27.0 ### Features * #185: Support for Server Restarts either Periodically or at specific Times, with support for cron expressions * #188: Support for Custom Error pages, with inbuilt Pode error pages ### Enhancements * #189: SMTP server to parse data headers and have them set on the event object ### Performance * #196: Massive improvements to performance when loading static content ### Bugs * #181: Importing modules into the current scope should be done Globally, making them instantly accessible * #183: TCP Reads and Writes should be Async so they can be terminated more easily * #184: SMTP and TCP servers fail to Restart * #196: Default paths on Static Content fail when using nested directories ### General * #194: Update Dockerfile from using PSCore 6.1.0 to 6.1.3 v0.26.0 ### Features * #162: Basic support for local modules in \"package.json\" on \"pode install\" * #175: Support for flash messages on sessions, and in authentication ### Bugs * #72: RunspacePools aren't being recreated during a restart, and modules fail to import into other RunspacePools v0.25.0 ### Features * #170: Support for Static Content Caching, with ability to include/exclude routes/extensions ### Enhancements * #161: New method to return configuration from the pode.json file, plus improved docs and support for environment configs * #165: Support on the inbuilt SMTP server for Subject and decoded Body * #168: Ability to exclude/include paths/extensions when triggering an Internal Restart ### Documentation * #45: Add \"Known Issues\" pages to documentation ### Clean-Up * #160: Internally, rename occurrences of $PodeSession to $PodeContext v0.24.0 ### Features * #125: Helper support function for uploading files from a web form ### Enhancements * #149: Inbuilt support for Windows AD Authentication ### Bugs * #152: Fix the Choco install script so it installs the module for PowerShell Core as well * #155: After an Internal Restart, the View Engine is not set back to the default * #158: If views/public directories don't exist, the creation of PSDrive fails v0.23.0 ### Features * #77: Ability to run a web server, and view it through a Desktop Application (Windows only) ### Enhancements * #137: Don't require admin privileges when listening on Localhost * #140: Add a Custom switch to the Logger function - no need to use the \"custom_<name>\" format any more! * #142: Ability to listen on multiple endpoints - especially useful for hostnames against a single IP address * #143: Support on routes to allow them to be bound against specific hostnames/protocols * #146: Listen function to have Name parameter - so we can select which one to bind a Route/Gui to better v0.22.0 ### Enhancements * #123: Ability to remove a `route` * #124: Views, Public and custom static routes now use `New-PSDrive` to prevent directory tranversing * #128: Ability to `listen` using a host name * #130: `auth` now allows re-using inbuilt/custom parsers. Rather than `name` the type, the name is now any custom name you want to use and yuo specify the `-type` (like basic, etc). If no `-type` supplied, `name` is used as the type instead * #131: There's now a route parameter on `middleware`, so you can define global middleware that only run on requests for specific routes. v0.21.0 ### Enhancements * #110: Return a 401 for inaccessible files * #116: Support on custom static content, for returning `index.html` or `default.html` (plus others), if a directory is requested ### Bugs * #111: Separate out the `service` server type into own runspace * #112: Server should return a 500 if middleware/route fails unexpectedly, rather than a 200 ### Documentation * #120: Added examples of running scripts as Windows or Linux services [here](https://badgerati.github.io/Pode/Getting-Started/RunAsService/) ### Clean-Up * #118: Rename `$WebSession` to `$WebEvent` - internal references only v0.20.0 ### Documentation * Extended documentation for third-party template engines * \"Building your first app\" documentation ### Features * #103: Adds support for custom static routes ### Enhancements * #101: Adds a `-Limit` parameter to schedules * `import` function now supports installed modules ### Clean-Up * #102: Logging converted to internal `endware` script v0.19.1 ### Documentation * #91: This release contains far better documentation for Pode: https://badgerati.github.io/Pode ### Enhancements * #93: Updates PowerShell Docker image to 6.1.0, so internal restarts now work * #96: Chocolatey package now contains the module, rather than downloading from GitHub * Adds more aliases for parameters on core functions * Renames `script` function to `import` (the former is still supported) * New CI builder: Travis CI, used to test Pode on *nix and PowerShell Core * Minor miscellaneous stability fixes v0.19.0 ### Features * #84: Session cookie support, with in-mem/custom data storage * #86: Request authentication support. Currently implemented: Basic, Forms, Custom ### Enhancements * #88: Enabling Ctrl+R to be pressed on the CLI to trigger a server restart - similar to using `-FileMonitor`. v0.18.0 ### Features * #78: Middleware support for web servers, allowing custom logic and extension modules on web request/responses ### Enhancements * #81: Added aliases onto some of the `Server` parameters v0.17.0 ### Features * #43: Ability to generate self-signed certificates, and bind those certs - or pre-installed certs - when using HTTPS * #71: New `scripts` call to specify external modules that should be imported into each runspace ### Bugs * #71: Unable to access functions from external scripts * #73: Calling `pode start` fails to import Pode module into runspaces v0.16.0 ### Features * #66: Support for basic rate limiting of requests per x seconds from IPs * #68: Support for scheduled tasks using cron expressions ### Enhancements * #62: Helper function to ease URL redirection * #64: Have a '*' HTTP method so a route can be used on every method v0.15.0 ### Features * #31: Support for multithreaded responses on web, smtp and tcp servers using `-Threads` on your Server block ### Misc * #59: Removal of obsolete functions, such as the older `Write-JsonResponse` which is now just `Json` * #31: Addition of some minor performance tests using `k6` * Addition of new icon and logo for Pode v0.14.0 ### Features * #21: Ability for Pode to Internally Restart when a File Change is Detected * #52: Support for Allowing/Denying IP and Subnet Addresses ### Enhancements * #44: Setup Unit Tests with Pester and run on AppVeyor ### Bugs * #51: Set Dockerfile to use a fixed version of the PowerShell container, rather than latest * #55: Setup SMTP/TCP listeners to run in separate runspace like Web v0.13.0 ### Features * #40: Ability to add variables to a shared state, so you can re-use variables in timers, loggers, and routes v0.12.0 ### Features * #33: Support for logging to the terminal, files, and custom loggers for LogStash/Fluentd/etc * #35: New `Attach` function to help attach files from the public directory to the response for downloading ### Enhancements * #32: Ability to listen on a specific IP address using `-IP` on a `Server` * #36: Support for relative paths on views/public content, when running server script from non-root directory v0.11.3 ### Bugs and Enhancements * # 22 : Proper fix for high CPU usage , by using ` Task . Wait ` with ` CancellationTokens ` ; A Runspace is setup to monitor for key presses , and on ` Ctrl + C ` will ` Cancel () ` the token and terminate Pode v0.11.2 ### Bugs * #22: Hot fix patch for reducing high CPU usage when idle v0.11.1 ### Bugs * #16: Status and Include functions were missing from module export list v0.11.0 ### Features * #5: Async timers to run tasks and processes in a separate thread (see timers sections in README) ### Enhancements * #7: New `status` function to easily alter the StatusCode of a Response * #8: New `json`, `xml`, `html`, `csv`, `view` and `tcp` functions to replace current \"Write-<Type>Response\" - now obsolete - functions (see ticket for explanation, and README for usage) ### Bugs * #12: Fixed an issue that caused image files (and others) to not render appropriately","title":"Release Notes"},{"location":"release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"release-notes/#v0273","text":"### Bugs * #217: Binding to hostname throws error","title":"v0.27.3"},{"location":"release-notes/#v0272","text":"### Bugs * #212: Incorrect variable name used in html, csv, xml and json functions when referencing files","title":"v0.27.2"},{"location":"release-notes/#v0271","text":"### Bugs * #199: Fix issues with relative paths when running server as a service * #200: Fix issue with file monitor, where folder patterns fail to match on new files","title":"v0.27.1"},{"location":"release-notes/#v0270","text":"### Features * #185: Support for Server Restarts either Periodically or at specific Times, with support for cron expressions * #188: Support for Custom Error pages, with inbuilt Pode error pages ### Enhancements * #189: SMTP server to parse data headers and have them set on the event object ### Performance * #196: Massive improvements to performance when loading static content ### Bugs * #181: Importing modules into the current scope should be done Globally, making them instantly accessible * #183: TCP Reads and Writes should be Async so they can be terminated more easily * #184: SMTP and TCP servers fail to Restart * #196: Default paths on Static Content fail when using nested directories ### General * #194: Update Dockerfile from using PSCore 6.1.0 to 6.1.3","title":"v0.27.0"},{"location":"release-notes/#v0260","text":"### Features * #162: Basic support for local modules in \"package.json\" on \"pode install\" * #175: Support for flash messages on sessions, and in authentication ### Bugs * #72: RunspacePools aren't being recreated during a restart, and modules fail to import into other RunspacePools","title":"v0.26.0"},{"location":"release-notes/#v0250","text":"### Features * #170: Support for Static Content Caching, with ability to include/exclude routes/extensions ### Enhancements * #161: New method to return configuration from the pode.json file, plus improved docs and support for environment configs * #165: Support on the inbuilt SMTP server for Subject and decoded Body * #168: Ability to exclude/include paths/extensions when triggering an Internal Restart ### Documentation * #45: Add \"Known Issues\" pages to documentation ### Clean-Up * #160: Internally, rename occurrences of $PodeSession to $PodeContext","title":"v0.25.0"},{"location":"release-notes/#v0240","text":"### Features * #125: Helper support function for uploading files from a web form ### Enhancements * #149: Inbuilt support for Windows AD Authentication ### Bugs * #152: Fix the Choco install script so it installs the module for PowerShell Core as well * #155: After an Internal Restart, the View Engine is not set back to the default * #158: If views/public directories don't exist, the creation of PSDrive fails","title":"v0.24.0"},{"location":"release-notes/#v0230","text":"### Features * #77: Ability to run a web server, and view it through a Desktop Application (Windows only) ### Enhancements * #137: Don't require admin privileges when listening on Localhost * #140: Add a Custom switch to the Logger function - no need to use the \"custom_<name>\" format any more! * #142: Ability to listen on multiple endpoints - especially useful for hostnames against a single IP address * #143: Support on routes to allow them to be bound against specific hostnames/protocols * #146: Listen function to have Name parameter - so we can select which one to bind a Route/Gui to better","title":"v0.23.0"},{"location":"release-notes/#v0220","text":"### Enhancements * #123: Ability to remove a `route` * #124: Views, Public and custom static routes now use `New-PSDrive` to prevent directory tranversing * #128: Ability to `listen` using a host name * #130: `auth` now allows re-using inbuilt/custom parsers. Rather than `name` the type, the name is now any custom name you want to use and yuo specify the `-type` (like basic, etc). If no `-type` supplied, `name` is used as the type instead * #131: There's now a route parameter on `middleware`, so you can define global middleware that only run on requests for specific routes.","title":"v0.22.0"},{"location":"release-notes/#v0210","text":"### Enhancements * #110: Return a 401 for inaccessible files * #116: Support on custom static content, for returning `index.html` or `default.html` (plus others), if a directory is requested ### Bugs * #111: Separate out the `service` server type into own runspace * #112: Server should return a 500 if middleware/route fails unexpectedly, rather than a 200 ### Documentation * #120: Added examples of running scripts as Windows or Linux services [here](https://badgerati.github.io/Pode/Getting-Started/RunAsService/) ### Clean-Up * #118: Rename `$WebSession` to `$WebEvent` - internal references only","title":"v0.21.0"},{"location":"release-notes/#v0200","text":"### Documentation * Extended documentation for third-party template engines * \"Building your first app\" documentation ### Features * #103: Adds support for custom static routes ### Enhancements * #101: Adds a `-Limit` parameter to schedules * `import` function now supports installed modules ### Clean-Up * #102: Logging converted to internal `endware` script","title":"v0.20.0"},{"location":"release-notes/#v0191","text":"### Documentation * #91: This release contains far better documentation for Pode: https://badgerati.github.io/Pode ### Enhancements * #93: Updates PowerShell Docker image to 6.1.0, so internal restarts now work * #96: Chocolatey package now contains the module, rather than downloading from GitHub * Adds more aliases for parameters on core functions * Renames `script` function to `import` (the former is still supported) * New CI builder: Travis CI, used to test Pode on *nix and PowerShell Core * Minor miscellaneous stability fixes","title":"v0.19.1"},{"location":"release-notes/#v0190","text":"### Features * #84: Session cookie support, with in-mem/custom data storage * #86: Request authentication support. Currently implemented: Basic, Forms, Custom ### Enhancements * #88: Enabling Ctrl+R to be pressed on the CLI to trigger a server restart - similar to using `-FileMonitor`.","title":"v0.19.0"},{"location":"release-notes/#v0180","text":"### Features * #78: Middleware support for web servers, allowing custom logic and extension modules on web request/responses ### Enhancements * #81: Added aliases onto some of the `Server` parameters","title":"v0.18.0"},{"location":"release-notes/#v0170","text":"### Features * #43: Ability to generate self-signed certificates, and bind those certs - or pre-installed certs - when using HTTPS * #71: New `scripts` call to specify external modules that should be imported into each runspace ### Bugs * #71: Unable to access functions from external scripts * #73: Calling `pode start` fails to import Pode module into runspaces","title":"v0.17.0"},{"location":"release-notes/#v0160","text":"### Features * #66: Support for basic rate limiting of requests per x seconds from IPs * #68: Support for scheduled tasks using cron expressions ### Enhancements * #62: Helper function to ease URL redirection * #64: Have a '*' HTTP method so a route can be used on every method","title":"v0.16.0"},{"location":"release-notes/#v0150","text":"### Features * #31: Support for multithreaded responses on web, smtp and tcp servers using `-Threads` on your Server block ### Misc * #59: Removal of obsolete functions, such as the older `Write-JsonResponse` which is now just `Json` * #31: Addition of some minor performance tests using `k6` * Addition of new icon and logo for Pode","title":"v0.15.0"},{"location":"release-notes/#v0140","text":"### Features * #21: Ability for Pode to Internally Restart when a File Change is Detected * #52: Support for Allowing/Denying IP and Subnet Addresses ### Enhancements * #44: Setup Unit Tests with Pester and run on AppVeyor ### Bugs * #51: Set Dockerfile to use a fixed version of the PowerShell container, rather than latest * #55: Setup SMTP/TCP listeners to run in separate runspace like Web","title":"v0.14.0"},{"location":"release-notes/#v0130","text":"### Features * #40: Ability to add variables to a shared state, so you can re-use variables in timers, loggers, and routes","title":"v0.13.0"},{"location":"release-notes/#v0120","text":"### Features * #33: Support for logging to the terminal, files, and custom loggers for LogStash/Fluentd/etc * #35: New `Attach` function to help attach files from the public directory to the response for downloading ### Enhancements * #32: Ability to listen on a specific IP address using `-IP` on a `Server` * #36: Support for relative paths on views/public content, when running server script from non-root directory","title":"v0.12.0"},{"location":"release-notes/#v0113","text":"### Bugs and Enhancements * # 22 : Proper fix for high CPU usage , by using ` Task . Wait ` with ` CancellationTokens ` ; A Runspace is setup to monitor for key presses , and on ` Ctrl + C ` will ` Cancel () ` the token and terminate Pode","title":"v0.11.3"},{"location":"release-notes/#v0112","text":"### Bugs * #22: Hot fix patch for reducing high CPU usage when idle","title":"v0.11.2"},{"location":"release-notes/#v0111","text":"### Bugs * #16: Status and Include functions were missing from module export list","title":"v0.11.1"},{"location":"release-notes/#v0110","text":"### Features * #5: Async timers to run tasks and processes in a separate thread (see timers sections in README) ### Enhancements * #7: New `status` function to easily alter the StatusCode of a Response * #8: New `json`, `xml`, `html`, `csv`, `view` and `tcp` functions to replace current \"Write-<Type>Response\" - now obsolete - functions (see ticket for explanation, and README for usage) ### Bugs * #12: Fixed an issue that caused image files (and others) to not render appropriately","title":"v0.11.0"},{"location":"Functions/Core/Endware/","text":"Endware Description The endware function allows you to add endware scripts, that run after all middleware and route logic - even if a middleware has ended the pipeline early. They allow you to do things like logging, further data storage, etc. Endware in Pode allows you to observe the request/response objects at the very end of the middleware/route pipeline for a current web event. This way you will have the most up-to-date information on the objects for any logging you may wish to perform. Info Unlike middleware which has a return value to halt execution, each endware will run in turn without the need for returning anything. So if there are 4 endware configured and 1 fails in the middle, the other later ones will still run. Examples Example 1 The following example is endware that observes the content length of the response, as well as the status code, and records them in some custom data storage for later analysis: Server { endware { param ( $event ) $status = $event . Response . StatusCode $length = $event . Response . ContentLength64 Save-ContentStatus -ContentLength $length -Status $status } } Parameters Name Type Required Description Default ScriptBlock scriptblock true The main logic for the endware; this scriptblock will be supplied a single parameter for the current event which contains the Request and Response objects null","title":"Endware"},{"location":"Functions/Core/Endware/#endware","text":"","title":"Endware"},{"location":"Functions/Core/Endware/#description","text":"The endware function allows you to add endware scripts, that run after all middleware and route logic - even if a middleware has ended the pipeline early. They allow you to do things like logging, further data storage, etc. Endware in Pode allows you to observe the request/response objects at the very end of the middleware/route pipeline for a current web event. This way you will have the most up-to-date information on the objects for any logging you may wish to perform. Info Unlike middleware which has a return value to halt execution, each endware will run in turn without the need for returning anything. So if there are 4 endware configured and 1 fails in the middle, the other later ones will still run.","title":"Description"},{"location":"Functions/Core/Endware/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Endware/#example-1","text":"The following example is endware that observes the content length of the response, as well as the status code, and records them in some custom data storage for later analysis: Server { endware { param ( $event ) $status = $event . Response . StatusCode $length = $event . Response . ContentLength64 Save-ContentStatus -ContentLength $length -Status $status } }","title":"Example 1"},{"location":"Functions/Core/Endware/#parameters","text":"Name Type Required Description Default ScriptBlock scriptblock true The main logic for the endware; this scriptblock will be supplied a single parameter for the current event which contains the Request and Response objects null","title":"Parameters"},{"location":"Functions/Core/Engine/","text":"Engine Description The engine function allows you to specify the engine used to render view and content templates. You can also specify a third-party engine to use, such as EPS . Info If you don't use the engine function, then the defaut of HTML will be used Examples Example 1 The following example will render views and content using the Pode template engine (such as the index.pode view or the style.css.pode public content file): Server { engine pode } Example 2 The following example will use the third-party engine EPS to render views (such as the index.eps view or the style.css.eps public content file): Server { engine eps { param ( $path , $data ) return Invoke-EpsTemplate -Path $path -Binding $data } } Parameters Name Type Required Description Default Engine string true The type of engine to use, can be either HTML, Pode, or a custom third-party type - the value passed should be the extension used by the engine HTML ScriptBlock scriptblock false When using a third-party template engine, the ScriptBlock is required as it tells Pode how to render views/static content using the engine null","title":"Engine"},{"location":"Functions/Core/Engine/#engine","text":"","title":"Engine"},{"location":"Functions/Core/Engine/#description","text":"The engine function allows you to specify the engine used to render view and content templates. You can also specify a third-party engine to use, such as EPS . Info If you don't use the engine function, then the defaut of HTML will be used","title":"Description"},{"location":"Functions/Core/Engine/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Engine/#example-1","text":"The following example will render views and content using the Pode template engine (such as the index.pode view or the style.css.pode public content file): Server { engine pode }","title":"Example 1"},{"location":"Functions/Core/Engine/#example-2","text":"The following example will use the third-party engine EPS to render views (such as the index.eps view or the style.css.eps public content file): Server { engine eps { param ( $path , $data ) return Invoke-EpsTemplate -Path $path -Binding $data } }","title":"Example 2"},{"location":"Functions/Core/Engine/#parameters","text":"Name Type Required Description Default Engine string true The type of engine to use, can be either HTML, Pode, or a custom third-party type - the value passed should be the extension used by the engine HTML ScriptBlock scriptblock false When using a third-party template engine, the ScriptBlock is required as it tells Pode how to render views/static content using the engine null","title":"Parameters"},{"location":"Functions/Core/Gui/","text":"Gui Warning Currently only supported on Windows due to using WPF. (Though it appears WPF could soon be supported on .NET Core 3) Description The gui function allows you to run a server and have it automatically open as a desktop application. In reality it's just a WPF application with a WebBrowser control, and the server running in the background. If you run your server directly, then the terminal will remain visible. However, you could have a script which opens PowerShell as hidden and launches the server. Tip You can use the gui and listen on any endpoint however, it's recommended to listen on the localhost - that way you don't need to run the application with elevated permissions. Examples Example 1 The following example will launch the server, and open a application called \"Pode Example 1\". It will also set the icon of the application: Server { gui 'Pode Example 1' @{ 'Icon' = '../images/icon.png' } listen localhost : 8080 http } Example 2 The following example will launch the server, but will open the application as fullscreen: Server { gui 'Pode Example 2' @{ 'State' = 'Maximized' } listen localhost : 8080 http } Parameters Note The gui function takes 2 parameters; the first is a mandatory name for the window, the second is a hashtable . The below parameters are the expected keys that could be in that hashtable Name Type Required Description Default Icon string false A path to an icon/image file that will be used for the application null ShowInTaskbar bool false Defines whether or not the application should appear in the taskbar true State string false The state of the application when it opens. (Values: Normal, Maximized, Minimized) Normal WindowStyle string false The border style of the application when it opens. (Values: None, SingleBorderWindow, ThreeDBorderWindow, ToolWindow) SingleBorderWindow ListenName string false The name of a listen endpoint to use - useful if you have multiple endpoints defined empty","title":"Gui"},{"location":"Functions/Core/Gui/#gui","text":"Warning Currently only supported on Windows due to using WPF. (Though it appears WPF could soon be supported on .NET Core 3)","title":"Gui"},{"location":"Functions/Core/Gui/#description","text":"The gui function allows you to run a server and have it automatically open as a desktop application. In reality it's just a WPF application with a WebBrowser control, and the server running in the background. If you run your server directly, then the terminal will remain visible. However, you could have a script which opens PowerShell as hidden and launches the server. Tip You can use the gui and listen on any endpoint however, it's recommended to listen on the localhost - that way you don't need to run the application with elevated permissions.","title":"Description"},{"location":"Functions/Core/Gui/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Gui/#example-1","text":"The following example will launch the server, and open a application called \"Pode Example 1\". It will also set the icon of the application: Server { gui 'Pode Example 1' @{ 'Icon' = '../images/icon.png' } listen localhost : 8080 http }","title":"Example 1"},{"location":"Functions/Core/Gui/#example-2","text":"The following example will launch the server, but will open the application as fullscreen: Server { gui 'Pode Example 2' @{ 'State' = 'Maximized' } listen localhost : 8080 http }","title":"Example 2"},{"location":"Functions/Core/Gui/#parameters","text":"Note The gui function takes 2 parameters; the first is a mandatory name for the window, the second is a hashtable . The below parameters are the expected keys that could be in that hashtable Name Type Required Description Default Icon string false A path to an icon/image file that will be used for the application null ShowInTaskbar bool false Defines whether or not the application should appear in the taskbar true State string false The state of the application when it opens. (Values: Normal, Maximized, Minimized) Normal WindowStyle string false The border style of the application when it opens. (Values: None, SingleBorderWindow, ThreeDBorderWindow, ToolWindow) SingleBorderWindow ListenName string false The name of a listen endpoint to use - useful if you have multiple endpoints defined empty","title":"Parameters"},{"location":"Functions/Core/Handler/","text":"Handler Description The handler function allows you to bind logic onto incoming TCP streams, or onto SMTP requests. The SMTP handler type will use Pode's inbuilt simple SMTP server, which will automatically create a TCP listener on port 25 (unless you specific a different port to listen on). The handler logic in this case will be passed an argument containing information about the Email. The TCP handler will have the TCP client itself passed to the handler's logic, this way you can build your own custom TCP handler. Warning You can only have 1 handler per type. Ie, TCP can only have one handler defined, as well as SMTP. Examples Example 1 The following example will setup the inbuilt simple SMTP server, writing to the terminal the content of the email: Server { listen * : 25 smtp handler smtp { param ( $email ) Write-Host $email . Data } } Tip The $email argument supplied to the SMTP handler contains the From and To address, as well as the Data of the email. Example 2 The following example will setup a TCP server, having the TCP client passed to the handler's logic. It will read in a message from the stream, then write one back: Server { listen * : 30 tcp handler tcp { $msg = ( tcp read ) if ( $msg -ieq 'HELO' ) { tcp write 'HEY' } } } Parameters Name Type Required Description Default Type string true The type of 'TCP' to bind onto the handler (Values: TCP, SMTP) empty ScriptBlock scriptblock true The main handler logic that will be invoked when the an incoming TCP stream is detected null","title":"Handler"},{"location":"Functions/Core/Handler/#handler","text":"","title":"Handler"},{"location":"Functions/Core/Handler/#description","text":"The handler function allows you to bind logic onto incoming TCP streams, or onto SMTP requests. The SMTP handler type will use Pode's inbuilt simple SMTP server, which will automatically create a TCP listener on port 25 (unless you specific a different port to listen on). The handler logic in this case will be passed an argument containing information about the Email. The TCP handler will have the TCP client itself passed to the handler's logic, this way you can build your own custom TCP handler. Warning You can only have 1 handler per type. Ie, TCP can only have one handler defined, as well as SMTP.","title":"Description"},{"location":"Functions/Core/Handler/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Handler/#example-1","text":"The following example will setup the inbuilt simple SMTP server, writing to the terminal the content of the email: Server { listen * : 25 smtp handler smtp { param ( $email ) Write-Host $email . Data } } Tip The $email argument supplied to the SMTP handler contains the From and To address, as well as the Data of the email.","title":"Example 1"},{"location":"Functions/Core/Handler/#example-2","text":"The following example will setup a TCP server, having the TCP client passed to the handler's logic. It will read in a message from the stream, then write one back: Server { listen * : 30 tcp handler tcp { $msg = ( tcp read ) if ( $msg -ieq 'HELO' ) { tcp write 'HEY' } } }","title":"Example 2"},{"location":"Functions/Core/Handler/#parameters","text":"Name Type Required Description Default Type string true The type of 'TCP' to bind onto the handler (Values: TCP, SMTP) empty ScriptBlock scriptblock true The main handler logic that will be invoked when the an incoming TCP stream is detected null","title":"Parameters"},{"location":"Functions/Core/Import/","text":"Import Description The import function lets you declare paths to PowerShell Modules ( .psm1 / .psd1 ) that need to be imported into each runspace - you can also specify the name of a module you already have installed. Because Pode runs most things in isolated runspaces, importing and using external modules in Pode can be quite bothersome, with import Pode will handle importing your modules into all runspaces for you. If a module name is used rather than a raw path, then Pode will check you're server's ps_modules directory first, and then check your globally installed modules. Examples Example 1 The following example will import the specified module file into each of the runspaces that Pode creates. This way you'll be able to use each of the functions declared within the module in routes , timers , schedules , loggers , handlers , etc. (basically, everything): Server { import './path/to/module.psm1' } Example 2 The following example will import the EPS module, for views, into each of the runspaces: Server { import eps } Parameters Name Type Required Description Default Path string true The path to a PowerShell Module ( .psm1 / .psd1 ), or the name of an installed mode, that should be imported into the runspaces empty Now switch false If true, the module will be imported immediately into the current scope false","title":"Import"},{"location":"Functions/Core/Import/#import","text":"","title":"Import"},{"location":"Functions/Core/Import/#description","text":"The import function lets you declare paths to PowerShell Modules ( .psm1 / .psd1 ) that need to be imported into each runspace - you can also specify the name of a module you already have installed. Because Pode runs most things in isolated runspaces, importing and using external modules in Pode can be quite bothersome, with import Pode will handle importing your modules into all runspaces for you. If a module name is used rather than a raw path, then Pode will check you're server's ps_modules directory first, and then check your globally installed modules.","title":"Description"},{"location":"Functions/Core/Import/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Import/#example-1","text":"The following example will import the specified module file into each of the runspaces that Pode creates. This way you'll be able to use each of the functions declared within the module in routes , timers , schedules , loggers , handlers , etc. (basically, everything): Server { import './path/to/module.psm1' }","title":"Example 1"},{"location":"Functions/Core/Import/#example-2","text":"The following example will import the EPS module, for views, into each of the runspaces: Server { import eps }","title":"Example 2"},{"location":"Functions/Core/Import/#parameters","text":"Name Type Required Description Default Path string true The path to a PowerShell Module ( .psm1 / .psd1 ), or the name of an installed mode, that should be imported into the runspaces empty Now switch false If true, the module will be imported immediately into the current scope false","title":"Parameters"},{"location":"Functions/Core/Listen/","text":"Listen Description The listen function allows you to specify the IP/Host, Port and Protocol for endpoints that your Server will listen on. If the protocol is https then you can also specify a certificate to bind, even having Pode create a self-signed certificate for you. The listen function will check for administrator privileges on Windows, unless the endpoint you're attempting to listen on is a localhost one. Note You can specify multiple endpoints to listen on for HTTP/HTTPS endpoints however, you can only supply a single endpoint for SMTP/TCP Examples Example 1 The following example will listen on every IP over port 8080 for HTTP requests: Server { listen * : 8080 http } Example 2 The following example will listen on localhost over port 25 for SMTP requests (this will not require administrator privileges): Server { listen 127 . 0 . 0 . 1 : 25 smtp } Example 3 The following example will listen on a specific IP address over port 8443 for HTTPS requests; it will also inform Pode to create and bind a self-signed certificate to the IP:Port: Server { listen 10 . 10 . 1 . 4 : 8443 https -cert self } Example 4 The following example will listen on a specific host name over port 8080 for HTTP requests: Server { listen pode . foo . com : 8080 http } Example 5 The following example will listen on a wildcard endpoint over port 8080 for HTTP requests: Server { listen *. foo . com : 8080 http } Example 6 The following example will listen on multiple endpoints for HTTP (Note, you can specify a combination of HTTP/HTTPS endpoints): Server { listen pode . foo . com : 8080 http listen pode . bar . com : 8080 http } Parameters Name Type Required Description Default IPPort string true The IP/Host:Port combination for an endpoint that the server should listen on null Type string true The protocol of the endpoint the server should use: HTTP, HTTPS, SMTP, TCP null Cert string false The certificate to bind to the endpoint. If the certificate is self then Pode will create a self-signed certificate. If the certificate is *.example.com then it must be installed to Cert:/LocalMachine/My empty Name string false A unique name for this endpoint, which can be used on the route and gui functions empty Force switch false If supplied, will force the listen function to not run the administrator check false","title":"Listen"},{"location":"Functions/Core/Listen/#listen","text":"","title":"Listen"},{"location":"Functions/Core/Listen/#description","text":"The listen function allows you to specify the IP/Host, Port and Protocol for endpoints that your Server will listen on. If the protocol is https then you can also specify a certificate to bind, even having Pode create a self-signed certificate for you. The listen function will check for administrator privileges on Windows, unless the endpoint you're attempting to listen on is a localhost one. Note You can specify multiple endpoints to listen on for HTTP/HTTPS endpoints however, you can only supply a single endpoint for SMTP/TCP","title":"Description"},{"location":"Functions/Core/Listen/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Listen/#example-1","text":"The following example will listen on every IP over port 8080 for HTTP requests: Server { listen * : 8080 http }","title":"Example 1"},{"location":"Functions/Core/Listen/#example-2","text":"The following example will listen on localhost over port 25 for SMTP requests (this will not require administrator privileges): Server { listen 127 . 0 . 0 . 1 : 25 smtp }","title":"Example 2"},{"location":"Functions/Core/Listen/#example-3","text":"The following example will listen on a specific IP address over port 8443 for HTTPS requests; it will also inform Pode to create and bind a self-signed certificate to the IP:Port: Server { listen 10 . 10 . 1 . 4 : 8443 https -cert self }","title":"Example 3"},{"location":"Functions/Core/Listen/#example-4","text":"The following example will listen on a specific host name over port 8080 for HTTP requests: Server { listen pode . foo . com : 8080 http }","title":"Example 4"},{"location":"Functions/Core/Listen/#example-5","text":"The following example will listen on a wildcard endpoint over port 8080 for HTTP requests: Server { listen *. foo . com : 8080 http }","title":"Example 5"},{"location":"Functions/Core/Listen/#example-6","text":"The following example will listen on multiple endpoints for HTTP (Note, you can specify a combination of HTTP/HTTPS endpoints): Server { listen pode . foo . com : 8080 http listen pode . bar . com : 8080 http }","title":"Example 6"},{"location":"Functions/Core/Listen/#parameters","text":"Name Type Required Description Default IPPort string true The IP/Host:Port combination for an endpoint that the server should listen on null Type string true The protocol of the endpoint the server should use: HTTP, HTTPS, SMTP, TCP null Cert string false The certificate to bind to the endpoint. If the certificate is self then Pode will create a self-signed certificate. If the certificate is *.example.com then it must be installed to Cert:/LocalMachine/My empty Name string false A unique name for this endpoint, which can be used on the route and gui functions empty Force switch false If supplied, will force the listen function to not run the administrator check false","title":"Parameters"},{"location":"Functions/Core/Load/","text":"Load Description The load function can be used to dot-source other PowerShell scripts into your server. While normal dot-sourcing still works as normal in Pode, this function is used to aid relative paths when running your server as a Service (as relative paths may resolve from where the service is running, and not where the server is running). Examples Example 1 The following example will run the given PowerShell script, creating any routes , etc., that are needed. Because the path is relative, the server's root path will be automatically added: Server { load './routes/api.ps1' } Parameters Name Type Required Description Default Path string true The path to a PowerShell script ( .ps1 ) that needs to be dot-sourced empty","title":"Load"},{"location":"Functions/Core/Load/#load","text":"","title":"Load"},{"location":"Functions/Core/Load/#description","text":"The load function can be used to dot-source other PowerShell scripts into your server. While normal dot-sourcing still works as normal in Pode, this function is used to aid relative paths when running your server as a Service (as relative paths may resolve from where the service is running, and not where the server is running).","title":"Description"},{"location":"Functions/Core/Load/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Load/#example-1","text":"The following example will run the given PowerShell script, creating any routes , etc., that are needed. Because the path is relative, the server's root path will be automatically added: Server { load './routes/api.ps1' }","title":"Example 1"},{"location":"Functions/Core/Load/#parameters","text":"Name Type Required Description Default Path string true The path to a PowerShell script ( .ps1 ) that needs to be dot-sourced empty","title":"Parameters"},{"location":"Functions/Core/Logger/","text":"Logger Description The logger function allows you to define inbuilt/custom log tools within your server that will send Combined Log Format rows to either the terminal, a file, or a custom script that will allow you to log to a variety of services - e.g. Splunk/FluentD/LogStash. When logging to a file, you can specify a custom path to create the log files, as well as a defined number of days to keep the log files. Examples Example 1 The following example will log web events to the terminal: Server { logger terminal } Example 2 The following example will log web events to a file. The log files will be placed at c:\\logs (default is /logs at the root), and will be split down by day; they will also only be kept for 7 days (default is forever) - any log file older than 7 days will automatically be deleted: Server { logger file @{ 'Path' = 'c:/logs/' ; 'MaxDays' = 7 ; } } Info The hashtable supplied to logger file is optional. If no Path is supplied then a /logs directory will be created at the server script root path, and if MaxDays is <= 0 then the log files will be kept forever. Example 3 The following example will create a custom log tool that outputs the request method/resource to the terminal. For custom loggers a scriptblock must be supplied - the script will be supplied a single argument, which is a log object contains details of the request/response: Server { logger -c terminal { param ( $obj ) $method = $obj . Log . Request . Method $resource = $obj . Log . Request . Resource \"[ $( $method ) ] $( $resource ) \" | Out-Default } } The .Log object will have the following structure: @{ 'Host' = '10.10.0.3' ; 'RfcUserIdentity' = '-' ; 'User' = '-' ; 'Date' = '14/Jun/2018:20:23:52 +01:00' ; 'Request' = @{ 'Method' = 'GET' ; 'Resource' = '/api/users' ; 'Protocol' = \"HTTP/1.1\" ; 'Referrer' = '-' ; 'Agent' = '<user-agent>' ; }; 'Response' = @{ 'StatusCode' = '200' ; 'StautsDescription' = 'OK' 'Size' = '9001' ; }; } Parameters Name Type Required Description Default Name string true The name of the logger; inbuilt loggers are terminal and file . Custom loggers can have any name, but the -Custom switch must be supplied empty Details object false For inbuilt loggers this should be a hashtable . For custom loggers this should be the custom scriptblock to define how the logger works null Custom switch false When supplied, will configure the logger defined as being custom false","title":"Logger"},{"location":"Functions/Core/Logger/#logger","text":"","title":"Logger"},{"location":"Functions/Core/Logger/#description","text":"The logger function allows you to define inbuilt/custom log tools within your server that will send Combined Log Format rows to either the terminal, a file, or a custom script that will allow you to log to a variety of services - e.g. Splunk/FluentD/LogStash. When logging to a file, you can specify a custom path to create the log files, as well as a defined number of days to keep the log files.","title":"Description"},{"location":"Functions/Core/Logger/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Logger/#example-1","text":"The following example will log web events to the terminal: Server { logger terminal }","title":"Example 1"},{"location":"Functions/Core/Logger/#example-2","text":"The following example will log web events to a file. The log files will be placed at c:\\logs (default is /logs at the root), and will be split down by day; they will also only be kept for 7 days (default is forever) - any log file older than 7 days will automatically be deleted: Server { logger file @{ 'Path' = 'c:/logs/' ; 'MaxDays' = 7 ; } } Info The hashtable supplied to logger file is optional. If no Path is supplied then a /logs directory will be created at the server script root path, and if MaxDays is <= 0 then the log files will be kept forever.","title":"Example 2"},{"location":"Functions/Core/Logger/#example-3","text":"The following example will create a custom log tool that outputs the request method/resource to the terminal. For custom loggers a scriptblock must be supplied - the script will be supplied a single argument, which is a log object contains details of the request/response: Server { logger -c terminal { param ( $obj ) $method = $obj . Log . Request . Method $resource = $obj . Log . Request . Resource \"[ $( $method ) ] $( $resource ) \" | Out-Default } } The .Log object will have the following structure: @{ 'Host' = '10.10.0.3' ; 'RfcUserIdentity' = '-' ; 'User' = '-' ; 'Date' = '14/Jun/2018:20:23:52 +01:00' ; 'Request' = @{ 'Method' = 'GET' ; 'Resource' = '/api/users' ; 'Protocol' = \"HTTP/1.1\" ; 'Referrer' = '-' ; 'Agent' = '<user-agent>' ; }; 'Response' = @{ 'StatusCode' = '200' ; 'StautsDescription' = 'OK' 'Size' = '9001' ; }; }","title":"Example 3"},{"location":"Functions/Core/Logger/#parameters","text":"Name Type Required Description Default Name string true The name of the logger; inbuilt loggers are terminal and file . Custom loggers can have any name, but the -Custom switch must be supplied empty Details object false For inbuilt loggers this should be a hashtable . For custom loggers this should be the custom scriptblock to define how the logger works null Custom switch false When supplied, will configure the logger defined as being custom false","title":"Parameters"},{"location":"Functions/Core/Middleware/","text":"Middleware Description The middleware function allows you to add middleware scripts, that run prior to route logic. They allow you to do things like rate-limiting, access restriction, authentication, sessions, etc. Middleware in Pode allows you to observe and edit the request/response objects for a current web event - you can alter the response, add custom objects to the request for later use, or terminate the response without processing the route logic. Examples Example 1 The following example is middleware that observes the user agent of the request. If the request comes from a PowerShell session then stop processing and return forbidden, otherwise create a new Agent key on the event for later middleware / route : Server { middleware { param ( $event ) if ( $event . Request . UserAgent -ilike '*powershell*' ) { status 403 return $false } $event . Agent = $event . Request . UserAgent return $true } } Example 2 The following example uses rate limiting, and defines middleware that will override the inbuilt rate limiting middleware logic so that it never limits requests: Server { listen * : 8080 http limit ip @( '127.0.0.1' , '[::1]' ) 8 5 middleware -Name '@limit' { return $true } route get '/' { # logic } } Example 3 The following example is middleware that only runs on /api routes. If the request comes from a PowerShell session then stop processing and return forbidden, otherwise create a new Agent key on the event for later middleware / route : Server { middleware '/api' { param ( $event ) if ( $event . Request . UserAgent -ilike '*powershell*' ) { status 403 return $false } $event . Agent = $event . Request . UserAgent return $true } } Example 4 The following example is middleware that will run Basic authenticaion validation on every /api request (assumes authentication has been set-up): Server { middleware '/api' ( auth check basic ) } Parameters Name Type Required Description Default ScriptBlock scriptblock true if no hashtable Main logic for the middleware; the scriptblock will be supplied a single parameter which contains the Request and Response objects null HashTable hashtable true if no scriptblock Main logic for the middleware; the hashtable requires a 'Logic' key with a scriptblock value (with the same rules as above) null Route string false Specifies which routes the middleware should be invoked on / Name string false Only use this parameter if you plan to override any of the inbuilt middleware. Names for the inbuilt middleware can be found below empty Return switch false If supplied, the middleware won't be added but will instead be returned - for use on specific routes false Notes Middleware in Pode is executed in a specific order due to having inbuilt middleware, this order of running is as follows: Access control - allowing/denying IP addresses (if access logic is defined) Rate limiting - limiting access to IP addresses (if limit logic is defined) Public content - static content such as images/css/js/html in the /public directory (or other defined static paths) Body parsing - parsing request payload a JSON or XML Querystring - getting any query string parameters currently on the request URL Custom middleware - runs any defined middleware in the order it was created Route middleware - runs any route middleware for the current route being processed Route - finally, the route itself is processed Pode has some inbuilt middleware, as defined in the order of running above. Sometimes you probably don't want to use the inbuilt rate limiting, and use a custom rate limiting library that utilises REDIS instead. Each of the inbuilt middlewares have a defined name, that you can pass to the middleware function via -Name : Access control - @access Rate limiting - @limit Public content - @public Body parsing - @body Querystring - @query An example of overriding the inbuilt middleware can be found in the examples above","title":"Middleware"},{"location":"Functions/Core/Middleware/#middleware","text":"","title":"Middleware"},{"location":"Functions/Core/Middleware/#description","text":"The middleware function allows you to add middleware scripts, that run prior to route logic. They allow you to do things like rate-limiting, access restriction, authentication, sessions, etc. Middleware in Pode allows you to observe and edit the request/response objects for a current web event - you can alter the response, add custom objects to the request for later use, or terminate the response without processing the route logic.","title":"Description"},{"location":"Functions/Core/Middleware/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Middleware/#example-1","text":"The following example is middleware that observes the user agent of the request. If the request comes from a PowerShell session then stop processing and return forbidden, otherwise create a new Agent key on the event for later middleware / route : Server { middleware { param ( $event ) if ( $event . Request . UserAgent -ilike '*powershell*' ) { status 403 return $false } $event . Agent = $event . Request . UserAgent return $true } }","title":"Example 1"},{"location":"Functions/Core/Middleware/#example-2","text":"The following example uses rate limiting, and defines middleware that will override the inbuilt rate limiting middleware logic so that it never limits requests: Server { listen * : 8080 http limit ip @( '127.0.0.1' , '[::1]' ) 8 5 middleware -Name '@limit' { return $true } route get '/' { # logic } }","title":"Example 2"},{"location":"Functions/Core/Middleware/#example-3","text":"The following example is middleware that only runs on /api routes. If the request comes from a PowerShell session then stop processing and return forbidden, otherwise create a new Agent key on the event for later middleware / route : Server { middleware '/api' { param ( $event ) if ( $event . Request . UserAgent -ilike '*powershell*' ) { status 403 return $false } $event . Agent = $event . Request . UserAgent return $true } }","title":"Example 3"},{"location":"Functions/Core/Middleware/#example-4","text":"The following example is middleware that will run Basic authenticaion validation on every /api request (assumes authentication has been set-up): Server { middleware '/api' ( auth check basic ) }","title":"Example 4"},{"location":"Functions/Core/Middleware/#parameters","text":"Name Type Required Description Default ScriptBlock scriptblock true if no hashtable Main logic for the middleware; the scriptblock will be supplied a single parameter which contains the Request and Response objects null HashTable hashtable true if no scriptblock Main logic for the middleware; the hashtable requires a 'Logic' key with a scriptblock value (with the same rules as above) null Route string false Specifies which routes the middleware should be invoked on / Name string false Only use this parameter if you plan to override any of the inbuilt middleware. Names for the inbuilt middleware can be found below empty Return switch false If supplied, the middleware won't be added but will instead be returned - for use on specific routes false","title":"Parameters"},{"location":"Functions/Core/Middleware/#notes","text":"Middleware in Pode is executed in a specific order due to having inbuilt middleware, this order of running is as follows: Access control - allowing/denying IP addresses (if access logic is defined) Rate limiting - limiting access to IP addresses (if limit logic is defined) Public content - static content such as images/css/js/html in the /public directory (or other defined static paths) Body parsing - parsing request payload a JSON or XML Querystring - getting any query string parameters currently on the request URL Custom middleware - runs any defined middleware in the order it was created Route middleware - runs any route middleware for the current route being processed Route - finally, the route itself is processed Pode has some inbuilt middleware, as defined in the order of running above. Sometimes you probably don't want to use the inbuilt rate limiting, and use a custom rate limiting library that utilises REDIS instead. Each of the inbuilt middlewares have a defined name, that you can pass to the middleware function via -Name : Access control - @access Rate limiting - @limit Public content - @public Body parsing - @body Querystring - @query An example of overriding the inbuilt middleware can be found in the examples above","title":"Notes"},{"location":"Functions/Core/Route/","text":"Route Description The route function allows you to bind logic to be invoked against a URL path and HTTP method. The function also accepts custom middleware to be invoked, before running the main route logic - such as authentication. You can also use the route function to specify routes to static content paths. Normally if you request a static file Pode will check the /public directory, but you can specify other paths using route static (example below). If you call a directory path with the directory structure, then a default file (such as index.html ) will be searched for and returned. Routes can also be bound against a specific protocol or endpoint. This allows you to bind multiple routes against different endpoints - if you're listening to multiple endpoints. Info The scriptblock supplied for the main route logic is invoked with a single parameter for the current web event. This parameter will contain the Request and Response objects; Data (from POST requests), and the Query (from the query string of the URL), as well as any Parameters from the route itself (eg: /:accountId ). Examples Example 1 The following example sets up a GET /ping route, that returns { \"value\": \"pong\" } : Server { listen * : 8080 http route get '/ping' { json @{ 'value' = 'ping' } } } Example 2 The following example sets up a GET /ping route, and then removes it: Server { listen * : 8080 http route get '/ping' { json @{ 'value' = 'ping' } } route -remove get '/ping' } Example 3 The following example sets up a POST /users route, that creates a new user using post data: Server { listen * : 8080 http route post '/users' { param ( $event ) # create the user using POST data $userId = New-DummyUser $event . Data . Email $event . Data . Name $event . Data . Password # return with userId json @{ 'userId' = $userId ; } } } Example 4 The following example sets up a static route of /assets using the directory ./content/assets . In the home.html view if you reference the image <img src=\"/assets/images/icon.png\" /> , then Pode will get the image from ./content/assets/images/icon.png . Server { listen * : 8080 http route static '/assets' './content/assets' route get '/' { view 'home' } } Tip Furthermore, if you attempt to navigate to http://localhost:8080/assets , then Pode will attempt to display a default page such as index.html - see here . Example 5 The following example sets up a GET /users/:userId route, that returns a user based on the route parameter userId : Server { listen * : 8080 http route get '/users/:userId' { param ( $event ) # get the user, using the parameter userId $user = Get-DummyUser -UserId $event . Parameters [ 'userId' ] # if no user, return 404 if ( $user -eq $null ) { status 404 } # return the user object json @{ 'user' = $user ; } } } Example 6 The following example sets up a GET / route, that has custom middleware to check the user agent first. If the user agent is from PowerShell deny the call, and don't invoke the route's logic: Server { listen * : 8080 http $agent_mid = { param ( $event ) if ( $event . Request . UserAgent -ilike '*powershell*' ) { status 403 # stop running return $false } $event . Agent = $event . Request . UserAgent # run the route logic return $true } route get '/' $agent_mid { view 'index' } } Example 7 The following example sets up two GET /ping routes: one that applies to only http requests, and another for everything else: Server { listen * : 8080 http route get '/ping' { json @{ 'value' = 'ping' } } route get '/ping' -protocol http { json @{ 'value' = 'pong' } } } Example 8 The following example sets up two GET /ping routes: one that applies to one endpoint, and the other to the other endpoint: Server { listen pode . foo . com : 8080 http listen pode . bar . com : 8080 http route get '/ping' -endpoint pode . foo . com { json @{ 'value' = 'ping' } } route get '/ping' -endpoint pode . bar . com { json @{ 'value' = 'pong' } } } Example 9 The following example sets up two GET /ping routes: one that applies to one endpoint, and the other to the other endpoint; this is done using the name supplied to the listen function: Server { listen pode . foo . com : 8080 http -name 'pode1' listen pode . bar . com : 8080 http -name 'pode2' route get '/ping' -listenName 'pode1' { json @{ 'value' = 'ping' } } route get '/ping' -listenName 'pode2' { json @{ 'value' = 'pong' } } } Parameters Name Type Required Description Default HttpMethod string true The HTTP method to bind the route onto (Values: DELETE, GET, HEAD, MERGE, OPTIONS, PATCH, POST, PUT, TRACE, STATIC, *) null Route string true The route path to listen on, the root path is / . The path can also contain parameters such as /:userId empty Middleware object[] false Custom middleware for the route that will be invoked before the main logic is invoked - such as authentication. For non-static routes this is an array of scriptblocks , but for a static route this is the path to the static content directory null ScriptBlock scriptblock true The main route logic that will be invoked when the route endpoint is hit null Defaults string[] false For static routes only, this is an array of default pages that could be displayed when the static directory is called ['index.html', 'index.htm', 'default.html', 'default.htm'] Protocol string false The protocol to bind the route against (Values: Empty, HTTP, HTTPS) empty Endpoint string false The endpoint to bind the route against - this will typically be the endpoint used in your listen function empty ListenName string false The name of a listen endpoint to bind the route against. This can be use instead of -Protocol and -Endpoint , but if used with them, will override their values empty Remove switch false When passed, will remove a defined route false Tip The special * method allows you to bind a route against every HTTP method. This method takes priority over the other methods; if you have a route for / against GET and * , then the * method will be used.","title":"Route"},{"location":"Functions/Core/Route/#route","text":"","title":"Route"},{"location":"Functions/Core/Route/#description","text":"The route function allows you to bind logic to be invoked against a URL path and HTTP method. The function also accepts custom middleware to be invoked, before running the main route logic - such as authentication. You can also use the route function to specify routes to static content paths. Normally if you request a static file Pode will check the /public directory, but you can specify other paths using route static (example below). If you call a directory path with the directory structure, then a default file (such as index.html ) will be searched for and returned. Routes can also be bound against a specific protocol or endpoint. This allows you to bind multiple routes against different endpoints - if you're listening to multiple endpoints. Info The scriptblock supplied for the main route logic is invoked with a single parameter for the current web event. This parameter will contain the Request and Response objects; Data (from POST requests), and the Query (from the query string of the URL), as well as any Parameters from the route itself (eg: /:accountId ).","title":"Description"},{"location":"Functions/Core/Route/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Route/#example-1","text":"The following example sets up a GET /ping route, that returns { \"value\": \"pong\" } : Server { listen * : 8080 http route get '/ping' { json @{ 'value' = 'ping' } } }","title":"Example 1"},{"location":"Functions/Core/Route/#example-2","text":"The following example sets up a GET /ping route, and then removes it: Server { listen * : 8080 http route get '/ping' { json @{ 'value' = 'ping' } } route -remove get '/ping' }","title":"Example 2"},{"location":"Functions/Core/Route/#example-3","text":"The following example sets up a POST /users route, that creates a new user using post data: Server { listen * : 8080 http route post '/users' { param ( $event ) # create the user using POST data $userId = New-DummyUser $event . Data . Email $event . Data . Name $event . Data . Password # return with userId json @{ 'userId' = $userId ; } } }","title":"Example 3"},{"location":"Functions/Core/Route/#example-4","text":"The following example sets up a static route of /assets using the directory ./content/assets . In the home.html view if you reference the image <img src=\"/assets/images/icon.png\" /> , then Pode will get the image from ./content/assets/images/icon.png . Server { listen * : 8080 http route static '/assets' './content/assets' route get '/' { view 'home' } } Tip Furthermore, if you attempt to navigate to http://localhost:8080/assets , then Pode will attempt to display a default page such as index.html - see here .","title":"Example 4"},{"location":"Functions/Core/Route/#example-5","text":"The following example sets up a GET /users/:userId route, that returns a user based on the route parameter userId : Server { listen * : 8080 http route get '/users/:userId' { param ( $event ) # get the user, using the parameter userId $user = Get-DummyUser -UserId $event . Parameters [ 'userId' ] # if no user, return 404 if ( $user -eq $null ) { status 404 } # return the user object json @{ 'user' = $user ; } } }","title":"Example 5"},{"location":"Functions/Core/Route/#example-6","text":"The following example sets up a GET / route, that has custom middleware to check the user agent first. If the user agent is from PowerShell deny the call, and don't invoke the route's logic: Server { listen * : 8080 http $agent_mid = { param ( $event ) if ( $event . Request . UserAgent -ilike '*powershell*' ) { status 403 # stop running return $false } $event . Agent = $event . Request . UserAgent # run the route logic return $true } route get '/' $agent_mid { view 'index' } }","title":"Example 6"},{"location":"Functions/Core/Route/#example-7","text":"The following example sets up two GET /ping routes: one that applies to only http requests, and another for everything else: Server { listen * : 8080 http route get '/ping' { json @{ 'value' = 'ping' } } route get '/ping' -protocol http { json @{ 'value' = 'pong' } } }","title":"Example 7"},{"location":"Functions/Core/Route/#example-8","text":"The following example sets up two GET /ping routes: one that applies to one endpoint, and the other to the other endpoint: Server { listen pode . foo . com : 8080 http listen pode . bar . com : 8080 http route get '/ping' -endpoint pode . foo . com { json @{ 'value' = 'ping' } } route get '/ping' -endpoint pode . bar . com { json @{ 'value' = 'pong' } } }","title":"Example 8"},{"location":"Functions/Core/Route/#example-9","text":"The following example sets up two GET /ping routes: one that applies to one endpoint, and the other to the other endpoint; this is done using the name supplied to the listen function: Server { listen pode . foo . com : 8080 http -name 'pode1' listen pode . bar . com : 8080 http -name 'pode2' route get '/ping' -listenName 'pode1' { json @{ 'value' = 'ping' } } route get '/ping' -listenName 'pode2' { json @{ 'value' = 'pong' } } }","title":"Example 9"},{"location":"Functions/Core/Route/#parameters","text":"Name Type Required Description Default HttpMethod string true The HTTP method to bind the route onto (Values: DELETE, GET, HEAD, MERGE, OPTIONS, PATCH, POST, PUT, TRACE, STATIC, *) null Route string true The route path to listen on, the root path is / . The path can also contain parameters such as /:userId empty Middleware object[] false Custom middleware for the route that will be invoked before the main logic is invoked - such as authentication. For non-static routes this is an array of scriptblocks , but for a static route this is the path to the static content directory null ScriptBlock scriptblock true The main route logic that will be invoked when the route endpoint is hit null Defaults string[] false For static routes only, this is an array of default pages that could be displayed when the static directory is called ['index.html', 'index.htm', 'default.html', 'default.htm'] Protocol string false The protocol to bind the route against (Values: Empty, HTTP, HTTPS) empty Endpoint string false The endpoint to bind the route against - this will typically be the endpoint used in your listen function empty ListenName string false The name of a listen endpoint to bind the route against. This can be use instead of -Protocol and -Endpoint , but if used with them, will override their values empty Remove switch false When passed, will remove a defined route false Tip The special * method allows you to bind a route against every HTTP method. This method takes priority over the other methods; if you have a route for / against GET and * , then the * method will be used.","title":"Parameters"},{"location":"Functions/Core/Schedule/","text":"Schedule Description The schedule function lets you create long-running async tasks. Unlike a timer , when a schedule is triggered its logic is run in its own runspace - so they don't affect each other if they take a while to process. Schedule triggers are defined using cron expressions , basic syntax is supported as well as some predefined expressions. They can start immediately, have a delayed start time, and also have a a defined end time. Examples Example 1 The following example will create a schedule that triggers every Tuesday at midnight, but will only trigger 4 times: Server { schedule 'tuesdays' '0 0 * * TUE' -limit 4 { # logic } } Example 2 The following example will create a schedule that triggers every 5 past the hour, starting in 2hrs: Server { schedule 'hourly-start' '5 * * * *' -start ( [DateTime] :: Now . AddHours ( 2 )) { # logic } } Example 3 The following example will create a schedule using a predefined cron to trigger every minute: Server { schedule 'minutely' '@minutely' { # logic } } Example 4 The following example will create a schedule using multiple predefined cron expressions to trigger every minute and every hour: Server { schedule 'minutely' @( '@minutely' , '@hourly' ) { # logic } } Parameters Name Type Required Description Default Name string true A unique name for the schedule empty Cron string[] true A cron expression, or multiple cron expressions, that define when the schedule should trigger empty ScriptBlock scriptblock true The main logic that will be invoked on each trigger null StartTime datetime false Defines when the schedule should start now EndTime datetime false Defines when the schedule should end never Limit int false The number of times the schedule should trigger before it is removed; 0 is unlimited 0","title":"Schedule"},{"location":"Functions/Core/Schedule/#schedule","text":"","title":"Schedule"},{"location":"Functions/Core/Schedule/#description","text":"The schedule function lets you create long-running async tasks. Unlike a timer , when a schedule is triggered its logic is run in its own runspace - so they don't affect each other if they take a while to process. Schedule triggers are defined using cron expressions , basic syntax is supported as well as some predefined expressions. They can start immediately, have a delayed start time, and also have a a defined end time.","title":"Description"},{"location":"Functions/Core/Schedule/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Schedule/#example-1","text":"The following example will create a schedule that triggers every Tuesday at midnight, but will only trigger 4 times: Server { schedule 'tuesdays' '0 0 * * TUE' -limit 4 { # logic } }","title":"Example 1"},{"location":"Functions/Core/Schedule/#example-2","text":"The following example will create a schedule that triggers every 5 past the hour, starting in 2hrs: Server { schedule 'hourly-start' '5 * * * *' -start ( [DateTime] :: Now . AddHours ( 2 )) { # logic } }","title":"Example 2"},{"location":"Functions/Core/Schedule/#example-3","text":"The following example will create a schedule using a predefined cron to trigger every minute: Server { schedule 'minutely' '@minutely' { # logic } }","title":"Example 3"},{"location":"Functions/Core/Schedule/#example-4","text":"The following example will create a schedule using multiple predefined cron expressions to trigger every minute and every hour: Server { schedule 'minutely' @( '@minutely' , '@hourly' ) { # logic } }","title":"Example 4"},{"location":"Functions/Core/Schedule/#parameters","text":"Name Type Required Description Default Name string true A unique name for the schedule empty Cron string[] true A cron expression, or multiple cron expressions, that define when the schedule should trigger empty ScriptBlock scriptblock true The main logic that will be invoked on each trigger null StartTime datetime false Defines when the schedule should start now EndTime datetime false Defines when the schedule should end never Limit int false The number of times the schedule should trigger before it is removed; 0 is unlimited 0","title":"Parameters"},{"location":"Functions/Core/Server/","text":"Server Description The Server function is the most important function throughout all of Pode, as it's the only function that is mandatory in your scripts. Within the scriptblock supplied to the Server is where you place all of your main server logic - routes, timers, middleware, etc. Warning You can only have one Server declared within your script Examples Example 1 The following example will run the scriptblock once, printing out Hello, world! , and then exit: Server { Write-Host 'Hello, world!' } Example 2 The following will start a server that repeats the scriptblock every 5 seconds: Server -Interval 5 { Write-Host 'Hey!' } Example 3 The following server will accept web requests, and handle them across 2 threads rather than 1: Server -Thread 2 { # route logic } Example 4 The following server will restart when it detects a file has been changed. Ie, if you start the server and then alter a web page, or change a dot-sourced script, then the server will restart: Server -FileMonitor { # route logic } Parameters Name Type Required Description Default ScriptBlock scriptblock true The main closure that contains the core server logic null Interval int false Specifies, in seconds, the time to sleep before looping the ScriptBlock logic 0 Threads int false Specifies the number of runspaces used to handle incoming requests 1 DisableTermination switch false Toggles the ability to allow using Ctrl+C to terminate the server false DisableLogging switch false Toggles any logging that has been setup. When true all logging is disabled false FileMonitor switch false When passed, any file changes will cause the server to restart false","title":"Server"},{"location":"Functions/Core/Server/#server","text":"","title":"Server"},{"location":"Functions/Core/Server/#description","text":"The Server function is the most important function throughout all of Pode, as it's the only function that is mandatory in your scripts. Within the scriptblock supplied to the Server is where you place all of your main server logic - routes, timers, middleware, etc. Warning You can only have one Server declared within your script","title":"Description"},{"location":"Functions/Core/Server/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Server/#example-1","text":"The following example will run the scriptblock once, printing out Hello, world! , and then exit: Server { Write-Host 'Hello, world!' }","title":"Example 1"},{"location":"Functions/Core/Server/#example-2","text":"The following will start a server that repeats the scriptblock every 5 seconds: Server -Interval 5 { Write-Host 'Hey!' }","title":"Example 2"},{"location":"Functions/Core/Server/#example-3","text":"The following server will accept web requests, and handle them across 2 threads rather than 1: Server -Thread 2 { # route logic }","title":"Example 3"},{"location":"Functions/Core/Server/#example-4","text":"The following server will restart when it detects a file has been changed. Ie, if you start the server and then alter a web page, or change a dot-sourced script, then the server will restart: Server -FileMonitor { # route logic }","title":"Example 4"},{"location":"Functions/Core/Server/#parameters","text":"Name Type Required Description Default ScriptBlock scriptblock true The main closure that contains the core server logic null Interval int false Specifies, in seconds, the time to sleep before looping the ScriptBlock logic 0 Threads int false Specifies the number of runspaces used to handle incoming requests 1 DisableTermination switch false Toggles the ability to allow using Ctrl+C to terminate the server false DisableLogging switch false Toggles any logging that has been setup. When true all logging is disabled false FileMonitor switch false When passed, any file changes will cause the server to restart false","title":"Parameters"},{"location":"Functions/Core/Timer/","text":"Timer Description The timer function allows you to setup short-running async tasks, that run periodically along side your main server logic; they have unique names, and iterate on a defined number of seconds. Info All timers are created and run within the same runspace, one after another when their trigger time occurs. You should ensure that a timer's defined logic is not long-running (things like heavy database tasks or reporting), as this will delay other timers from being run. For timers that might take a much longer time to run, try using schedule instead Examples Example 1 The following example is a timer that runs for ever, every 5secs: Server { timer 'forever' 5 { # logic } } Example 2 The following example is a timer that will skip the first 3 iterations, and after 15secs (3x5) will loop every 5secs: Server { timer 'skip-first-3' 5 -skip 3 { # logic } } Example 3 The following example is a timer that runs once after waiting for 2mins: Server { timer 'run-once' 120 -skip 1 -limit 1 { # logic } } Example 4 The following example will create a new timer every time the route is called - the route expects two query string parameters of Name an Seconds : Server { route 'get' '/api/timer' { param ( $event ) $query = $event . Query timer $query [ 'Name' ] $query [ 'Seconds' ] { # logic } } } Parameters Name Type Required Description Default Name string true The unique name of the timer empty Interval int true The number of seconds between each iteration 0 ScriptBlock scriptblock true The main logic that will be invoked on each timer iteration null Limit int false The number of iterations that should be invoked before the timer is removed; 0 is unlimited 0 Skip int false The number of iterations to skip before invoking timer logic 0","title":"Timer"},{"location":"Functions/Core/Timer/#timer","text":"","title":"Timer"},{"location":"Functions/Core/Timer/#description","text":"The timer function allows you to setup short-running async tasks, that run periodically along side your main server logic; they have unique names, and iterate on a defined number of seconds. Info All timers are created and run within the same runspace, one after another when their trigger time occurs. You should ensure that a timer's defined logic is not long-running (things like heavy database tasks or reporting), as this will delay other timers from being run. For timers that might take a much longer time to run, try using schedule instead","title":"Description"},{"location":"Functions/Core/Timer/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Timer/#example-1","text":"The following example is a timer that runs for ever, every 5secs: Server { timer 'forever' 5 { # logic } }","title":"Example 1"},{"location":"Functions/Core/Timer/#example-2","text":"The following example is a timer that will skip the first 3 iterations, and after 15secs (3x5) will loop every 5secs: Server { timer 'skip-first-3' 5 -skip 3 { # logic } }","title":"Example 2"},{"location":"Functions/Core/Timer/#example-3","text":"The following example is a timer that runs once after waiting for 2mins: Server { timer 'run-once' 120 -skip 1 -limit 1 { # logic } }","title":"Example 3"},{"location":"Functions/Core/Timer/#example-4","text":"The following example will create a new timer every time the route is called - the route expects two query string parameters of Name an Seconds : Server { route 'get' '/api/timer' { param ( $event ) $query = $event . Query timer $query [ 'Name' ] $query [ 'Seconds' ] { # logic } } }","title":"Example 4"},{"location":"Functions/Core/Timer/#parameters","text":"Name Type Required Description Default Name string true The unique name of the timer empty Interval int true The number of seconds between each iteration 0 ScriptBlock scriptblock true The main logic that will be invoked on each timer iteration null Limit int false The number of iterations that should be invoked before the timer is removed; 0 is unlimited 0 Skip int false The number of iterations to skip before invoking timer logic 0","title":"Parameters"},{"location":"Functions/Helpers/Coalesce/","text":"Coalesce Description The coalesce function will return the first argument if it's not $null or empty , otherwise the second argument is returned. Examples Example 1 The following example will use the second value and output Hello! , because the first is $null : Server { $msg = ( coalesce $null 'Hello!' ) Write-Host $msg } Parameters Name Type Required Description Default Value1 object false The first value to check if it's $null null Value2 object false The second value to use if the first is $null null","title":"Coalesce"},{"location":"Functions/Helpers/Coalesce/#coalesce","text":"","title":"Coalesce"},{"location":"Functions/Helpers/Coalesce/#description","text":"The coalesce function will return the first argument if it's not $null or empty , otherwise the second argument is returned.","title":"Description"},{"location":"Functions/Helpers/Coalesce/#examples","text":"","title":"Examples"},{"location":"Functions/Helpers/Coalesce/#example-1","text":"The following example will use the second value and output Hello! , because the first is $null : Server { $msg = ( coalesce $null 'Hello!' ) Write-Host $msg }","title":"Example 1"},{"location":"Functions/Helpers/Coalesce/#parameters","text":"Name Type Required Description Default Value1 object false The first value to check if it's $null null Value2 object false The second value to use if the first is $null null","title":"Parameters"},{"location":"Functions/Helpers/Get-PodeConfiguration/","text":"Get-PodeConfiguration Description The Get-PodeConfiguration function returns the loaded contents of the pode.json (or pode.ENV.json ) configuration file. If no configuration file exists, then an empty hashtable will be returned. Examples Example 1 The following example load the pode.json file, and bind onto the port number (80) in the configuration: pode.json { \"port\" : 80 } server.ps1 Server { $port = ( Get-PodeConfiguration ). port listen * : $port http } Example 2 The following example has a pode.json and pode.dev.json . When the you set $env:PODE_ENVIRONMENT = 'dev' , then Pode will automatically load the pode.dev.json file. When using Get-PodeConfiguration for the port number, the dev one of 8080 will be used: pode.json { \"port\" : 80 } pode.dev.json { \"port\" : 8080 } server.ps1 Server { $port = ( Get-PodeConfiguration ). port listen * : $port http }","title":"Get-PodeConfiguration"},{"location":"Functions/Helpers/Get-PodeConfiguration/#get-podeconfiguration","text":"","title":"Get-PodeConfiguration"},{"location":"Functions/Helpers/Get-PodeConfiguration/#description","text":"The Get-PodeConfiguration function returns the loaded contents of the pode.json (or pode.ENV.json ) configuration file. If no configuration file exists, then an empty hashtable will be returned.","title":"Description"},{"location":"Functions/Helpers/Get-PodeConfiguration/#examples","text":"","title":"Examples"},{"location":"Functions/Helpers/Get-PodeConfiguration/#example-1","text":"The following example load the pode.json file, and bind onto the port number (80) in the configuration: pode.json { \"port\" : 80 } server.ps1 Server { $port = ( Get-PodeConfiguration ). port listen * : $port http }","title":"Example 1"},{"location":"Functions/Helpers/Get-PodeConfiguration/#example-2","text":"The following example has a pode.json and pode.dev.json . When the you set $env:PODE_ENVIRONMENT = 'dev' , then Pode will automatically load the pode.dev.json file. When using Get-PodeConfiguration for the port number, the dev one of 8080 will be used: pode.json { \"port\" : 80 } pode.dev.json { \"port\" : 8080 } server.ps1 Server { $port = ( Get-PodeConfiguration ). port listen * : $port http }","title":"Example 2"},{"location":"Functions/Helpers/Invoke-ScriptBlock/","text":"Invoke-ScriptBlock Description The Invoke-ScriptBlock function takes a scriptblock and invokes it. You can specify arguments to pass to the script, and whether a value should be returned. By default the scriptblock will have the GetNewClosure() method called, and will be invoked in the current scope; these can be toggled via -NoNewClosure and -Scoped respectively. If any arguments are supplied, they will be supplied as a single argument to the scriptblock. By using the -Splat switch, then if the arguments are an array/hashtable they will be passed as multiple arguments instead. Examples Example 1 The following example will invoke a scriptblock outside of the current scope: Server { Invoke-ScriptBlock -Scoped { Write-Host 'Hello, world!' } } Example 2 The following example will invoke a scriptblock, passing it arguments and returning a value: Server { $ht = @{ 'Name' = 'Bob' ; 'Age' = 32 ; } $value = ( Invoke-ScriptBlock -Arguments $ht -Return { param ( $opts ) return \"Hello, $( $opts . Name ) ! You're $( $opts . Age ) years old.\" }) } Example 3 The following example will invoke a scriptblock, passing it arguments and splatting them to the scriptblock: Server { $ht = @{ 'Name' = 'Bob' ; 'Age' = 32 ; } Invoke-ScriptBlock -Arguments $ht -Splat { param ( $name , $age ) Write-Host \"Hello, $( $name ) ! You're $( $age ) years old.\" }) } Parameters Name Type Required Description Default ScriptBlock scriptblock true The script to be invoked null Arguments hashtable/array false Any arguments that need to be passed to the script null Scoped switch false If passed, the script will be invoked within its own scope; otherwise it will be invoked within the current scope false Return switch false If passed, will attempt to return any value from the script; otherwise nothing is returned, even if the script returns a value false Splat switch false If passed, the arguments array/hastable will be split-up and passed as mutliple arguments; otherwise it will be passed as a single argument false NoNewClosure switch false If passed, the script will not have its GetNewClosure() method called false","title":"Invoke-ScriptBlock"},{"location":"Functions/Helpers/Invoke-ScriptBlock/#invoke-scriptblock","text":"","title":"Invoke-ScriptBlock"},{"location":"Functions/Helpers/Invoke-ScriptBlock/#description","text":"The Invoke-ScriptBlock function takes a scriptblock and invokes it. You can specify arguments to pass to the script, and whether a value should be returned. By default the scriptblock will have the GetNewClosure() method called, and will be invoked in the current scope; these can be toggled via -NoNewClosure and -Scoped respectively. If any arguments are supplied, they will be supplied as a single argument to the scriptblock. By using the -Splat switch, then if the arguments are an array/hashtable they will be passed as multiple arguments instead.","title":"Description"},{"location":"Functions/Helpers/Invoke-ScriptBlock/#examples","text":"","title":"Examples"},{"location":"Functions/Helpers/Invoke-ScriptBlock/#example-1","text":"The following example will invoke a scriptblock outside of the current scope: Server { Invoke-ScriptBlock -Scoped { Write-Host 'Hello, world!' } }","title":"Example 1"},{"location":"Functions/Helpers/Invoke-ScriptBlock/#example-2","text":"The following example will invoke a scriptblock, passing it arguments and returning a value: Server { $ht = @{ 'Name' = 'Bob' ; 'Age' = 32 ; } $value = ( Invoke-ScriptBlock -Arguments $ht -Return { param ( $opts ) return \"Hello, $( $opts . Name ) ! You're $( $opts . Age ) years old.\" }) }","title":"Example 2"},{"location":"Functions/Helpers/Invoke-ScriptBlock/#example-3","text":"The following example will invoke a scriptblock, passing it arguments and splatting them to the scriptblock: Server { $ht = @{ 'Name' = 'Bob' ; 'Age' = 32 ; } Invoke-ScriptBlock -Arguments $ht -Splat { param ( $name , $age ) Write-Host \"Hello, $( $name ) ! You're $( $age ) years old.\" }) }","title":"Example 3"},{"location":"Functions/Helpers/Invoke-ScriptBlock/#parameters","text":"Name Type Required Description Default ScriptBlock scriptblock true The script to be invoked null Arguments hashtable/array false Any arguments that need to be passed to the script null Scoped switch false If passed, the script will be invoked within its own scope; otherwise it will be invoked within the current scope false Return switch false If passed, will attempt to return any value from the script; otherwise nothing is returned, even if the script returns a value false Splat switch false If passed, the arguments array/hastable will be split-up and passed as mutliple arguments; otherwise it will be passed as a single argument false NoNewClosure switch false If passed, the script will not have its GetNewClosure() method called false","title":"Parameters"},{"location":"Functions/Helpers/Test-Empty/","text":"Test-Empty Description The Test-Empty function will return whether the value supplied is either empty , $null or its length is zero. Tip The function supports virtually every type from array to string , even scriptblock . Note The function will automatically return $false if the value is a ValueType , such as float , int , bool etc. Examples Example 1 The following example will return $true and run the logic because the array is empty: Server { if ( Test-Empty @()) { # logic } } Example 2 The following example will return $false and not run the logic because the string is not empty: Server { if ( Test-Empty 'contains a value' ) { # logic } } Example 3 The following example will return $true and run the logic because the hashtable is empty: Server { if ( Test-Empty @{}) { # logic } } Parameters Name Type Required Description Default Value object false The value to check if it is empty, null or zero-length null","title":"Test-Empty"},{"location":"Functions/Helpers/Test-Empty/#test-empty","text":"","title":"Test-Empty"},{"location":"Functions/Helpers/Test-Empty/#description","text":"The Test-Empty function will return whether the value supplied is either empty , $null or its length is zero. Tip The function supports virtually every type from array to string , even scriptblock . Note The function will automatically return $false if the value is a ValueType , such as float , int , bool etc.","title":"Description"},{"location":"Functions/Helpers/Test-Empty/#examples","text":"","title":"Examples"},{"location":"Functions/Helpers/Test-Empty/#example-1","text":"The following example will return $true and run the logic because the array is empty: Server { if ( Test-Empty @()) { # logic } }","title":"Example 1"},{"location":"Functions/Helpers/Test-Empty/#example-2","text":"The following example will return $false and not run the logic because the string is not empty: Server { if ( Test-Empty 'contains a value' ) { # logic } }","title":"Example 2"},{"location":"Functions/Helpers/Test-Empty/#example-3","text":"The following example will return $true and run the logic because the hashtable is empty: Server { if ( Test-Empty @{}) { # logic } }","title":"Example 3"},{"location":"Functions/Helpers/Test-Empty/#parameters","text":"Name Type Required Description Default Value object false The value to check if it is empty, null or zero-length null","title":"Parameters"},{"location":"Functions/Helpers/Test-IsPSCore/","text":"Test-IsPSCore Description The Test-IsPSCore function will return $true if Pode is running using PowerShell Core (v6.0+), $false otherwise. Examples Example 1 The following example will return whether Pode is running on PowerShell Core: Server { listen * : 8080 http route get '/env' { json @{ 'PSCore' = ( Test-IsPSCore ) } } } Parameters None.","title":"Test-IsPSCore"},{"location":"Functions/Helpers/Test-IsPSCore/#test-ispscore","text":"","title":"Test-IsPSCore"},{"location":"Functions/Helpers/Test-IsPSCore/#description","text":"The Test-IsPSCore function will return $true if Pode is running using PowerShell Core (v6.0+), $false otherwise.","title":"Description"},{"location":"Functions/Helpers/Test-IsPSCore/#examples","text":"","title":"Examples"},{"location":"Functions/Helpers/Test-IsPSCore/#example-1","text":"The following example will return whether Pode is running on PowerShell Core: Server { listen * : 8080 http route get '/env' { json @{ 'PSCore' = ( Test-IsPSCore ) } } }","title":"Example 1"},{"location":"Functions/Helpers/Test-IsPSCore/#parameters","text":"None.","title":"Parameters"},{"location":"Functions/Helpers/Test-IsUnix/","text":"Test-IsUnix Description The Test-IsUnix function will return $true if Pode is running on a *nix environment, $false otherwise. Examples Example 1 The following example will return whether the current environment is *nix: Server { listen * : 8080 http route get '/env' { json @{ 'Unix' = ( Test-IsUnix ) } } } Parameters None.","title":"Test-IsUnix"},{"location":"Functions/Helpers/Test-IsUnix/#test-isunix","text":"","title":"Test-IsUnix"},{"location":"Functions/Helpers/Test-IsUnix/#description","text":"The Test-IsUnix function will return $true if Pode is running on a *nix environment, $false otherwise.","title":"Description"},{"location":"Functions/Helpers/Test-IsUnix/#examples","text":"","title":"Examples"},{"location":"Functions/Helpers/Test-IsUnix/#example-1","text":"The following example will return whether the current environment is *nix: Server { listen * : 8080 http route get '/env' { json @{ 'Unix' = ( Test-IsUnix ) } } }","title":"Example 1"},{"location":"Functions/Helpers/Test-IsUnix/#parameters","text":"None.","title":"Parameters"},{"location":"Functions/Helpers/Test-IsWindows/","text":"Test-IsWindows Description The Test-IsWindows function will return $true if Pode is running on a Windows environment, $false otherwise. Examples Example 1 The following example will return whether the current environment is Windows: Server { listen * : 8080 http route get '/env' { json @{ 'Windows' = ( Test-IsWindows ) } } } Parameters None.","title":"Test-IsWindows"},{"location":"Functions/Helpers/Test-IsWindows/#test-iswindows","text":"","title":"Test-IsWindows"},{"location":"Functions/Helpers/Test-IsWindows/#description","text":"The Test-IsWindows function will return $true if Pode is running on a Windows environment, $false otherwise.","title":"Description"},{"location":"Functions/Helpers/Test-IsWindows/#examples","text":"","title":"Examples"},{"location":"Functions/Helpers/Test-IsWindows/#example-1","text":"The following example will return whether the current environment is Windows: Server { listen * : 8080 http route get '/env' { json @{ 'Windows' = ( Test-IsWindows ) } } }","title":"Example 1"},{"location":"Functions/Helpers/Test-IsWindows/#parameters","text":"None.","title":"Parameters"},{"location":"Functions/Middleware/Access/","text":"Access Description The access function allows you to specify rules to allow/deny IP addresses or subnets access to your routes. If an IP address hits your server that you've denied access, then a 403 response is returned and the connection immediately closed. For SMTP/TCP servers the connection is just closed with no response. Examples Example 1 The following example will allow access from the localhost: Server { access allow ip '127.0.0.1' } Tip It's best to use @('127.0.0.1', '[::1]') for localhost instead of just 127.0.0.1 , as this will allow the IPv6 localhost address as well. Example 2 The following example will allow access from multiple IP addresses: Server { access allow ip @( '192.168.1.1' , '192.168.1.2' ) } Example 3 The following example will deny access from a subnet mask: Server { access deny ip '10.10.0.0/24' } Example 4 The following example will deny access from all IP addresses: Server { access deny ip all } Parameters Name Type Required Description Default Permission string true The type of access for the IP address/subnet (Values: Allow, Deny) empty Type string true The type of what you wish to restrict access (Values: IP) empty Value object true The IP address or subnet mask to apply the access rule null Info There are plans to expand access to restrict content types as well.","title":"Access"},{"location":"Functions/Middleware/Access/#access","text":"","title":"Access"},{"location":"Functions/Middleware/Access/#description","text":"The access function allows you to specify rules to allow/deny IP addresses or subnets access to your routes. If an IP address hits your server that you've denied access, then a 403 response is returned and the connection immediately closed. For SMTP/TCP servers the connection is just closed with no response.","title":"Description"},{"location":"Functions/Middleware/Access/#examples","text":"","title":"Examples"},{"location":"Functions/Middleware/Access/#example-1","text":"The following example will allow access from the localhost: Server { access allow ip '127.0.0.1' } Tip It's best to use @('127.0.0.1', '[::1]') for localhost instead of just 127.0.0.1 , as this will allow the IPv6 localhost address as well.","title":"Example 1"},{"location":"Functions/Middleware/Access/#example-2","text":"The following example will allow access from multiple IP addresses: Server { access allow ip @( '192.168.1.1' , '192.168.1.2' ) }","title":"Example 2"},{"location":"Functions/Middleware/Access/#example-3","text":"The following example will deny access from a subnet mask: Server { access deny ip '10.10.0.0/24' }","title":"Example 3"},{"location":"Functions/Middleware/Access/#example-4","text":"The following example will deny access from all IP addresses: Server { access deny ip all }","title":"Example 4"},{"location":"Functions/Middleware/Access/#parameters","text":"Name Type Required Description Default Permission string true The type of access for the IP address/subnet (Values: Allow, Deny) empty Type string true The type of what you wish to restrict access (Values: IP) empty Value object true The IP address or subnet mask to apply the access rule null Info There are plans to expand access to restrict content types as well.","title":"Parameters"},{"location":"Functions/Middleware/Auth/","text":"Auth Description The auth function allows you to use and check against defined authentication methods on web requests; this could be Basic/Form authentication, or custom defined authentication. Authentication can either be sessionless (requiring validation on every request), or session-persistent (only requiring validation once, and then checks against a session signed-cookie). Actions Use # inbuilt auth use < name > -validator {} [ -type < string >] [ -options @{}] # custom auth use -custom < name > -parser {} -validator {} [ -type < string >] [ -options @{}] The auth use action allows you to specify and configure which authentication methods your server will use; you can have many of them, defining which one to validate against on the auth check action. The name of the method can be anything, so long as you specify the type as well. The type should be a valid inbuilt method, unless you have stated that the method is custom. If custom, you must supply a parser script which will parse payloads/headers for credentials and then return this data as an array - which will then be supplied to the validator script. Info If you don't supply a type then the name will be used instead. Check auth check < name > [ -options @{}] The auth check action allows you to define which authentication method to validate a request against. The action returns a valid middleware script, meaning you can either use this action on specific route definitions, or globally for all routes as middleware . If this action fails, then a 401 response is returned. On success, this action will then allow the route logic to be invoked. If session middleware has been configured then an authenticated session is also created for future requests. When the user makes another call using the same authenticated session, then the auth check action will detect the already authenticated session and skip the validator script. If you're using sessions and you don't want the auth check to check the session, or store the user against the session, then pass -o @{ 'Session' = $false } to the auth check . The following table contains options that you can supply to an auth check -o @{} call - these are all optional: Name Description Default FailureUrl The URL to redirect to should authentication fail empty SuccessUrl The URL to redirect to should authenticationh succeed empty Session If true, check if the session already has an authenticated user; storing the user in the session if they are authenticated true Login If true, check the authentication status in the session and redirect to the SuccessUrl if the user is authenticated. Otherwise proceed to the page with no authentication required false Logout If true, purge the session and redirect to the FailureUrl false Info The Login option allows you to have authentication on your login pages, such that if there is no user in a current session then the login page displays - rather then being 401'd. Whereas if there is an authenticated user in the session it will auto-redirect to the SuccessUrl . Examples Example 1 The following example will setup sessionless Basic authentication, and then use it as route middleware. This will require authentication on every request. The basic authentication will check for an { \"Authorization\": \"Basic <user:pass>\" } header on the request: Server { listen * : 8080 http # setup basic auth, with validator to check the user auth use basic -v { param ( $username , $pass ) # check if the user is valid return @{ 'user' = $user } } # check the request against the above auth route get '/info' ( auth check basic ) { json @{ 'cpu' = 82 } } } Example 2 The following example will setup sessionless Form authentication, and set it as global middleware for every route . This will require authentication on every request. The form authentication will check the POST payload for a username and password , supplied from a <form> : Server { listen * : 8080 http # setup form auth, with validator to check the user auth use form -v { param ( $username , $pass ) # check if the user is valid return @{ 'user' = $user } } # apply the auth check as global middleware middleware ( auth check form ) # the route will use the above auth middleware route get '/info' { json @{ 'cpu' = 82 } } } Example 3 The following example will setup session-persistent Basic authentication, and then use it as route middleware. This will only require authentication once, and the the check will succeed if the authenticated session cookie is passed: Server { listen * : 8080 http # configure session middleware to bind the auth'd user against middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; }) # setup basic auth, with validator to check the user auth use basic -v { param ( $username , $pass ) # check if the user is valid return @{ 'user' = $user } } # check the request against the above auth route get '/info' ( auth check basic ) { json @{ 'cpu' = 82 } } } Parameters Name Type Required Description Default Action string true The action to perform on the auth function (Values: Use, Check) empty Name string true The name of the authentication middleware that will be used to reference and validate against in the check call empty Type string false The type of the authentication middleware; if -Custom is not specified, then this will be the name of an inbuilt authentication method empty Validator scriptblock false A script that will be passed user credentials, here you can validate the user is valid and exists in some data store null Parser scriptblock false If -Custom is supplied then this parameter is required. This is the custom script where you can parse payloads/querystring or headers to source user credentials, that will then be supplied to your validator null Options hashtable false A hashtable of options to customise the authentication method. Depending on the method is this be options like FieldName or Encoding null Custom switch false If passed, states that this authentication method is a custom defined method false","title":"Auth"},{"location":"Functions/Middleware/Auth/#auth","text":"","title":"Auth"},{"location":"Functions/Middleware/Auth/#description","text":"The auth function allows you to use and check against defined authentication methods on web requests; this could be Basic/Form authentication, or custom defined authentication. Authentication can either be sessionless (requiring validation on every request), or session-persistent (only requiring validation once, and then checks against a session signed-cookie).","title":"Description"},{"location":"Functions/Middleware/Auth/#actions","text":"","title":"Actions"},{"location":"Functions/Middleware/Auth/#use","text":"# inbuilt auth use < name > -validator {} [ -type < string >] [ -options @{}] # custom auth use -custom < name > -parser {} -validator {} [ -type < string >] [ -options @{}] The auth use action allows you to specify and configure which authentication methods your server will use; you can have many of them, defining which one to validate against on the auth check action. The name of the method can be anything, so long as you specify the type as well. The type should be a valid inbuilt method, unless you have stated that the method is custom. If custom, you must supply a parser script which will parse payloads/headers for credentials and then return this data as an array - which will then be supplied to the validator script. Info If you don't supply a type then the name will be used instead.","title":"Use"},{"location":"Functions/Middleware/Auth/#check","text":"auth check < name > [ -options @{}] The auth check action allows you to define which authentication method to validate a request against. The action returns a valid middleware script, meaning you can either use this action on specific route definitions, or globally for all routes as middleware . If this action fails, then a 401 response is returned. On success, this action will then allow the route logic to be invoked. If session middleware has been configured then an authenticated session is also created for future requests. When the user makes another call using the same authenticated session, then the auth check action will detect the already authenticated session and skip the validator script. If you're using sessions and you don't want the auth check to check the session, or store the user against the session, then pass -o @{ 'Session' = $false } to the auth check . The following table contains options that you can supply to an auth check -o @{} call - these are all optional: Name Description Default FailureUrl The URL to redirect to should authentication fail empty SuccessUrl The URL to redirect to should authenticationh succeed empty Session If true, check if the session already has an authenticated user; storing the user in the session if they are authenticated true Login If true, check the authentication status in the session and redirect to the SuccessUrl if the user is authenticated. Otherwise proceed to the page with no authentication required false Logout If true, purge the session and redirect to the FailureUrl false Info The Login option allows you to have authentication on your login pages, such that if there is no user in a current session then the login page displays - rather then being 401'd. Whereas if there is an authenticated user in the session it will auto-redirect to the SuccessUrl .","title":"Check"},{"location":"Functions/Middleware/Auth/#examples","text":"","title":"Examples"},{"location":"Functions/Middleware/Auth/#example-1","text":"The following example will setup sessionless Basic authentication, and then use it as route middleware. This will require authentication on every request. The basic authentication will check for an { \"Authorization\": \"Basic <user:pass>\" } header on the request: Server { listen * : 8080 http # setup basic auth, with validator to check the user auth use basic -v { param ( $username , $pass ) # check if the user is valid return @{ 'user' = $user } } # check the request against the above auth route get '/info' ( auth check basic ) { json @{ 'cpu' = 82 } } }","title":"Example 1"},{"location":"Functions/Middleware/Auth/#example-2","text":"The following example will setup sessionless Form authentication, and set it as global middleware for every route . This will require authentication on every request. The form authentication will check the POST payload for a username and password , supplied from a <form> : Server { listen * : 8080 http # setup form auth, with validator to check the user auth use form -v { param ( $username , $pass ) # check if the user is valid return @{ 'user' = $user } } # apply the auth check as global middleware middleware ( auth check form ) # the route will use the above auth middleware route get '/info' { json @{ 'cpu' = 82 } } }","title":"Example 2"},{"location":"Functions/Middleware/Auth/#example-3","text":"The following example will setup session-persistent Basic authentication, and then use it as route middleware. This will only require authentication once, and the the check will succeed if the authenticated session cookie is passed: Server { listen * : 8080 http # configure session middleware to bind the auth'd user against middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; }) # setup basic auth, with validator to check the user auth use basic -v { param ( $username , $pass ) # check if the user is valid return @{ 'user' = $user } } # check the request against the above auth route get '/info' ( auth check basic ) { json @{ 'cpu' = 82 } } }","title":"Example 3"},{"location":"Functions/Middleware/Auth/#parameters","text":"Name Type Required Description Default Action string true The action to perform on the auth function (Values: Use, Check) empty Name string true The name of the authentication middleware that will be used to reference and validate against in the check call empty Type string false The type of the authentication middleware; if -Custom is not specified, then this will be the name of an inbuilt authentication method empty Validator scriptblock false A script that will be passed user credentials, here you can validate the user is valid and exists in some data store null Parser scriptblock false If -Custom is supplied then this parameter is required. This is the custom script where you can parse payloads/querystring or headers to source user credentials, that will then be supplied to your validator null Options hashtable false A hashtable of options to customise the authentication method. Depending on the method is this be options like FieldName or Encoding null Custom switch false If passed, states that this authentication method is a custom defined method false","title":"Parameters"},{"location":"Functions/Middleware/Limit/","text":"Limit Description The limit function allows you to specify rate limiting rules on IP addresses or subnets to limit access to your routes. If an IP address hits your server and has exceeded the rate limit counter within the defined period, then a 429 response is returned and the connection immediately closed. For SMTP/TCP servers the connection is just closed with no response. Examples Example 1 The following example will limit the localhost to 5 requests per second: Server { limit ip 127 . 0 . 0 . 1 -limit 5 -seconds 1 } Tip It's best to use @('127.0.0.1', '[::1]') for localhost instead of just 127.0.0.1 , as this will limit the IPv6 localhost address as well. Example 2 The following example will limit multiple IP addresses to 5 requests per 10 seconds: Server { limit ip @( '192.168.1.1' , '192.168.1.2' ) -l 5 -s 10 } Example 3 The following example will limit a subnet mask to 5 requests per second, per each individual IP address governed by that subnet mask: Server { limit ip '10.10.0.0/24' -l 5 -s 1 } Info So here, the IP addresses 10.10.0.1 and 10.10.0.2 are under the subnet mask 10.10.0.0/24 ; each IP address will each get 5 requests per second before hitting the limit. Therefore if the first IP made 3req/s and the second made 3req/s, then the each call will be allowed through. Example 4 The following example will limit a subnet mask to 5 requests per second, where all IP addresses governed by the subnet are treated as one: Server { limit ip -group '10.10.0.0/24' -l 5 -s 1 } Info So here, the IP addresses 10.10.0.1 and 10.10.0.2 are under the subnet mask 10.10.0.0/24 ; each IP address will get a single grouped 5 requests per second before hitting the limit. Therefore if the first IP made 3req/s and the second made 3req/s, then the final call from the second will get a 429 response. Example 5 The following example will limit requests from all IP addresses to 10 requests per minute: Server { limit ip all -l 10 -s 60 } Parameters Name Type Required Description Default Type string true The type of what you wish to limit access (Values: IP) empty Value object true The IP address or subnet mask to apply rate limiting null Limit int true The amount of requests to allow within the given number of seconds, before a 429 status is returned 0 Seconds int true The number of seconds to wait before resetting the rate limit counter 0 Group switch false Only applies to subnet masks; if passed, all IP addresses governed by the mask will restricted by the same rate limit counter, rather than individually false Info There are plans to expand limit to limit content types as well.","title":"Limit"},{"location":"Functions/Middleware/Limit/#limit","text":"","title":"Limit"},{"location":"Functions/Middleware/Limit/#description","text":"The limit function allows you to specify rate limiting rules on IP addresses or subnets to limit access to your routes. If an IP address hits your server and has exceeded the rate limit counter within the defined period, then a 429 response is returned and the connection immediately closed. For SMTP/TCP servers the connection is just closed with no response.","title":"Description"},{"location":"Functions/Middleware/Limit/#examples","text":"","title":"Examples"},{"location":"Functions/Middleware/Limit/#example-1","text":"The following example will limit the localhost to 5 requests per second: Server { limit ip 127 . 0 . 0 . 1 -limit 5 -seconds 1 } Tip It's best to use @('127.0.0.1', '[::1]') for localhost instead of just 127.0.0.1 , as this will limit the IPv6 localhost address as well.","title":"Example 1"},{"location":"Functions/Middleware/Limit/#example-2","text":"The following example will limit multiple IP addresses to 5 requests per 10 seconds: Server { limit ip @( '192.168.1.1' , '192.168.1.2' ) -l 5 -s 10 }","title":"Example 2"},{"location":"Functions/Middleware/Limit/#example-3","text":"The following example will limit a subnet mask to 5 requests per second, per each individual IP address governed by that subnet mask: Server { limit ip '10.10.0.0/24' -l 5 -s 1 } Info So here, the IP addresses 10.10.0.1 and 10.10.0.2 are under the subnet mask 10.10.0.0/24 ; each IP address will each get 5 requests per second before hitting the limit. Therefore if the first IP made 3req/s and the second made 3req/s, then the each call will be allowed through.","title":"Example 3"},{"location":"Functions/Middleware/Limit/#example-4","text":"The following example will limit a subnet mask to 5 requests per second, where all IP addresses governed by the subnet are treated as one: Server { limit ip -group '10.10.0.0/24' -l 5 -s 1 } Info So here, the IP addresses 10.10.0.1 and 10.10.0.2 are under the subnet mask 10.10.0.0/24 ; each IP address will get a single grouped 5 requests per second before hitting the limit. Therefore if the first IP made 3req/s and the second made 3req/s, then the final call from the second will get a 429 response.","title":"Example 4"},{"location":"Functions/Middleware/Limit/#example-5","text":"The following example will limit requests from all IP addresses to 10 requests per minute: Server { limit ip all -l 10 -s 60 }","title":"Example 5"},{"location":"Functions/Middleware/Limit/#parameters","text":"Name Type Required Description Default Type string true The type of what you wish to limit access (Values: IP) empty Value object true The IP address or subnet mask to apply rate limiting null Limit int true The amount of requests to allow within the given number of seconds, before a 429 status is returned 0 Seconds int true The number of seconds to wait before resetting the rate limit counter 0 Group switch false Only applies to subnet masks; if passed, all IP addresses governed by the mask will restricted by the same rate limit counter, rather than individually false Info There are plans to expand limit to limit content types as well.","title":"Parameters"},{"location":"Functions/Middleware/Session/","text":"Session Description The session function creates and returns a middleware that enables session cookies. Session middleware attaches onto web requests/responses, and uses signed-cookies and server-side data storage. When configured, the middleware will check for a session-cookie on the request; if a cookie is not found on the request, or the session is not in the store, then a new session is created and attached to the response. If there is a session, then the appropriate data is loaded from the store. The age of the session-cookie can be specified (and whether to extend the duration each time), as well as a secret-key to sign cookies, and the ability to specify custom data stores - the default is in-memory, so custom stores could be anything like redis/mongo. Examples Example 1 The following example sets up basic session middleware, using a secret key and a 5min fixed duration: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; }) } Example 2 The following example sets up session middleware with a non-default cookie name, and a sliding 5min duration: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; 'Extend' = $true ; 'Name' = 'session.id' ; }) } Example 3 The following example sets up session middleware with a custom SessionId script generator; to use a random filename instead of a guid: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; 'GenerateId' = { return [System.IO.Path] :: GetRandomFileName () } }) } Example 4 The following example sets up basic session middleware, and defines a route that adds data to the session. Each subsequent call to the route will increment the views counter: Server { listen * : 8080 http middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; }) route get '/' { $param ( $s ) $s . Session . Data . Views ++ json @{ 'Views' = $s . Session . Data . Views } } } Parameters Note The session function takes a single hashtable as its parameter. The below parameters are the expected keys that should be present within the supplied parameter Name Type Required Description Default Secret string true The secret key used to sign the cookies empty Name string false The name of the session cookie pode.sid Duration int false The duration of which the cookie lasts, in seconds (>=0) 0 Extend bool false If true, the duration of the cookie will be extended each time a request is made using the session false Discard bool false If true, informs the enduser's browser to discard the cookie on expiry false Secure bool false If true, informs the enduser's browser to only send the cookie on secure connections false GenerateId scriptblock false A script that should return a valid string. The string itself should be a random unique value, that can be used as a session identifier guid Store psobject false An object that defines specific functions to communicate with a custom data store null Notes Stores A store should be a psobject that requires the following functions: [hashtable] Get ( [string] $sessionId ) [void] Set ( [string] $sessionId , [hashtable] $data , [datetime] $expiry ) [void] Delete ( [string] $sessionId )","title":"Session"},{"location":"Functions/Middleware/Session/#session","text":"","title":"Session"},{"location":"Functions/Middleware/Session/#description","text":"The session function creates and returns a middleware that enables session cookies. Session middleware attaches onto web requests/responses, and uses signed-cookies and server-side data storage. When configured, the middleware will check for a session-cookie on the request; if a cookie is not found on the request, or the session is not in the store, then a new session is created and attached to the response. If there is a session, then the appropriate data is loaded from the store. The age of the session-cookie can be specified (and whether to extend the duration each time), as well as a secret-key to sign cookies, and the ability to specify custom data stores - the default is in-memory, so custom stores could be anything like redis/mongo.","title":"Description"},{"location":"Functions/Middleware/Session/#examples","text":"","title":"Examples"},{"location":"Functions/Middleware/Session/#example-1","text":"The following example sets up basic session middleware, using a secret key and a 5min fixed duration: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; }) }","title":"Example 1"},{"location":"Functions/Middleware/Session/#example-2","text":"The following example sets up session middleware with a non-default cookie name, and a sliding 5min duration: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; 'Extend' = $true ; 'Name' = 'session.id' ; }) }","title":"Example 2"},{"location":"Functions/Middleware/Session/#example-3","text":"The following example sets up session middleware with a custom SessionId script generator; to use a random filename instead of a guid: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; 'GenerateId' = { return [System.IO.Path] :: GetRandomFileName () } }) }","title":"Example 3"},{"location":"Functions/Middleware/Session/#example-4","text":"The following example sets up basic session middleware, and defines a route that adds data to the session. Each subsequent call to the route will increment the views counter: Server { listen * : 8080 http middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; }) route get '/' { $param ( $s ) $s . Session . Data . Views ++ json @{ 'Views' = $s . Session . Data . Views } } }","title":"Example 4"},{"location":"Functions/Middleware/Session/#parameters","text":"Note The session function takes a single hashtable as its parameter. The below parameters are the expected keys that should be present within the supplied parameter Name Type Required Description Default Secret string true The secret key used to sign the cookies empty Name string false The name of the session cookie pode.sid Duration int false The duration of which the cookie lasts, in seconds (>=0) 0 Extend bool false If true, the duration of the cookie will be extended each time a request is made using the session false Discard bool false If true, informs the enduser's browser to discard the cookie on expiry false Secure bool false If true, informs the enduser's browser to only send the cookie on secure connections false GenerateId scriptblock false A script that should return a valid string. The string itself should be a random unique value, that can be used as a session identifier guid Store psobject false An object that defines specific functions to communicate with a custom data store null","title":"Parameters"},{"location":"Functions/Middleware/Session/#notes","text":"","title":"Notes"},{"location":"Functions/Middleware/Session/#stores","text":"A store should be a psobject that requires the following functions: [hashtable] Get ( [string] $sessionId ) [void] Set ( [string] $sessionId , [hashtable] $data , [datetime] $expiry ) [void] Delete ( [string] $sessionId )","title":"Stores"},{"location":"Functions/Response/Attach/","text":"Attach Description The attach function allows you to attach files in the /public directory, as well as custom static route directories, onto the web response. This allows the files to be downloaded by the end-user. Examples Example 1 The following example attaches the installer found at /public/downloads/installer.exe onto the response, when the http://localhost:8080/app/install endpoint is hit: Server { listen * : 8080 http route get '/app/install' { attach 'downloads/installer.exe' } } Example 2 The following example attaches the image found at /content/assets/images/icon.png onto the response, when the http://localhost:8080/app/icon endpoint is hit: Server { listen * : 8080 http route static '/assets' './content/assets' route get '/app/icon' { attach '/assets/images/icon.png' } } Parameters Name Type Required Description Default Path string true The path to the file to attach, relative to your /public directory null","title":"Attach"},{"location":"Functions/Response/Attach/#attach","text":"","title":"Attach"},{"location":"Functions/Response/Attach/#description","text":"The attach function allows you to attach files in the /public directory, as well as custom static route directories, onto the web response. This allows the files to be downloaded by the end-user.","title":"Description"},{"location":"Functions/Response/Attach/#examples","text":"","title":"Examples"},{"location":"Functions/Response/Attach/#example-1","text":"The following example attaches the installer found at /public/downloads/installer.exe onto the response, when the http://localhost:8080/app/install endpoint is hit: Server { listen * : 8080 http route get '/app/install' { attach 'downloads/installer.exe' } }","title":"Example 1"},{"location":"Functions/Response/Attach/#example-2","text":"The following example attaches the image found at /content/assets/images/icon.png onto the response, when the http://localhost:8080/app/icon endpoint is hit: Server { listen * : 8080 http route static '/assets' './content/assets' route get '/app/icon' { attach '/assets/images/icon.png' } }","title":"Example 2"},{"location":"Functions/Response/Attach/#parameters","text":"Name Type Required Description Default Path string true The path to the file to attach, relative to your /public directory null","title":"Parameters"},{"location":"Functions/Response/Csv/","text":"Csv Description The csv function converts an array of hashtable values, or reads in a file, and converts it to a CSV; the value is then written to the web response. You can also supply raw CSV data as the value to write. Examples Example 1 The following example will convert an array of hashtable values to a CSV and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { csv @( @{ 'Name' = 'Bob' ; 'Age' = 29 }, @{ 'Name' = 'James' ; 'Age' = 23 }) } } Example 2 The following example will write raw CSV data to a web response within a route : Server { listen * : 8080 http route get '/info' { csv \"Name, Age `n Bob, 29 `n James, 23\" } } Example 3 The following example will read in a file, and write the contents as CSV to a web response within a route : Server { listen * : 8080 http route get '/data' { csv -file './files/data.csv' } } Parameters Name Type Required Description Default Value hashtable[]/string true The value should either be an array of hashtable values or string - the string can be either a path or raw CSV. It will be converted to CSV, if not raw, and attached to the web response null File switch false If passed, the value should be a string that's a path to a CSV file false","title":"Csv"},{"location":"Functions/Response/Csv/#csv","text":"","title":"Csv"},{"location":"Functions/Response/Csv/#description","text":"The csv function converts an array of hashtable values, or reads in a file, and converts it to a CSV; the value is then written to the web response. You can also supply raw CSV data as the value to write.","title":"Description"},{"location":"Functions/Response/Csv/#examples","text":"","title":"Examples"},{"location":"Functions/Response/Csv/#example-1","text":"The following example will convert an array of hashtable values to a CSV and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { csv @( @{ 'Name' = 'Bob' ; 'Age' = 29 }, @{ 'Name' = 'James' ; 'Age' = 23 }) } }","title":"Example 1"},{"location":"Functions/Response/Csv/#example-2","text":"The following example will write raw CSV data to a web response within a route : Server { listen * : 8080 http route get '/info' { csv \"Name, Age `n Bob, 29 `n James, 23\" } }","title":"Example 2"},{"location":"Functions/Response/Csv/#example-3","text":"The following example will read in a file, and write the contents as CSV to a web response within a route : Server { listen * : 8080 http route get '/data' { csv -file './files/data.csv' } }","title":"Example 3"},{"location":"Functions/Response/Csv/#parameters","text":"Name Type Required Description Default Value hashtable[]/string true The value should either be an array of hashtable values or string - the string can be either a path or raw CSV. It will be converted to CSV, if not raw, and attached to the web response null File switch false If passed, the value should be a string that's a path to a CSV file false","title":"Parameters"},{"location":"Functions/Response/Html/","text":"Html Description The html function reads in an HTML file and then writes to content the web response. You can also supply raw HTML data as the value to write. Examples Example 1 The following example will write raw HTML data to a web response within a route : Server { listen * : 8080 http route get '/info' { html '<html><head><title>Example</title></head><body>Hello, world!</body></html>' } } Example 2 The following example will read in a file, and write the contents as HTML to a web response within a route : Server { listen * : 8080 http route get '/data' { html -file './files/data.html' } } Parameters Name Type Required Description Default Value string true The value should be a string, of either a path or raw HTML. It will be attached to the web response null File switch false If passed, the above value should be a string that's a path to an HTML file false","title":"Html"},{"location":"Functions/Response/Html/#html","text":"","title":"Html"},{"location":"Functions/Response/Html/#description","text":"The html function reads in an HTML file and then writes to content the web response. You can also supply raw HTML data as the value to write.","title":"Description"},{"location":"Functions/Response/Html/#examples","text":"","title":"Examples"},{"location":"Functions/Response/Html/#example-1","text":"The following example will write raw HTML data to a web response within a route : Server { listen * : 8080 http route get '/info' { html '<html><head><title>Example</title></head><body>Hello, world!</body></html>' } }","title":"Example 1"},{"location":"Functions/Response/Html/#example-2","text":"The following example will read in a file, and write the contents as HTML to a web response within a route : Server { listen * : 8080 http route get '/data' { html -file './files/data.html' } }","title":"Example 2"},{"location":"Functions/Response/Html/#parameters","text":"Name Type Required Description Default Value string true The value should be a string, of either a path or raw HTML. It will be attached to the web response null File switch false If passed, the above value should be a string that's a path to an HTML file false","title":"Parameters"},{"location":"Functions/Response/Json/","text":"Json Description The json function converts a hashtable , or reads in a file, and converts it to JSON; the JSON value is then written to the web response. You can also supply raw JSON data as the value to write. Examples Example 1 The following example will convert a hashtable to JSON and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { json @{ 'cpu' = 80 ; 'memory' = 15 ; } } } Example 2 The following example will write raw JSON data to a web response within a route : Server { listen * : 8080 http route get '/info' { json '{ \"cpu\": 80, \"memory\": 15 }' } } Example 3 The following example will read in a file, and write the contents as JSON to a web response within a route : Server { listen * : 8080 http route get '/data' { json -file './files/data.json' } } Parameters Name Type Required Description Default Value hashtable/string false The value should either be a hashtable or string - the string can be either a path or raw JSON. It will be converted to JSON, if not raw, and attached to the web response null File switch false If passed, the value should be a string that's a path to a JSON file false","title":"Json"},{"location":"Functions/Response/Json/#json","text":"","title":"Json"},{"location":"Functions/Response/Json/#description","text":"The json function converts a hashtable , or reads in a file, and converts it to JSON; the JSON value is then written to the web response. You can also supply raw JSON data as the value to write.","title":"Description"},{"location":"Functions/Response/Json/#examples","text":"","title":"Examples"},{"location":"Functions/Response/Json/#example-1","text":"The following example will convert a hashtable to JSON and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { json @{ 'cpu' = 80 ; 'memory' = 15 ; } } }","title":"Example 1"},{"location":"Functions/Response/Json/#example-2","text":"The following example will write raw JSON data to a web response within a route : Server { listen * : 8080 http route get '/info' { json '{ \"cpu\": 80, \"memory\": 15 }' } }","title":"Example 2"},{"location":"Functions/Response/Json/#example-3","text":"The following example will read in a file, and write the contents as JSON to a web response within a route : Server { listen * : 8080 http route get '/data' { json -file './files/data.json' } }","title":"Example 3"},{"location":"Functions/Response/Json/#parameters","text":"Name Type Required Description Default Value hashtable/string false The value should either be a hashtable or string - the string can be either a path or raw JSON. It will be converted to JSON, if not raw, and attached to the web response null File switch false If passed, the value should be a string that's a path to a JSON file false","title":"Parameters"},{"location":"Functions/Response/Redirect/","text":"Redirect Description The redirect function allows you to specify a URL to which the enduser should be redirected. You can either specify a raw or relative URL, or alter the current request URI's endpoint/port/protocol - such as redirecting from HTTP to HTTPS. Examples Example 1 The following example will redirect the enduser to the relative /login URL on the same endpoint: Server { listen * : 8080 http route get '/logout' { redirect -url '/login' } } Example 2 The following example will redirect the enduser to https://google.com : Server { listen * : 8080 http route get '/google' { redirect -url 'https://google.com' } } Example 3 Assuming the current request URI is http://localhost:8080 , then the following example will redirect the enduser to http://localhost:8090 : Server { listen * : 8080 http route get '/' { redirect -port 8090 } } Example 4 Assuming the current request URI is http://localhost:8080 , then the following example will redirect the enduser to https://localhost:8080 : Server { listen * : 8080 http route get '/' { redirect -protocol https } } Example 5 The following example will redirect every method and route to https: Server { listen * : 8080 http route * * { redirect -protocol https } } Example 6 The following example will redirect every method and route from the 127.0.0.2 endpoint to the localhost one - the port and protocol will remain untouched: Server { listen 127 . 0 . 0 . 1 : 8080 http listen 127 . 0 . 0 . 2 : 8080 http route * * -endpoint 127 . 0 . 0 . 2 { redirect -endpoint 127 . 0 . 0 . 1 } } Parameters Name Type Required Description Default Url string false The raw, or relative, URL to which the enduser should be redirected empty Port int false If no URL is supplied, then the redirect will be based on the current request URI's port. This parameter will override the current port of the request URI 0 Protocol string false If no URL is supplied, then the redirect will be based on the current request URI's protocol. This parameter will override the current protocol of the request URI (Values: Empty, HTTP, HTTPS) empty Endpoint string false If no URL is supplied, then the redirect will be based on the current request URI's endpoint. This parameter will override the current endpoint of the request URI empty Moved switch false If flagged, the redirect will be done as a 301 Moved status, rather than a 302 Redirect false","title":"Redirect"},{"location":"Functions/Response/Redirect/#redirect","text":"","title":"Redirect"},{"location":"Functions/Response/Redirect/#description","text":"The redirect function allows you to specify a URL to which the enduser should be redirected. You can either specify a raw or relative URL, or alter the current request URI's endpoint/port/protocol - such as redirecting from HTTP to HTTPS.","title":"Description"},{"location":"Functions/Response/Redirect/#examples","text":"","title":"Examples"},{"location":"Functions/Response/Redirect/#example-1","text":"The following example will redirect the enduser to the relative /login URL on the same endpoint: Server { listen * : 8080 http route get '/logout' { redirect -url '/login' } }","title":"Example 1"},{"location":"Functions/Response/Redirect/#example-2","text":"The following example will redirect the enduser to https://google.com : Server { listen * : 8080 http route get '/google' { redirect -url 'https://google.com' } }","title":"Example 2"},{"location":"Functions/Response/Redirect/#example-3","text":"Assuming the current request URI is http://localhost:8080 , then the following example will redirect the enduser to http://localhost:8090 : Server { listen * : 8080 http route get '/' { redirect -port 8090 } }","title":"Example 3"},{"location":"Functions/Response/Redirect/#example-4","text":"Assuming the current request URI is http://localhost:8080 , then the following example will redirect the enduser to https://localhost:8080 : Server { listen * : 8080 http route get '/' { redirect -protocol https } }","title":"Example 4"},{"location":"Functions/Response/Redirect/#example-5","text":"The following example will redirect every method and route to https: Server { listen * : 8080 http route * * { redirect -protocol https } }","title":"Example 5"},{"location":"Functions/Response/Redirect/#example-6","text":"The following example will redirect every method and route from the 127.0.0.2 endpoint to the localhost one - the port and protocol will remain untouched: Server { listen 127 . 0 . 0 . 1 : 8080 http listen 127 . 0 . 0 . 2 : 8080 http route * * -endpoint 127 . 0 . 0 . 2 { redirect -endpoint 127 . 0 . 0 . 1 } }","title":"Example 6"},{"location":"Functions/Response/Redirect/#parameters","text":"Name Type Required Description Default Url string false The raw, or relative, URL to which the enduser should be redirected empty Port int false If no URL is supplied, then the redirect will be based on the current request URI's port. This parameter will override the current port of the request URI 0 Protocol string false If no URL is supplied, then the redirect will be based on the current request URI's protocol. This parameter will override the current protocol of the request URI (Values: Empty, HTTP, HTTPS) empty Endpoint string false If no URL is supplied, then the redirect will be based on the current request URI's endpoint. This parameter will override the current endpoint of the request URI empty Moved switch false If flagged, the redirect will be done as a 301 Moved status, rather than a 302 Redirect false","title":"Parameters"},{"location":"Functions/Response/Status/","text":"Status Description The status function allows you to specify a status code, an optional description, and an optional exception that can be displayed on the error page. If the status code supplied is 400+ then Pode will render an error page, which you can override using custom error pages . If you supplied an exception to status , then the details of the exception can be used to populate the error pages with debugging info if enabled. Examples Example 1 The following example sets the status code of the response to be 404: Server { listen * : 8080 http route get '/missing' { status 404 } } Example 2 The following example sets the status code and description of the response to be 500: Server { listen * : 8080 http route get '/error' { status 500 'Oh no! Something went wrong!' } } Example 3 The following example will catch an exception, and set the status code to 500; the exception will also be supplied so it can be rendered on any error pages : Server { listen * : 8080 http route get '/error' { try { # logic that fails } catch { status 500 -e $_ } } } Parameters Name Type Required Description Default Code int true The status code to set on the web response 0 Description string false The status description to set on the response empty Exception exception false An exception that can be used to populate further details on the error page null","title":"Status"},{"location":"Functions/Response/Status/#status","text":"","title":"Status"},{"location":"Functions/Response/Status/#description","text":"The status function allows you to specify a status code, an optional description, and an optional exception that can be displayed on the error page. If the status code supplied is 400+ then Pode will render an error page, which you can override using custom error pages . If you supplied an exception to status , then the details of the exception can be used to populate the error pages with debugging info if enabled.","title":"Description"},{"location":"Functions/Response/Status/#examples","text":"","title":"Examples"},{"location":"Functions/Response/Status/#example-1","text":"The following example sets the status code of the response to be 404: Server { listen * : 8080 http route get '/missing' { status 404 } }","title":"Example 1"},{"location":"Functions/Response/Status/#example-2","text":"The following example sets the status code and description of the response to be 500: Server { listen * : 8080 http route get '/error' { status 500 'Oh no! Something went wrong!' } }","title":"Example 2"},{"location":"Functions/Response/Status/#example-3","text":"The following example will catch an exception, and set the status code to 500; the exception will also be supplied so it can be rendered on any error pages : Server { listen * : 8080 http route get '/error' { try { # logic that fails } catch { status 500 -e $_ } } }","title":"Example 3"},{"location":"Functions/Response/Status/#parameters","text":"Name Type Required Description Default Code int true The status code to set on the web response 0 Description string false The status description to set on the response empty Exception exception false An exception that can be used to populate further details on the error page null","title":"Parameters"},{"location":"Functions/Response/View/","text":"View Description The view function allows you to render view files that are placed within the /views directory at the root of your server. When you call view , Pode will automatically look within this directory for files. Pode uses a View Engine to render either HTML, Pode, or other file types. Default is HTML, and you can change it to Pode, or other third-party engines, by using the engine function. Examples Example 1 The following example will render the index.html view when you navigate to http://localhost:8080 : Server { listen * : 8080 http route get '/' { view 'index' } } Example 2 The following example will render the index.pode view when you navigate to http://localhost:8080 : Server { listen * : 8080 http engine pode route get '/' { view 'index' } } Example 3 The following example will render the index.pode view when you navigate to http://localhost:8080 , it will also supply dynamic data - in this case, the current date: The dynamic data can be used in your pode view via $($data.date) Server { listen * : 8080 http engine pode route get '/' { view 'index' -d @{ 'date' = [DateTime] :: Now } } } Parameters Name Type Required Description Default Path string true The path to the view to render, relative to your /views directory null Data hashtable false A hashtable of dynamic data that will be supplied to .pode , and other third-party template engine, view files @{} FlashMessages switch false If true, will load all flash messages from the current session into the dynamic view's data as $data.flash false","title":"View"},{"location":"Functions/Response/View/#view","text":"","title":"View"},{"location":"Functions/Response/View/#description","text":"The view function allows you to render view files that are placed within the /views directory at the root of your server. When you call view , Pode will automatically look within this directory for files. Pode uses a View Engine to render either HTML, Pode, or other file types. Default is HTML, and you can change it to Pode, or other third-party engines, by using the engine function.","title":"Description"},{"location":"Functions/Response/View/#examples","text":"","title":"Examples"},{"location":"Functions/Response/View/#example-1","text":"The following example will render the index.html view when you navigate to http://localhost:8080 : Server { listen * : 8080 http route get '/' { view 'index' } }","title":"Example 1"},{"location":"Functions/Response/View/#example-2","text":"The following example will render the index.pode view when you navigate to http://localhost:8080 : Server { listen * : 8080 http engine pode route get '/' { view 'index' } }","title":"Example 2"},{"location":"Functions/Response/View/#example-3","text":"The following example will render the index.pode view when you navigate to http://localhost:8080 , it will also supply dynamic data - in this case, the current date: The dynamic data can be used in your pode view via $($data.date) Server { listen * : 8080 http engine pode route get '/' { view 'index' -d @{ 'date' = [DateTime] :: Now } } }","title":"Example 3"},{"location":"Functions/Response/View/#parameters","text":"Name Type Required Description Default Path string true The path to the view to render, relative to your /views directory null Data hashtable false A hashtable of dynamic data that will be supplied to .pode , and other third-party template engine, view files @{} FlashMessages switch false If true, will load all flash messages from the current session into the dynamic view's data as $data.flash false","title":"Parameters"},{"location":"Functions/Response/Xml/","text":"Xml Description The xml function converts a hashtable , or reads in a file, and converts it to XML; the XML value is then written to the web response. You can also supply raw XML data as the value to write. Examples Example 1 The following example will convert a hashtable to XML and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { xml @{ 'cpu' = 80 ; 'memory' = 15 ; } } } Example 2 The following example will write raw XML data to a web response within a route : Server { listen * : 8080 http route get '/info' { xml '<root><users><user>Rick</user><user>Morty</user></users></root>' } } Example 3 The following example will read in a file, and write the contents as XML to a web response within a route : Server { listen * : 8080 http route get '/data' { xml -file './files/data.xml' } } Parameters Name Type Required Description Default Value hashtable/string true The value should either be a hashtable or string - the string can be either a path or raw XML. It will be converted to XML, if not raw, and attached to the web response null File switch false If passed, the above value should be a string that's a path to an XML file false","title":"Xml"},{"location":"Functions/Response/Xml/#xml","text":"","title":"Xml"},{"location":"Functions/Response/Xml/#description","text":"The xml function converts a hashtable , or reads in a file, and converts it to XML; the XML value is then written to the web response. You can also supply raw XML data as the value to write.","title":"Description"},{"location":"Functions/Response/Xml/#examples","text":"","title":"Examples"},{"location":"Functions/Response/Xml/#example-1","text":"The following example will convert a hashtable to XML and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { xml @{ 'cpu' = 80 ; 'memory' = 15 ; } } }","title":"Example 1"},{"location":"Functions/Response/Xml/#example-2","text":"The following example will write raw XML data to a web response within a route : Server { listen * : 8080 http route get '/info' { xml '<root><users><user>Rick</user><user>Morty</user></users></root>' } }","title":"Example 2"},{"location":"Functions/Response/Xml/#example-3","text":"The following example will read in a file, and write the contents as XML to a web response within a route : Server { listen * : 8080 http route get '/data' { xml -file './files/data.xml' } }","title":"Example 3"},{"location":"Functions/Response/Xml/#parameters","text":"Name Type Required Description Default Value hashtable/string true The value should either be a hashtable or string - the string can be either a path or raw XML. It will be converted to XML, if not raw, and attached to the web response null File switch false If passed, the above value should be a string that's a path to an XML file false","title":"Parameters"},{"location":"Functions/Utility/Await/","text":"Await Description The await function takes a [System.Threading.Tasks.Task] object, and waits for it to complete. If running within the context of Pode, a cancellation token will be supplied for when you terminate/restart your server. If the task's result object is non-null, then a value is returned from the await function. Examples Example 1 The following example will wait on an async call for an HttpListener ; on completion, the HttpContext is returned: Server { $context = ( await $httpListener . GetContextAsync ()) } Example 2 The following example will async write some bytes to a stream. Since the WriteAsync function doesn't return a value, then await also doesn't return anything: Server { await $stream . WriteAsync ( $bytes , 0 , $bytes . Length ) } Parameters Name Type Required Description Default Task [System.Threading.Tasks.Task] true The task to wait on for completion null","title":"Await"},{"location":"Functions/Utility/Await/#await","text":"","title":"Await"},{"location":"Functions/Utility/Await/#description","text":"The await function takes a [System.Threading.Tasks.Task] object, and waits for it to complete. If running within the context of Pode, a cancellation token will be supplied for when you terminate/restart your server. If the task's result object is non-null, then a value is returned from the await function.","title":"Description"},{"location":"Functions/Utility/Await/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/Await/#example-1","text":"The following example will wait on an async call for an HttpListener ; on completion, the HttpContext is returned: Server { $context = ( await $httpListener . GetContextAsync ()) }","title":"Example 1"},{"location":"Functions/Utility/Await/#example-2","text":"The following example will async write some bytes to a stream. Since the WriteAsync function doesn't return a value, then await also doesn't return anything: Server { await $stream . WriteAsync ( $bytes , 0 , $bytes . Length ) }","title":"Example 2"},{"location":"Functions/Utility/Await/#parameters","text":"Name Type Required Description Default Task [System.Threading.Tasks.Task] true The task to wait on for completion null","title":"Parameters"},{"location":"Functions/Utility/Dispose/","text":"Dispose Description The dispose function takes a disposable object and will optionally close the object, and then dispose of the object. Examples Example 1 The following example takes a StreamReader , and then closes and disposes of the object: Server { $reader = [System.IO.StreamReader] :: new ( $stream ) # logic that uses the reader dispose $reader -close } Parameters Name Type Required Description Default InputObject IDisposable true A disposable object that will be optionally closed, and then disposed null Close switch false If passed, the object will first be closed before being disposed false CheckNetwork switch false If passed, any exceptions thrown will be checked; if they are one of the validated network errors the exception will be ignored false Info The network errors ignored by the -CheckNetwork flag are: network name is no longer available nonexistent network connection broken pipe","title":"Dispose"},{"location":"Functions/Utility/Dispose/#dispose","text":"","title":"Dispose"},{"location":"Functions/Utility/Dispose/#description","text":"The dispose function takes a disposable object and will optionally close the object, and then dispose of the object.","title":"Description"},{"location":"Functions/Utility/Dispose/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/Dispose/#example-1","text":"The following example takes a StreamReader , and then closes and disposes of the object: Server { $reader = [System.IO.StreamReader] :: new ( $stream ) # logic that uses the reader dispose $reader -close }","title":"Example 1"},{"location":"Functions/Utility/Dispose/#parameters","text":"Name Type Required Description Default InputObject IDisposable true A disposable object that will be optionally closed, and then disposed null Close switch false If passed, the object will first be closed before being disposed false CheckNetwork switch false If passed, any exceptions thrown will be checked; if they are one of the validated network errors the exception will be ignored false Info The network errors ignored by the -CheckNetwork flag are: network name is no longer available nonexistent network connection broken pipe","title":"Parameters"},{"location":"Functions/Utility/Flash/","text":"Flash Description The flash function allows you to add messages onto a user's current session. This does mean that session middleware is required . Using flash messages allows you to add informational/error messages to the session, which can be later retrieved on a different web request for the same user session. The act of retrieving a flash message from the session will remove the message. Adding multiple messages under the same key will aggregate them as an array of messages. Flash messages are useful when validating request data: adding error messages to the session, and then passing them back through to a view on a redirect/reload (ie, sign-up/login pages). Tip Views have a -FlashMessages switch which allows you to automatically load all flash messages into the $data of a dynamic view. Authentication checks have a FailureFlash option to automatically load error messages in the session. Examples Example 1 The following example will add a flash message to the session flash add 'address-error' 'Invalid home number supplied for address' Example 2 The following example will retrieve a flash message - when retrieved, the key will be removed from the current user session flash get 'address-error' Parameters Name Type Required Description Default Action string true The action to perform on the flash message (Values: Add, Clear, Get, Keys, Remove) empty Key string false The key identifier of the message for later retrieval empty Message string false The message to add to the key, messages for the same key are appended as an array empty","title":"Flash"},{"location":"Functions/Utility/Flash/#flash","text":"","title":"Flash"},{"location":"Functions/Utility/Flash/#description","text":"The flash function allows you to add messages onto a user's current session. This does mean that session middleware is required . Using flash messages allows you to add informational/error messages to the session, which can be later retrieved on a different web request for the same user session. The act of retrieving a flash message from the session will remove the message. Adding multiple messages under the same key will aggregate them as an array of messages. Flash messages are useful when validating request data: adding error messages to the session, and then passing them back through to a view on a redirect/reload (ie, sign-up/login pages). Tip Views have a -FlashMessages switch which allows you to automatically load all flash messages into the $data of a dynamic view. Authentication checks have a FailureFlash option to automatically load error messages in the session.","title":"Description"},{"location":"Functions/Utility/Flash/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/Flash/#example-1","text":"The following example will add a flash message to the session flash add 'address-error' 'Invalid home number supplied for address'","title":"Example 1"},{"location":"Functions/Utility/Flash/#example-2","text":"The following example will retrieve a flash message - when retrieved, the key will be removed from the current user session flash get 'address-error'","title":"Example 2"},{"location":"Functions/Utility/Flash/#parameters","text":"Name Type Required Description Default Action string true The action to perform on the flash message (Values: Add, Clear, Get, Keys, Remove) empty Key string false The key identifier of the message for later retrieval empty Message string false The message to add to the key, messages for the same key are appended as an array empty","title":"Parameters"},{"location":"Functions/Utility/Include/","text":"Include Description The include function can only be used within a .pode view file; it allows you to include other views (html/pode/other) into a main view. This way you can have shared partial views (like headers, footers or navigation), and include them into your main views. Examples Example 1 The following example will include a header partial view file into below example index.pode file: <!-- /views/index.pode --> < html > $(include shared/head) < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > <!-- /views/shared/head.pode --> < head > < title > Include Example </ title > </ head > Example 2 The following example will include the header partial view file, but this time will supply some dynamic data: <!-- /views/index.pode --> < html > $(include shared/head -d @{ 'PageName' = 'Index' }) < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > <!-- /views/shared/head.pode --> < head > < title > Page: $($data.PageName) </ title > </ head > Parameters Name Type Required Description Default Path string true The path to the view that should be included, relative to the /views directory empty Data hashtable false A hashtable of dynamic data that will be supplied to .pode , and other third-party template engine, view files @{}","title":"Include"},{"location":"Functions/Utility/Include/#include","text":"","title":"Include"},{"location":"Functions/Utility/Include/#description","text":"The include function can only be used within a .pode view file; it allows you to include other views (html/pode/other) into a main view. This way you can have shared partial views (like headers, footers or navigation), and include them into your main views.","title":"Description"},{"location":"Functions/Utility/Include/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/Include/#example-1","text":"The following example will include a header partial view file into below example index.pode file: <!-- /views/index.pode --> < html > $(include shared/head) < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > <!-- /views/shared/head.pode --> < head > < title > Include Example </ title > </ head >","title":"Example 1"},{"location":"Functions/Utility/Include/#example-2","text":"The following example will include the header partial view file, but this time will supply some dynamic data: <!-- /views/index.pode --> < html > $(include shared/head -d @{ 'PageName' = 'Index' }) < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > <!-- /views/shared/head.pode --> < head > < title > Page: $($data.PageName) </ title > </ head >","title":"Example 2"},{"location":"Functions/Utility/Include/#parameters","text":"Name Type Required Description Default Path string true The path to the view that should be included, relative to the /views directory empty Data hashtable false A hashtable of dynamic data that will be supplied to .pode , and other third-party template engine, view files @{}","title":"Parameters"},{"location":"Functions/Utility/Lock/","text":"Lock Description The lock function takes an object that will be locked so that it is threadsafe. The supplied ScriptBlock will be invoked within the scope of the locked object. Tip The session object supplied to a route , timer , schedule and logger each contain a .Lockable resource that can be supplied to the lock function. Examples Example 1 The following example will lock an object, and increment a counter on the session and write it to the response in a threadsafe scope: Server { listen * : 8080 http route get '/count' { param ( $s ) lock $s . Lockable { $s . Session . Data . Views ++ json @{ 'Views' = $s . Session . Data . Views } } } } Parameters Name Type Required Description Default InputObject object true The object to lock, so that it is threadsafe within the supplied ScriptBlock null ScriptBlock scriptblock true The logic that will utilise the locked object null","title":"Lock"},{"location":"Functions/Utility/Lock/#lock","text":"","title":"Lock"},{"location":"Functions/Utility/Lock/#description","text":"The lock function takes an object that will be locked so that it is threadsafe. The supplied ScriptBlock will be invoked within the scope of the locked object. Tip The session object supplied to a route , timer , schedule and logger each contain a .Lockable resource that can be supplied to the lock function.","title":"Description"},{"location":"Functions/Utility/Lock/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/Lock/#example-1","text":"The following example will lock an object, and increment a counter on the session and write it to the response in a threadsafe scope: Server { listen * : 8080 http route get '/count' { param ( $s ) lock $s . Lockable { $s . Session . Data . Views ++ json @{ 'Views' = $s . Session . Data . Views } } } }","title":"Example 1"},{"location":"Functions/Utility/Lock/#parameters","text":"Name Type Required Description Default InputObject object true The object to lock, so that it is threadsafe within the supplied ScriptBlock null ScriptBlock scriptblock true The logic that will utilise the locked object null","title":"Parameters"},{"location":"Functions/Utility/Root/","text":"Root Description The root function returns the parent path to your server script. Tip Useful when loading local files when running Pode as a service, and the working directory is shifted to where the PowerShell executable is located. Examples Example 1 The following example will import the local module, located within the /modules directory: Server { import \" $( root ) /modules/tools.psm1\" }","title":"Root"},{"location":"Functions/Utility/Root/#root","text":"","title":"Root"},{"location":"Functions/Utility/Root/#description","text":"The root function returns the parent path to your server script. Tip Useful when loading local files when running Pode as a service, and the working directory is shifted to where the PowerShell executable is located.","title":"Description"},{"location":"Functions/Utility/Root/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/Root/#example-1","text":"The following example will import the local module, located within the /modules directory: Server { import \" $( root ) /modules/tools.psm1\" }","title":"Example 1"},{"location":"Functions/Utility/Save/","text":"Save Description The save function allows you to save a file to a specified path. You can use the function in conjunction with uploaded files, meaning you can save them to the file-system (ie: users uploading profile pictures in a <form> ) The Name supplied is used to retrieve the file's contents from the current web event's .Files array. This Name should be the name of the <form> element. Note If the path supplied to save the file is a directory, then the file is saved using the file's original upload name. If path supplied also contains a filename, such as ./image.png , then this name is used instead. Examples Example 1 The following example saves an uploaded image from a <form> , called \" prof-pic \", to the server's root path: Server { listen * : 8080 http route post '/signup' { save 'prof-pic' } } Example 2 The following example saves an uploaded image from a <form> , called \" prof-pic \", to a custom path: Server { listen * : 8080 http route post '/signup' { save 'prof-pic' 'e:/profiles/pictures' } } Parameters Name Type Required Description Default Name string true The name of the <form> element so the function can self-retrieve the file's contents null Path string false The path to save the file Server Root","title":"Save"},{"location":"Functions/Utility/Save/#save","text":"","title":"Save"},{"location":"Functions/Utility/Save/#description","text":"The save function allows you to save a file to a specified path. You can use the function in conjunction with uploaded files, meaning you can save them to the file-system (ie: users uploading profile pictures in a <form> ) The Name supplied is used to retrieve the file's contents from the current web event's .Files array. This Name should be the name of the <form> element. Note If the path supplied to save the file is a directory, then the file is saved using the file's original upload name. If path supplied also contains a filename, such as ./image.png , then this name is used instead.","title":"Description"},{"location":"Functions/Utility/Save/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/Save/#example-1","text":"The following example saves an uploaded image from a <form> , called \" prof-pic \", to the server's root path: Server { listen * : 8080 http route post '/signup' { save 'prof-pic' } }","title":"Example 1"},{"location":"Functions/Utility/Save/#example-2","text":"The following example saves an uploaded image from a <form> , called \" prof-pic \", to a custom path: Server { listen * : 8080 http route post '/signup' { save 'prof-pic' 'e:/profiles/pictures' } }","title":"Example 2"},{"location":"Functions/Utility/Save/#parameters","text":"Name Type Required Description Default Name string true The name of the <form> element so the function can self-retrieve the file's contents null Path string false The path to save the file Server Root","title":"Parameters"},{"location":"Functions/Utility/State/","text":"State Description The state function allows you to set/get objects on a shared state that exists across all runspaces; this is because functions like route and timer all run within separate runspaces - meaning normally you can't create a variable in a timer and then access that variable in a route . The state function overcomes this by letting you create a variable in a timer and set it against the shared state, then you can retrieve that variable from the state in a route . Tip It's wise to use the state function in conjunction with the lock function, so as to ensure thread safety between runspaces. The event object supplied to a route , timer , schedule and logger each contain a .Lockable resource that can be supplied to the lock function. Warning If you omit the use of lock , you will run into errors due to multi-threading. Only omit if you are absolutely confident you do not need locking. (ie: you set in state once and then only ever retrieve, never updating the variable). Examples Example 1 The following example is uses a timer to create and update a hashtable , and then retrieve that variable in a route : Server { listen * : 8080 http timer 'forever' 2 { param ( $event ) $hash = $null # create a lock on a pode lockable resource for safety lock $event . Lockable { # first, attempt to get the hashtable from the state $hash = ( state get 'hash' ) # if it doesn't exist yet, set it against the state if ( $hash -eq $null ) { $hash = ( state set 'hash' @{}) $hash [ 'values' ] = @() } # add a random number to the hash, that will be reflected in the state $hash [ 'values' ] += ( Get-Random -Minimum 0 -Maximum 10 ) } } route get '/state' { param ( $event ) # create another lock on the same lockable resource lock $event . Lockable { # get the hashtable defined in the timer above, and return it as json $hash = ( state get 'hash' ) json $hash } } } Parameters Name Type Required Description Default Action string true The action to perform on the shared state for the variable (Values: Get, Set, Remove) empty Name string true The name of the variable within the shared state empty Object object false Should only be supplied for an action of set . This is the value for the variable in the shared state null","title":"State"},{"location":"Functions/Utility/State/#state","text":"","title":"State"},{"location":"Functions/Utility/State/#description","text":"The state function allows you to set/get objects on a shared state that exists across all runspaces; this is because functions like route and timer all run within separate runspaces - meaning normally you can't create a variable in a timer and then access that variable in a route . The state function overcomes this by letting you create a variable in a timer and set it against the shared state, then you can retrieve that variable from the state in a route . Tip It's wise to use the state function in conjunction with the lock function, so as to ensure thread safety between runspaces. The event object supplied to a route , timer , schedule and logger each contain a .Lockable resource that can be supplied to the lock function. Warning If you omit the use of lock , you will run into errors due to multi-threading. Only omit if you are absolutely confident you do not need locking. (ie: you set in state once and then only ever retrieve, never updating the variable).","title":"Description"},{"location":"Functions/Utility/State/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/State/#example-1","text":"The following example is uses a timer to create and update a hashtable , and then retrieve that variable in a route : Server { listen * : 8080 http timer 'forever' 2 { param ( $event ) $hash = $null # create a lock on a pode lockable resource for safety lock $event . Lockable { # first, attempt to get the hashtable from the state $hash = ( state get 'hash' ) # if it doesn't exist yet, set it against the state if ( $hash -eq $null ) { $hash = ( state set 'hash' @{}) $hash [ 'values' ] = @() } # add a random number to the hash, that will be reflected in the state $hash [ 'values' ] += ( Get-Random -Minimum 0 -Maximum 10 ) } } route get '/state' { param ( $event ) # create another lock on the same lockable resource lock $event . Lockable { # get the hashtable defined in the timer above, and return it as json $hash = ( state get 'hash' ) json $hash } } }","title":"Example 1"},{"location":"Functions/Utility/State/#parameters","text":"Name Type Required Description Default Action string true The action to perform on the shared state for the variable (Values: Get, Set, Remove) empty Name string true The name of the variable within the shared state empty Object object false Should only be supplied for an action of set . This is the value for the variable in the shared state null","title":"Parameters"},{"location":"Functions/Utility/Stopwatch/","text":"Stopwatch Description The stopwatch function lets you wrap logic in a scriptblock, and have the amount of time the logic took to execute outputted to the CLI. Examples Example 1 The following example will wrap a stopwatch around reading in files and converting them to JSON: Server { stopwatch 'files' { Get-ChildItem 'c:/temp/*.json' | Foreach -Object { $content = Get-Content -Raw $_ $json = $content | ConvertFrom-Json } } } The above will run, and output something similar to the below, on the CLI: [Stopwatch]: 00:00:08.136788 [files] Parameters Name Type Required Description Default Name string true The name of the logic the stopwatch is wrapped around empty ScriptBlock scriptblock true The logic the stopwatch should time null","title":"Stopwatch"},{"location":"Functions/Utility/Stopwatch/#stopwatch","text":"","title":"Stopwatch"},{"location":"Functions/Utility/Stopwatch/#description","text":"The stopwatch function lets you wrap logic in a scriptblock, and have the amount of time the logic took to execute outputted to the CLI.","title":"Description"},{"location":"Functions/Utility/Stopwatch/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/Stopwatch/#example-1","text":"The following example will wrap a stopwatch around reading in files and converting them to JSON: Server { stopwatch 'files' { Get-ChildItem 'c:/temp/*.json' | Foreach -Object { $content = Get-Content -Raw $_ $json = $content | ConvertFrom-Json } } } The above will run, and output something similar to the below, on the CLI: [Stopwatch]: 00:00:08.136788 [files]","title":"Example 1"},{"location":"Functions/Utility/Stopwatch/#parameters","text":"Name Type Required Description Default Name string true The name of the logic the stopwatch is wrapped around empty ScriptBlock scriptblock true The logic the stopwatch should time null","title":"Parameters"},{"location":"Functions/Utility/Stream/","text":"Stream Description The stream function allows you to use streams, utilise them, and then automatically dispose of the stream object for you. Examples Example 1 The following example opens a StreamReader , reads in the content of the stream, and then automatically disposes of the stream for you. The content is then placed into the $data variable: Server { $data = stream ( [System.IO.StreamReader] :: new ( $stream )) { return $args [ 0 ]. ReadToEnd () } } Parameters Name Type Required Description Default InputObject IDisposable true A disposable object that will be used, and then disposed. This works much the same as using in C# .NET null ScriptBlock scriptblock true The logic that will utilise the disposable stream object, of which the stream itself is passed as an argument to the scriptblock null","title":"Stream"},{"location":"Functions/Utility/Stream/#stream","text":"","title":"Stream"},{"location":"Functions/Utility/Stream/#description","text":"The stream function allows you to use streams, utilise them, and then automatically dispose of the stream object for you.","title":"Description"},{"location":"Functions/Utility/Stream/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/Stream/#example-1","text":"The following example opens a StreamReader , reads in the content of the stream, and then automatically disposes of the stream for you. The content is then placed into the $data variable: Server { $data = stream ( [System.IO.StreamReader] :: new ( $stream )) { return $args [ 0 ]. ReadToEnd () } }","title":"Example 1"},{"location":"Functions/Utility/Stream/#parameters","text":"Name Type Required Description Default InputObject IDisposable true A disposable object that will be used, and then disposed. This works much the same as using in C# .NET null ScriptBlock scriptblock true The logic that will utilise the disposable stream object, of which the stream itself is passed as an argument to the scriptblock null","title":"Parameters"},{"location":"Functions/Utility/Tcp/","text":"Tcp Description The tcp function allows you to read/write messages to/from a TCP stream. By default Pode's TCP server stream is used, but you can specify a custom TCP stream to read/write. Examples Example 1 The following example will write a message onto the TCP stream: Server { listen * : 30 tcp handler tcp { tcp write 'Hello, world!' } } Example 2 The following example will read a message from the TCP stream: Server { listen * : 30 tcp handler tcp { $msg = ( tcp read ) } } Parameters Name Type Required Description Default Action string true The action to perform on the TCP stream (Values: Write, Read) empty Message string false A message to write on the TCP stream empty Client object false A custom other TCP stream, otherwise the global stream will be used global stream","title":"Tcp"},{"location":"Functions/Utility/Tcp/#tcp","text":"","title":"Tcp"},{"location":"Functions/Utility/Tcp/#description","text":"The tcp function allows you to read/write messages to/from a TCP stream. By default Pode's TCP server stream is used, but you can specify a custom TCP stream to read/write.","title":"Description"},{"location":"Functions/Utility/Tcp/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/Tcp/#example-1","text":"The following example will write a message onto the TCP stream: Server { listen * : 30 tcp handler tcp { tcp write 'Hello, world!' } }","title":"Example 1"},{"location":"Functions/Utility/Tcp/#example-2","text":"The following example will read a message from the TCP stream: Server { listen * : 30 tcp handler tcp { $msg = ( tcp read ) } }","title":"Example 2"},{"location":"Functions/Utility/Tcp/#parameters","text":"Name Type Required Description Default Action string true The action to perform on the TCP stream (Values: Write, Read) empty Message string false A message to write on the TCP stream empty Client object false A custom other TCP stream, otherwise the global stream will be used global stream","title":"Parameters"},{"location":"Getting-Started/CLI/","text":"CLI Pode has some commands that you can utilise from the CLI - when your in a PowerShell terminal, or pwsh session. These commands help you to initialise, start, test, build, or install any packages for your repo/server. All of these commands are centered around the package.json format - similar to that of Node.js and Yarn. Info At the moment, Pode only uses the start , test , build and install properties of the scripts section in your package.json . You can still have others, like dependencies for Yarn Commands Build The build action will run the script found in the package.json file, at the scripts/build value: pode build Init The init action will help you create a new package.json file from scratch. It will ask a few questions, such as author/name/etc, and then create the file for you: pode init Tip By default, Pode will pre-populate the test , build and install values using yarn , psake and pester respectively Install The install action will run the script found in the package.json file, at the scripts/install value: pode install Start The start action will run the script found in the package.json file, at the scripts/start value. If this value is not set, then this action will instead run the value under main : pode start Test The test action will run the script found in the package.json file, at the scripts/test value: pode test Package File The following is an example of a package.json file: { \"name\" : \"example\" , \"description\" : \"\" , \"version\" : \"1.0.0\" , \"main\" : \"./server.ps1\" , \"scripts\" : { \"start\" : \"./server.ps1\" , \"test\" : \"invoke-pester ./tests/*.ps1\" , \"install\" : \"yarn install --force --ignore-scripts --modules-folder pode_modules\" , \"build\" : \"psake\" }, \"author\" : \"Rick Sanchez\" , \"license\" : \"MIT\" }","title":"CLI"},{"location":"Getting-Started/CLI/#cli","text":"Pode has some commands that you can utilise from the CLI - when your in a PowerShell terminal, or pwsh session. These commands help you to initialise, start, test, build, or install any packages for your repo/server. All of these commands are centered around the package.json format - similar to that of Node.js and Yarn. Info At the moment, Pode only uses the start , test , build and install properties of the scripts section in your package.json . You can still have others, like dependencies for Yarn","title":"CLI"},{"location":"Getting-Started/CLI/#commands","text":"","title":"Commands"},{"location":"Getting-Started/CLI/#build","text":"The build action will run the script found in the package.json file, at the scripts/build value: pode build","title":"Build"},{"location":"Getting-Started/CLI/#init","text":"The init action will help you create a new package.json file from scratch. It will ask a few questions, such as author/name/etc, and then create the file for you: pode init Tip By default, Pode will pre-populate the test , build and install values using yarn , psake and pester respectively","title":"Init"},{"location":"Getting-Started/CLI/#install","text":"The install action will run the script found in the package.json file, at the scripts/install value: pode install","title":"Install"},{"location":"Getting-Started/CLI/#start","text":"The start action will run the script found in the package.json file, at the scripts/start value. If this value is not set, then this action will instead run the value under main : pode start","title":"Start"},{"location":"Getting-Started/CLI/#test","text":"The test action will run the script found in the package.json file, at the scripts/test value: pode test","title":"Test"},{"location":"Getting-Started/CLI/#package-file","text":"The following is an example of a package.json file: { \"name\" : \"example\" , \"description\" : \"\" , \"version\" : \"1.0.0\" , \"main\" : \"./server.ps1\" , \"scripts\" : { \"start\" : \"./server.ps1\" , \"test\" : \"invoke-pester ./tests/*.ps1\" , \"install\" : \"yarn install --force --ignore-scripts --modules-folder pode_modules\" , \"build\" : \"psake\" }, \"author\" : \"Rick Sanchez\" , \"license\" : \"MIT\" }","title":"Package File"},{"location":"Getting-Started/Docker/","text":"Docker Pode has a Docker container that you can use, by calling docker pull badgerati/pode you can pull down the latest image. The image itself uses PowerShell Core on the Ubuntu Xenial OS. Dockerfile An example of using the Pode container in your Dockerfile could be as follows: Info The server script used below can be found in the examples/web-pages-docker.ps1 # pull down the pode image FROM badgerati/pode # copy over the local files to the container COPY . /usr/src/app/ # expose the port EXPOSE 8085 # run the server CMD [ \"pwsh\", \"-c\", \"cd /usr/src/app; ./web-pages-docker.ps1\" ] Build and Run To build and run the above Dockerfile, you can use the following commands: docker build -t pode/example . docker run -p 8085 :8085 -d pode/example Info The Dockerfile above is the same Dockerfile in the examples/ directory Now try navigating to localhost:8085 (or calling curl localhost:8085 ) and you should be greeted with a \"Hello, world!\" page.","title":"Docker"},{"location":"Getting-Started/Docker/#docker","text":"Pode has a Docker container that you can use, by calling docker pull badgerati/pode you can pull down the latest image. The image itself uses PowerShell Core on the Ubuntu Xenial OS.","title":"Docker"},{"location":"Getting-Started/Docker/#dockerfile","text":"An example of using the Pode container in your Dockerfile could be as follows: Info The server script used below can be found in the examples/web-pages-docker.ps1 # pull down the pode image FROM badgerati/pode # copy over the local files to the container COPY . /usr/src/app/ # expose the port EXPOSE 8085 # run the server CMD [ \"pwsh\", \"-c\", \"cd /usr/src/app; ./web-pages-docker.ps1\" ]","title":"Dockerfile"},{"location":"Getting-Started/Docker/#build-and-run","text":"To build and run the above Dockerfile, you can use the following commands: docker build -t pode/example . docker run -p 8085 :8085 -d pode/example Info The Dockerfile above is the same Dockerfile in the examples/ directory Now try navigating to localhost:8085 (or calling curl localhost:8085 ) and you should be greeted with a \"Hello, world!\" page.","title":"Build and Run"},{"location":"Getting-Started/FirstApp/","text":"Building your first Pode app Note Before starting, ensure you've installed Pode. The following steps will run you through creating your first Pode app, and give you an overview to some of the basic features. Setup First, create a /my-first-pode-app directory, this should be where ever you put your project/learning code. Open PowerShell, and navigate to the above directory. Run pode init in the console, this will create a basic package.json file for you - see the CLI reference for more information. The init action will ask for some input, leave everything as default (just press enter). \u03bb pode init name ( my-first-pode-app ) : version ( 1 . 0 . 0 ) : description : entry point (./ server . ps1 ) : author : license ( MIT ) : Success , saved package . json In your favourite text editor, create a server.ps1 file within the directory. REST Server Within your server.ps1 file, first import the Pode module: Import-Module Pode Next, you need to create the server . This is where the main script will go that defines how the server should function: Server { # logic } Now we have our server, we need to get it to listen on an endpoint. This will allow us to receive requests and respond to them. The below tells you server to listen on localhost for port 8080 for HTTP requests: Server { listen localhost : 8080 http } Our simple server will have a single GET route , that will be invoked when the root ( / ) of the server is called (ie: http://localhost:8080/ ). This route will respond with a simple JSON response: Server { listen localhost : 8080 http route get '/' { json @{ 'value' = 'Hello, world!' } } } Save the file, and run pode start (or ./server.ps1 ) from the console. This will start the server listening on localhost:8080 . When http://localhost:8080/ is hit, the server will respond with: { \"value\" : \"Hello, world!\" } More Tutorials To see how to create web pages using Pode, see here To see how to do basic login/logout pages, see here For more tutorials, see here","title":"Build Your First App"},{"location":"Getting-Started/FirstApp/#building-your-first-pode-app","text":"Note Before starting, ensure you've installed Pode. The following steps will run you through creating your first Pode app, and give you an overview to some of the basic features.","title":"Building your first Pode app"},{"location":"Getting-Started/FirstApp/#setup","text":"First, create a /my-first-pode-app directory, this should be where ever you put your project/learning code. Open PowerShell, and navigate to the above directory. Run pode init in the console, this will create a basic package.json file for you - see the CLI reference for more information. The init action will ask for some input, leave everything as default (just press enter). \u03bb pode init name ( my-first-pode-app ) : version ( 1 . 0 . 0 ) : description : entry point (./ server . ps1 ) : author : license ( MIT ) : Success , saved package . json In your favourite text editor, create a server.ps1 file within the directory.","title":"Setup"},{"location":"Getting-Started/FirstApp/#rest-server","text":"Within your server.ps1 file, first import the Pode module: Import-Module Pode Next, you need to create the server . This is where the main script will go that defines how the server should function: Server { # logic } Now we have our server, we need to get it to listen on an endpoint. This will allow us to receive requests and respond to them. The below tells you server to listen on localhost for port 8080 for HTTP requests: Server { listen localhost : 8080 http } Our simple server will have a single GET route , that will be invoked when the root ( / ) of the server is called (ie: http://localhost:8080/ ). This route will respond with a simple JSON response: Server { listen localhost : 8080 http route get '/' { json @{ 'value' = 'Hello, world!' } } } Save the file, and run pode start (or ./server.ps1 ) from the console. This will start the server listening on localhost:8080 . When http://localhost:8080/ is hit, the server will respond with: { \"value\" : \"Hello, world!\" }","title":"REST Server"},{"location":"Getting-Started/FirstApp/#more-tutorials","text":"To see how to create web pages using Pode, see here To see how to do basic login/logout pages, see here For more tutorials, see here","title":"More Tutorials"},{"location":"Getting-Started/Frontend/","text":"Frontend You can host web-pages using Pode, and to help you can also use package managers like yarn to install frontend libraries - like bootstrap. Using Yarn The following will install Yarn onto your machine: choco install yarn -y yarn init Once installed, you can use Yarn to download frontend libraries. The libraries will be added to a package.json file - which if you're using the Pode CLI, you'll already have in place. To install frontend libraries, you could use the following: yarn add bootstrap yarn add lodash Pode Install Once you've added some libraries you can use pode install to trigger yarn . This will tell yarn to install the packages to a pode_modules directory. Info Other useful packages could include gulp , jquery , moment , etc.","title":"Frontend"},{"location":"Getting-Started/Frontend/#frontend","text":"You can host web-pages using Pode, and to help you can also use package managers like yarn to install frontend libraries - like bootstrap.","title":"Frontend"},{"location":"Getting-Started/Frontend/#using-yarn","text":"The following will install Yarn onto your machine: choco install yarn -y yarn init Once installed, you can use Yarn to download frontend libraries. The libraries will be added to a package.json file - which if you're using the Pode CLI, you'll already have in place. To install frontend libraries, you could use the following: yarn add bootstrap yarn add lodash","title":"Using Yarn"},{"location":"Getting-Started/Frontend/#pode-install","text":"Once you've added some libraries you can use pode install to trigger yarn . This will tell yarn to install the packages to a pode_modules directory. Info Other useful packages could include gulp , jquery , moment , etc.","title":"Pode Install"},{"location":"Getting-Started/Installation/","text":"Installation Pode is a PowerShell module that can be installed from either Chocolatey, PowerShell Gallery, or Docker. Once installed, you can import the module into your PowerShell scripts. Chocolatey To install Pode via Chocolatey, the following command can be used: choco install pode PowerShell Gallery To install Pode from the PowerShell Gallery, you can use the following: Install-Module -Name Pode Docker Pode can run on *nix environments, therefore it only makes sense for there to be a Docker container for you to use! The container uses PowerShell Core on an Ubuntu Xenial container. To pull down the Pode container you can do: docker pull badgerati / pode Once pulled, you can view here on how to use the image. Using the Module After you have installed the module, you can then import it into your server scripts: Import-Module Pode","title":"Installation"},{"location":"Getting-Started/Installation/#installation","text":"Pode is a PowerShell module that can be installed from either Chocolatey, PowerShell Gallery, or Docker. Once installed, you can import the module into your PowerShell scripts.","title":"Installation"},{"location":"Getting-Started/Installation/#chocolatey","text":"To install Pode via Chocolatey, the following command can be used: choco install pode","title":"Chocolatey"},{"location":"Getting-Started/Installation/#powershell-gallery","text":"To install Pode from the PowerShell Gallery, you can use the following: Install-Module -Name Pode","title":"PowerShell Gallery"},{"location":"Getting-Started/Installation/#docker","text":"Pode can run on *nix environments, therefore it only makes sense for there to be a Docker container for you to use! The container uses PowerShell Core on an Ubuntu Xenial container. To pull down the Pode container you can do: docker pull badgerati / pode Once pulled, you can view here on how to use the image.","title":"Docker"},{"location":"Getting-Started/Installation/#using-the-module","text":"After you have installed the module, you can then import it into your server scripts: Import-Module Pode","title":"Using the Module"},{"location":"Getting-Started/KnownIssues/","text":"Known Issues Below is a list of reported issues when using Pode, and the way to resolve them: Long URL Segements Reported in issue #45 . On Windows systems there is a limit on the maximum length of URL segments. It's usually about 260 characters, and anything above this will cause Pode to throw a 400 Bad Request error. To resolve, you can set the UrlSegmentMaxLength registry setting to 0 (for unlimited), or any other value. The below PowerShell will set the value to unlimited: New-ItemProperty -Path 'HKLM:\\System\\CurrentControlSet\\Services\\HTTP\\Parameters' -Name 'UrlSegmentMaxLength' -Value 0 -PropertyType DWord -Force","title":"Known Issues"},{"location":"Getting-Started/KnownIssues/#known-issues","text":"Below is a list of reported issues when using Pode, and the way to resolve them:","title":"Known Issues"},{"location":"Getting-Started/KnownIssues/#long-url-segements","text":"Reported in issue #45 . On Windows systems there is a limit on the maximum length of URL segments. It's usually about 260 characters, and anything above this will cause Pode to throw a 400 Bad Request error. To resolve, you can set the UrlSegmentMaxLength registry setting to 0 (for unlimited), or any other value. The below PowerShell will set the value to unlimited: New-ItemProperty -Path 'HKLM:\\System\\CurrentControlSet\\Services\\HTTP\\Parameters' -Name 'UrlSegmentMaxLength' -Value 0 -PropertyType DWord -Force","title":"Long URL Segements"},{"location":"Getting-Started/LocalModules/","text":"Local Modules To save installing PowerShell modules globally, Pode allows you to specify modules in the package.json file; these modules will be downloaded into a ps_modules folder at the root of your server. Important Pode will only download modules from the PowerShell Gallery. This is only a basic implementation, if you wish to download from other locations, we'd recommend looking at other tools such as PSDepend or PSPM Package.json Within your server's package.json file, you can specify a modules and devModules section with a list of modules and their versions to download: { \"modules\" : { \"eps\" : \"0.5.0\" }, \"devModules\" : { \"pester\" : \"latest\" } } The \"latest\" version will always install the latest version of the module. When installing, if Pode detects a different version already downloaded then it will be removed. Pode Install When you have modules defined within your package.jon file, then calling pode install from the CLI will automatically download any defined modules. Using pode -d install will also install the modules, but will also install the dev-modules. These modules will be downloaded into a ps_modules directory at the root of your server. For example, using the above package.json and calling pode -d install will create the following directory structure: server.ps1 package.json /ps_modules /eps /0.5.0 /pester /4.6.0 Importing When you have the modules downloaded, you can utilise them using the import function.","title":"Local Modules"},{"location":"Getting-Started/LocalModules/#local-modules","text":"To save installing PowerShell modules globally, Pode allows you to specify modules in the package.json file; these modules will be downloaded into a ps_modules folder at the root of your server. Important Pode will only download modules from the PowerShell Gallery. This is only a basic implementation, if you wish to download from other locations, we'd recommend looking at other tools such as PSDepend or PSPM","title":"Local Modules"},{"location":"Getting-Started/LocalModules/#packagejson","text":"Within your server's package.json file, you can specify a modules and devModules section with a list of modules and their versions to download: { \"modules\" : { \"eps\" : \"0.5.0\" }, \"devModules\" : { \"pester\" : \"latest\" } } The \"latest\" version will always install the latest version of the module. When installing, if Pode detects a different version already downloaded then it will be removed.","title":"Package.json"},{"location":"Getting-Started/LocalModules/#pode-install","text":"When you have modules defined within your package.jon file, then calling pode install from the CLI will automatically download any defined modules. Using pode -d install will also install the modules, but will also install the dev-modules. These modules will be downloaded into a ps_modules directory at the root of your server. For example, using the above package.json and calling pode -d install will create the following directory structure: server.ps1 package.json /ps_modules /eps /0.5.0 /pester /4.6.0","title":"Pode Install"},{"location":"Getting-Started/LocalModules/#importing","text":"When you have the modules downloaded, you can utilise them using the import function.","title":"Importing"},{"location":"Getting-Started/RunAsService/","text":"Running Pode as a Service Rather than having to manually invoke your Pode server script each time, it's best if you can have it start automatically when your computer/server starts. Below you'll see how to set your script to run as either a Windows or a Linux service. Windows To run your Pode server as a Windows service, we recommend using the NSSM tool. To install on Windows you can use Chocolatey: choco install nssm -y Once installed, you'll need to set the location of the pwsh or powershell executables as a variable: $exe = ( Get-Command pwsh . exe ). Source # or $exe = ( Get-Command powershell . exe ). Source Next, define the name of the Windows service; as well as the full file path to your Pode server script, and the arguments to be supplied to PowerShell: $name = 'Pode Web Server' $file = 'C:\\Pode\\Server.ps1' $arg = \"-ExecutionPolicy Bypass -NoProfile -Command `\" $( $file ) `\" \" Finally, install and start the service: nssm install $name $exe $arg nssm start $name Info You can now navigate to your server, ie: http://localhost:8080 . To stop (or remove) the service afterwards, you can use the following: nssm stop $name nssm remove $name confirm Linux To run your Pode server as a Linux service you just need to create a <name>.service file at /etc/systemd/system . The following is example content for an example pode-server.service file, which run PowerShell Core ( pwsh ), as well as you script: sudo vim /etc/systemd/system/pode-server.service [ Unit ] Description = Pode Web Server After = network.target [ Service ] ExecStart = /usr/bin/pwsh -c /usr/src/pode/server.ps1 -nop -ep Bypass Restart = always [ Install ] WantedBy = multi-user.target Alias = pode-server.service Finally, start the service: sudo systemctl start pode-server Info You can now navigate to your server, ie: http://localhost:8080 . To stop the service afterwards, you can use the following: sudo systemctl stop pode-server","title":"Run as a Service"},{"location":"Getting-Started/RunAsService/#running-pode-as-a-service","text":"Rather than having to manually invoke your Pode server script each time, it's best if you can have it start automatically when your computer/server starts. Below you'll see how to set your script to run as either a Windows or a Linux service.","title":"Running Pode as a Service"},{"location":"Getting-Started/RunAsService/#windows","text":"To run your Pode server as a Windows service, we recommend using the NSSM tool. To install on Windows you can use Chocolatey: choco install nssm -y Once installed, you'll need to set the location of the pwsh or powershell executables as a variable: $exe = ( Get-Command pwsh . exe ). Source # or $exe = ( Get-Command powershell . exe ). Source Next, define the name of the Windows service; as well as the full file path to your Pode server script, and the arguments to be supplied to PowerShell: $name = 'Pode Web Server' $file = 'C:\\Pode\\Server.ps1' $arg = \"-ExecutionPolicy Bypass -NoProfile -Command `\" $( $file ) `\" \" Finally, install and start the service: nssm install $name $exe $arg nssm start $name Info You can now navigate to your server, ie: http://localhost:8080 . To stop (or remove) the service afterwards, you can use the following: nssm stop $name nssm remove $name confirm","title":"Windows"},{"location":"Getting-Started/RunAsService/#linux","text":"To run your Pode server as a Linux service you just need to create a <name>.service file at /etc/systemd/system . The following is example content for an example pode-server.service file, which run PowerShell Core ( pwsh ), as well as you script: sudo vim /etc/systemd/system/pode-server.service [ Unit ] Description = Pode Web Server After = network.target [ Service ] ExecStart = /usr/bin/pwsh -c /usr/src/pode/server.ps1 -nop -ep Bypass Restart = always [ Install ] WantedBy = multi-user.target Alias = pode-server.service Finally, start the service: sudo systemctl start pode-server Info You can now navigate to your server, ie: http://localhost:8080 . To stop the service afterwards, you can use the following: sudo systemctl stop pode-server","title":"Linux"},{"location":"Tutorials/Basics/","text":"Basics Pode at its heart is a PowerShell module, in order to use Pode you'll need to start off by importing it into your scripts: Import-Module Pode After that, all of your main server logic must be wrapped in a Server block: Import-Module Pode Server { # attach to port 8080 listen * : 8080 http # logic for routes, timers, schedules, etc } Warning You can only have one Server declared in your script The above Server will start a basic HTTP listener on port 8080. To start the server you can either: Directly run the ./server.ps1 script, or If you've created a package.json file, ensure the ./server.ps1 script is set as your main or scripts/start , then just run pode start (more here ) Tip Once Pode has started, you can exit out at any time using Ctrl+C . You can also restart the server by using Ctrl+R .","title":"Basics"},{"location":"Tutorials/Basics/#basics","text":"Pode at its heart is a PowerShell module, in order to use Pode you'll need to start off by importing it into your scripts: Import-Module Pode After that, all of your main server logic must be wrapped in a Server block: Import-Module Pode Server { # attach to port 8080 listen * : 8080 http # logic for routes, timers, schedules, etc } Warning You can only have one Server declared in your script The above Server will start a basic HTTP listener on port 8080. To start the server you can either: Directly run the ./server.ps1 script, or If you've created a package.json file, ensure the ./server.ps1 script is set as your main or scripts/start , then just run pode start (more here ) Tip Once Pode has started, you can exit out at any time using Ctrl+C . You can also restart the server by using Ctrl+R .","title":"Basics"},{"location":"Tutorials/Certificates/","text":"Certificates Warning Binding existing, and generating self-signed certificates is only supported on Windows . Pode has the ability to generate and bind self-signed certificates (for dev/testing), as well as the ability to bind existing - already installed - certificates for HTTPS. If Pode detects that the IP:Port or Hostname:Port binding already has a certificate bound, then Pode will re-use that certificate and will not create a new self-signed certificate, or bind a new certificate. Self-Signed If you are developing/testing a site on HTTPS then Pode can generate and bind quick self-signed certificates. To do this you can pass the value self to the -cert parameter of the listen : Server { # for an IP: listen * : 8443 https -cert self # for a hostname: listen foo . bar . com : 8443 https -cert self } Pre-Installed To bind an already installed signed certificate, the certificate must be installed to Cert:/LocalMachine/My . Then you can pass the certificate name/domain to -cert parameter; an example for *.example.com is as follows: Server { # for an IP: listen * : 8443 https -cert '*.example.com' # for a hostname listen foo . example . com : 8443 https -cert '*.example.com' } Clean-Up If you want to use a new certificate on a binding that already has one, then you'll have to clean-up the binding first. Calling either: netsh http delete sslcert ipport=<ip>:<port> netsh http delete sslcert hostnameport=<hostname>:<port> will remove the binding.","title":"Certificates"},{"location":"Tutorials/Certificates/#certificates","text":"Warning Binding existing, and generating self-signed certificates is only supported on Windows . Pode has the ability to generate and bind self-signed certificates (for dev/testing), as well as the ability to bind existing - already installed - certificates for HTTPS. If Pode detects that the IP:Port or Hostname:Port binding already has a certificate bound, then Pode will re-use that certificate and will not create a new self-signed certificate, or bind a new certificate.","title":"Certificates"},{"location":"Tutorials/Certificates/#self-signed","text":"If you are developing/testing a site on HTTPS then Pode can generate and bind quick self-signed certificates. To do this you can pass the value self to the -cert parameter of the listen : Server { # for an IP: listen * : 8443 https -cert self # for a hostname: listen foo . bar . com : 8443 https -cert self }","title":"Self-Signed"},{"location":"Tutorials/Certificates/#pre-installed","text":"To bind an already installed signed certificate, the certificate must be installed to Cert:/LocalMachine/My . Then you can pass the certificate name/domain to -cert parameter; an example for *.example.com is as follows: Server { # for an IP: listen * : 8443 https -cert '*.example.com' # for a hostname listen foo . example . com : 8443 https -cert '*.example.com' }","title":"Pre-Installed"},{"location":"Tutorials/Certificates/#clean-up","text":"If you want to use a new certificate on a binding that already has one, then you'll have to clean-up the binding first. Calling either: netsh http delete sslcert ipport=<ip>:<port> netsh http delete sslcert hostnameport=<hostname>:<port> will remove the binding.","title":"Clean-Up"},{"location":"Tutorials/Configuration/","text":"Configuration There is an optional configuration file that can be used with Pode called called pode.json , and should be located at the root directory of your server script. Note When a server restart occurs, the pode.json file will be reloaded. Structure The configuration file is just plain JSON, so normal JSON syntax applies. Within the file you can put any settings you want however, there are 5 defined sections that should ideally be left for Pode: { \"server\" : { }, \"service\" : { }, \"web\" : { }, \"smtp\" : { }, \"tcp\" : { } } These 5 sections apply to the different server types you can build with Pode, and could be used for later inbuilt options (such as the current web/static/defaults for defining default static pages ). After this, you can put whatever else you want into the configuration file. Usage The configuration file is automatically loaded when you start your server. Pode will look in the root directory of your server for a pode.json file, and if found it will be loaded internally. Within your scripts you can use the Get-PodeConfiguration function, which will return the contents of the file. For example, say you have the following pode.json : { \"port\" : 8080 } Then you can get and use the port number via: Server { $port = ( Get-PodeConfiguration ). port listen * : $port http } Environments Besides the default pode.json file, Pode also supports environmental files based on the $env:PODE_ENVIRONMENT environment variable. For example, if you set the PODE_ENVIRONMENT variable to dev , then Pode will look for pode.dev.json first. If pode.dev.json does not exist, then the default pode.json is loaded instead.","title":"Configuration"},{"location":"Tutorials/Configuration/#configuration","text":"There is an optional configuration file that can be used with Pode called called pode.json , and should be located at the root directory of your server script. Note When a server restart occurs, the pode.json file will be reloaded.","title":"Configuration"},{"location":"Tutorials/Configuration/#structure","text":"The configuration file is just plain JSON, so normal JSON syntax applies. Within the file you can put any settings you want however, there are 5 defined sections that should ideally be left for Pode: { \"server\" : { }, \"service\" : { }, \"web\" : { }, \"smtp\" : { }, \"tcp\" : { } } These 5 sections apply to the different server types you can build with Pode, and could be used for later inbuilt options (such as the current web/static/defaults for defining default static pages ). After this, you can put whatever else you want into the configuration file.","title":"Structure"},{"location":"Tutorials/Configuration/#usage","text":"The configuration file is automatically loaded when you start your server. Pode will look in the root directory of your server for a pode.json file, and if found it will be loaded internally. Within your scripts you can use the Get-PodeConfiguration function, which will return the contents of the file. For example, say you have the following pode.json : { \"port\" : 8080 } Then you can get and use the port number via: Server { $port = ( Get-PodeConfiguration ). port listen * : $port http }","title":"Usage"},{"location":"Tutorials/Configuration/#environments","text":"Besides the default pode.json file, Pode also supports environmental files based on the $env:PODE_ENVIRONMENT environment variable. For example, if you set the PODE_ENVIRONMENT variable to dev , then Pode will look for pode.dev.json first. If pode.dev.json does not exist, then the default pode.json is loaded instead.","title":"Environments"},{"location":"Tutorials/ImportingModules/","text":"Importing Modules Because Pode runs most things in isolated runspaces, importing and using modules in Pode can be quite bothersome. To overcome this, you can use the import function to declare paths/names of modules that need to be imported into all runspaces. The import function takes a path/name of a module ( .psm1 / .psd1 ) - can be literal or relative - and adds it to the session state for each runspace pool. Import via Path The following example will tell Pode that the tools.psm1 module needs to be imported into all runspaces. This will allow the functions defined within the module to be accessible to all other functions within your server. Server { import './path/to/tools.psm1' } Import via Name The following example will tell Pode to import the EPS module into all runspaces. If you're using local modules in your package.json file, then Pode will first check to see if the EPS module is in the ps_modules directory. When Pode can't find the EPS module within the ps_modules directory, then it will attempt to import a globally installed version of the EPS module. Server { import eps }","title":"Importing Modules"},{"location":"Tutorials/ImportingModules/#importing-modules","text":"Because Pode runs most things in isolated runspaces, importing and using modules in Pode can be quite bothersome. To overcome this, you can use the import function to declare paths/names of modules that need to be imported into all runspaces. The import function takes a path/name of a module ( .psm1 / .psd1 ) - can be literal or relative - and adds it to the session state for each runspace pool.","title":"Importing Modules"},{"location":"Tutorials/ImportingModules/#import-via-path","text":"The following example will tell Pode that the tools.psm1 module needs to be imported into all runspaces. This will allow the functions defined within the module to be accessible to all other functions within your server. Server { import './path/to/tools.psm1' }","title":"Import via Path"},{"location":"Tutorials/ImportingModules/#import-via-name","text":"The following example will tell Pode to import the EPS module into all runspaces. If you're using local modules in your package.json file, then Pode will first check to see if the EPS module is in the ps_modules directory. When Pode can't find the EPS module within the ps_modules directory, then it will attempt to import a globally installed version of the EPS module. Server { import eps }","title":"Import via Name"},{"location":"Tutorials/Schedules/","text":"Schedules A schedule in Pode is a long-running async task, and unlike timers, when they trigger they are run in their own separate runspace - so they don't affect each other if they take a while to process. Schedule triggers are defined using cron expressions , basic syntax is supported as well as some predefined expressions. Schedules can start immediately, have a delayed start time, and also have a a defined end time. Create a Schedule To create a new schedule in your server you use the schedule function. The make-up of the function is as follows: schedule < name > < cron ( s )> < scriptblock > [ -start < datetime >] [ -end < datetime >] [ -limit < int >] # or shorthand: schedule < name > < cron ( s )> < scriptblock > [ -s < datetime >] [ -e < datetime >] [ -l < int >] Each schedule must have a <name> , one or more <cron> expressions, and a <scriptblock> for the main logic. The <name> must be unique across all schedules. To create a basic schedule , the following example will work; this will trigger at '00:05' every Tuesday outputting the current date/time: Server { schedule 'date' '5 0 * * TUE' { Write-Host \" $( [DateTime] :: Now ) \" } } Whereas the following will create the same schedule, but will only trigger the schedule 4 times due to the -limit value supplied: Server { schedule 'date' '5 0 * * TUE' -limit 4 { Write-Host \" $( [DateTime] :: Now ) \" } } You can also supply multiple cron expressions for the same schedule . For example, the following will trigger the same schedule every minute and every hour: Server { schedule 'date' @( '@minutely' , '@hourly' ) { Write-Host \" $( [DateTime] :: Now ) \" } } Delayed Start The -start <datetime> parameter will cause the schedule to only be triggered after the date/time defined. For example, if you have a schedule set to trigger at 00:05 every Tuesday, and you pass -start [DateTime]::Now.AddMonths(2) , then the schedule will only start trigger on Tuesdays in 2 months time. The following will create a schedule that triggers at 16:00 every Friday, and is delayed by 1 year: Server { $start = [DateTime] :: Now . AddYears ( 1 ) schedule 'date' '0 16 * * FRI' -start $start { Write-Host \" $( [DateTime] :: Now ) \" } } Defined End The -end <datetime> parameter will cause the schedule to cease triggering after the date/time defined. For example, if you have a schedule set to trigger at 00:05 every Tuesday, and you pass -end [DateTime]::Now.AddMonths(2) , then the schedule will stop triggering in 2 months time. The following will create a schedule that triggers at 16:00 every Friday, and stops triggering in 1 year: Server { $end = [DateTime] :: Now . AddYears ( 1 ) schedule 'date' '0 16 * * FRI' -end $end { Write-Host \" $( [DateTime] :: Now ) \" } }","title":"Schedules"},{"location":"Tutorials/Schedules/#schedules","text":"A schedule in Pode is a long-running async task, and unlike timers, when they trigger they are run in their own separate runspace - so they don't affect each other if they take a while to process. Schedule triggers are defined using cron expressions , basic syntax is supported as well as some predefined expressions. Schedules can start immediately, have a delayed start time, and also have a a defined end time.","title":"Schedules"},{"location":"Tutorials/Schedules/#create-a-schedule","text":"To create a new schedule in your server you use the schedule function. The make-up of the function is as follows: schedule < name > < cron ( s )> < scriptblock > [ -start < datetime >] [ -end < datetime >] [ -limit < int >] # or shorthand: schedule < name > < cron ( s )> < scriptblock > [ -s < datetime >] [ -e < datetime >] [ -l < int >] Each schedule must have a <name> , one or more <cron> expressions, and a <scriptblock> for the main logic. The <name> must be unique across all schedules. To create a basic schedule , the following example will work; this will trigger at '00:05' every Tuesday outputting the current date/time: Server { schedule 'date' '5 0 * * TUE' { Write-Host \" $( [DateTime] :: Now ) \" } } Whereas the following will create the same schedule, but will only trigger the schedule 4 times due to the -limit value supplied: Server { schedule 'date' '5 0 * * TUE' -limit 4 { Write-Host \" $( [DateTime] :: Now ) \" } } You can also supply multiple cron expressions for the same schedule . For example, the following will trigger the same schedule every minute and every hour: Server { schedule 'date' @( '@minutely' , '@hourly' ) { Write-Host \" $( [DateTime] :: Now ) \" } }","title":"Create a Schedule"},{"location":"Tutorials/Schedules/#delayed-start","text":"The -start <datetime> parameter will cause the schedule to only be triggered after the date/time defined. For example, if you have a schedule set to trigger at 00:05 every Tuesday, and you pass -start [DateTime]::Now.AddMonths(2) , then the schedule will only start trigger on Tuesdays in 2 months time. The following will create a schedule that triggers at 16:00 every Friday, and is delayed by 1 year: Server { $start = [DateTime] :: Now . AddYears ( 1 ) schedule 'date' '0 16 * * FRI' -start $start { Write-Host \" $( [DateTime] :: Now ) \" } }","title":"Delayed Start"},{"location":"Tutorials/Schedules/#defined-end","text":"The -end <datetime> parameter will cause the schedule to cease triggering after the date/time defined. For example, if you have a schedule set to trigger at 00:05 every Tuesday, and you pass -end [DateTime]::Now.AddMonths(2) , then the schedule will stop triggering in 2 months time. The following will create a schedule that triggers at 16:00 every Friday, and stops triggering in 1 year: Server { $end = [DateTime] :: Now . AddYears ( 1 ) schedule 'date' '0 16 * * FRI' -end $end { Write-Host \" $( [DateTime] :: Now ) \" } }","title":"Defined End"},{"location":"Tutorials/SharedState/","text":"Shared State Most things in Pode all run in isolated runspaces, which means you can't create a variable in a timer and then access that variable in a route. To overcome this limitation you can use the state function, which allows you to set/get variables on a state shared between all runspaces. This means you can create a variable in a timer and set it against the shared state; then you can retrieve that variable from the state in a route. To do this, you use the state function with an action of set , get or remove , in combination with the lock function to ensure thread safety Tip It's wise to use the state function in conjunction with the lock function, so as to ensure thread safety between runspaces. The argument object supplied to the route , handler , timer , schedule , middleware , endware and logger functions each contain a .Lockable resource that can be supplied to the lock function. Warning If you omit the use of lock , you will run into errors due to multi-threading. Only omit if you are absolutely confident you do not need locking. (ie: you set in state once and then only ever retrieve, never updating the variable). Actions Set The state set action will create/update a variable on the shared state. You need to supply a name and an object to set on the state. The set action will also return the object you're settting. The make-up of the set action is: state set < name > < object > An example of using the set action to create a shared hashtable variable is as follows: Server { state set 'data' @{ 'Name' = 'Rick Sanchez' } | Out-Null } As per the tip above, it's always worth wrapping state actions within a lock . The following example will set a shared variable in a timer , and lock the global Lockable object. Server { timer 'do-something' 5 { param ( $e ) lock $e . Lockable { state set 'data' @{ 'Name' = 'Rick Sanchez' } | Out-Null } } } Get The state get action will return the value currently stored on the shared state for a variable. You only need to supply the variable's name to get on the value from the state. If the variable doesn't exist then $null is returned. The make-up of the get action is: state get < name > An example of using the get action to retrieve the value from the shared state is as follows: Server { $value = ( state get 'data' ) } As per the tip above, it's always worth wrapping state actions within a lock . The following example will get a shared variable in a timer , and lock the global Lockable object. Server { timer 'do-something' 5 { param ( $e ) $value = $null lock $e . Lockable { $value = ( state get 'data' ) } # do something with $value } } Remove The state remove action will remove a variable from the shared state. You only need to supply the variable's name for it to be removed from the state. The action will also return the value stored in the state before removing the variable. The make-up of the remove action is: state remove < name > An example of using the remove action to remove a variable from the shared state is as follows: Server { state remove 'data' | Out-Null } As per the tip above, it's always worth wrapping state actions within a lock . The following example will remove a shared variable in a timer , and lock the global Lockable object. Server { timer 'do-something' 5 { param ( $e ) lock $e . Lockable { state remove 'data' | Out-Null } } } Full Example The following is a full example of using the state function. It is a simple timer that creates and updates a hashtable variable, and then a route is used to retrieve that variable. There is also another route that will remove the variable from the state: Server { listen * : 8080 http # create the shared variable state set 'hash' @{ 'values' = @(); } | Out-Null # timer to add a random number to the shared state timer 'forever' 2 { param ( $e ) # ensure we're thread safe lock $e . Lockable { # attempt to get the hashtable from the state $hash = ( state get 'hash' ) # add a random number $hash [ 'values' ] += ( Get-Random -Minimum 0 -Maximum 10 ) } } # route to return the value of the hashtable from shared state route get '/' { param ( $e ) # again, ensure we're thread safe lock $e . Lockable { # get the hashtable from the state and return it $hash = ( state get 'hash' ) json $hash } } # route to remove the hashtable from shared state route delete '/' { param ( $e ) # ensure we're thread safe lock $e . Lockable { # remove the hashtable from the state state remove 'hash' | Out-Null } } }","title":"Shared State"},{"location":"Tutorials/SharedState/#shared-state","text":"Most things in Pode all run in isolated runspaces, which means you can't create a variable in a timer and then access that variable in a route. To overcome this limitation you can use the state function, which allows you to set/get variables on a state shared between all runspaces. This means you can create a variable in a timer and set it against the shared state; then you can retrieve that variable from the state in a route. To do this, you use the state function with an action of set , get or remove , in combination with the lock function to ensure thread safety Tip It's wise to use the state function in conjunction with the lock function, so as to ensure thread safety between runspaces. The argument object supplied to the route , handler , timer , schedule , middleware , endware and logger functions each contain a .Lockable resource that can be supplied to the lock function. Warning If you omit the use of lock , you will run into errors due to multi-threading. Only omit if you are absolutely confident you do not need locking. (ie: you set in state once and then only ever retrieve, never updating the variable).","title":"Shared State"},{"location":"Tutorials/SharedState/#actions","text":"","title":"Actions"},{"location":"Tutorials/SharedState/#set","text":"The state set action will create/update a variable on the shared state. You need to supply a name and an object to set on the state. The set action will also return the object you're settting. The make-up of the set action is: state set < name > < object > An example of using the set action to create a shared hashtable variable is as follows: Server { state set 'data' @{ 'Name' = 'Rick Sanchez' } | Out-Null } As per the tip above, it's always worth wrapping state actions within a lock . The following example will set a shared variable in a timer , and lock the global Lockable object. Server { timer 'do-something' 5 { param ( $e ) lock $e . Lockable { state set 'data' @{ 'Name' = 'Rick Sanchez' } | Out-Null } } }","title":"Set"},{"location":"Tutorials/SharedState/#get","text":"The state get action will return the value currently stored on the shared state for a variable. You only need to supply the variable's name to get on the value from the state. If the variable doesn't exist then $null is returned. The make-up of the get action is: state get < name > An example of using the get action to retrieve the value from the shared state is as follows: Server { $value = ( state get 'data' ) } As per the tip above, it's always worth wrapping state actions within a lock . The following example will get a shared variable in a timer , and lock the global Lockable object. Server { timer 'do-something' 5 { param ( $e ) $value = $null lock $e . Lockable { $value = ( state get 'data' ) } # do something with $value } }","title":"Get"},{"location":"Tutorials/SharedState/#remove","text":"The state remove action will remove a variable from the shared state. You only need to supply the variable's name for it to be removed from the state. The action will also return the value stored in the state before removing the variable. The make-up of the remove action is: state remove < name > An example of using the remove action to remove a variable from the shared state is as follows: Server { state remove 'data' | Out-Null } As per the tip above, it's always worth wrapping state actions within a lock . The following example will remove a shared variable in a timer , and lock the global Lockable object. Server { timer 'do-something' 5 { param ( $e ) lock $e . Lockable { state remove 'data' | Out-Null } } }","title":"Remove"},{"location":"Tutorials/SharedState/#full-example","text":"The following is a full example of using the state function. It is a simple timer that creates and updates a hashtable variable, and then a route is used to retrieve that variable. There is also another route that will remove the variable from the state: Server { listen * : 8080 http # create the shared variable state set 'hash' @{ 'values' = @(); } | Out-Null # timer to add a random number to the shared state timer 'forever' 2 { param ( $e ) # ensure we're thread safe lock $e . Lockable { # attempt to get the hashtable from the state $hash = ( state get 'hash' ) # add a random number $hash [ 'values' ] += ( Get-Random -Minimum 0 -Maximum 10 ) } } # route to return the value of the hashtable from shared state route get '/' { param ( $e ) # again, ensure we're thread safe lock $e . Lockable { # get the hashtable from the state and return it $hash = ( state get 'hash' ) json $hash } } # route to remove the hashtable from shared state route delete '/' { param ( $e ) # ensure we're thread safe lock $e . Lockable { # remove the hashtable from the state state remove 'hash' | Out-Null } } }","title":"Full Example"},{"location":"Tutorials/SmtpServer/","text":"SMTP Server Pode has an inbuilt SMTP server which will automatically creates a TCP listener on port 25 (unless you specify a different port via the listen function). Unlike with web servers that use the route function, SMTP servers use the handler function, which lets you specify logic for handling responses from TCP streams. Just note that you can only have one handler per server . To create a handler for the inbuilt SMTP server you can use the following example: Server { listen * : 25 smtp handler smtp { param ( $email ) Write-Host $email . From Write-Host $email . To Write-Host $email . Data } } The SMTP handler will be passed the current email object, and this will have the following properties: Name Type Description From string The email address of the person sending the email To string[] The email addresses receiving the email (this is to, cc, and bcc) Subject string The subject of the email Body string The body of the email, decoded depending on content type/encoding IsUrgent boolean This will be true if the Priority/Importance of the email is High, otherwise false ContentType string The content type of the original email body ContentEncoding string The content encoding of the original email body Headers hashtable A list of all the headers received for the email Data string The full raw data of the email","title":"SMTP Server"},{"location":"Tutorials/SmtpServer/#smtp-server","text":"Pode has an inbuilt SMTP server which will automatically creates a TCP listener on port 25 (unless you specify a different port via the listen function). Unlike with web servers that use the route function, SMTP servers use the handler function, which lets you specify logic for handling responses from TCP streams. Just note that you can only have one handler per server . To create a handler for the inbuilt SMTP server you can use the following example: Server { listen * : 25 smtp handler smtp { param ( $email ) Write-Host $email . From Write-Host $email . To Write-Host $email . Data } } The SMTP handler will be passed the current email object, and this will have the following properties: Name Type Description From string The email address of the person sending the email To string[] The email addresses receiving the email (this is to, cc, and bcc) Subject string The subject of the email Body string The body of the email, decoded depending on content type/encoding IsUrgent boolean This will be true if the Priority/Importance of the email is High, otherwise false ContentType string The content type of the original email body ContentEncoding string The content encoding of the original email body Headers hashtable A list of all the headers received for the email Data string The full raw data of the email","title":"SMTP Server"},{"location":"Tutorials/Threading/","text":"Threading By default Pode deals with incoming request synchronously in a single thread. You can increase the number of threads/runspaces that Pode uses to handle requests by using the -Threads parameter on your Server : Server -Threads 2 { # logic } The number of threads supplied only applies to Web, SMTP, and TCP servers. If -Threads is not supplied, or is <=0 then the number of threads is forced to the default of 1.","title":"Threading"},{"location":"Tutorials/Threading/#threading","text":"By default Pode deals with incoming request synchronously in a single thread. You can increase the number of threads/runspaces that Pode uses to handle requests by using the -Threads parameter on your Server : Server -Threads 2 { # logic } The number of threads supplied only applies to Web, SMTP, and TCP servers. If -Threads is not supplied, or is <=0 then the number of threads is forced to the default of 1.","title":"Threading"},{"location":"Tutorials/Timers/","text":"Timers A timer in Pode is a short-running async task. All timers in Pode run in the same separate runspace along side your main server logic. Timers have unique names, and iterate on a defined number of seconds. Warning Since all timers are run within the same runspace, it is wise to keep them as short-running as possible. If you require something long-running we recommend you use Schedules instead. Create a Timer To create a new timer in your server you use the timer function. The make-up of the function is as follows: timer < name > < interval > < scriptblock > [ -skip < int >] [ -limit < int >] # or shorthand: timer < name > < interval > < scriptblock > [ -s < int >] [ -l < int >] Each timer must have a <name> , an <interval> , and a <scriptblock> for the main logic. The <interval> must be a positive number of seconds, and the <name> must be unique across all timers. To create a basic timer , the following example will work; this will loop every 5 seconds outputting the date/time: Server { timer 'date' 5 { Write-Host \" $( [DateTime] :: Now ) \" } } Delayed Start The -skip <int> parameter will cause the timer to skip its first initial triggers. For example, if you have a timer run every 10 seconds, and you pass -skip 5 , then the timer will first run after 50 seconds (10secs * skip 5). The following will create a timer that runs every 10 seconds, and skips the first 5 iterations: Server { timer 'date' 10 -skip 5 { Write-Host \" $( [DateTime] :: Now ) \" } } Note When a timer is created, the logic will run once and then be placed onto the separate runspace. To avoid the timer running the first time on the main runspace you can pass -skip 1 . Run X Times Normally a timer will run forever, or at least until you terminate the server. Sometimes you might want a timer to end early, or only run once. To do this you use the -limit <int> parameter, which defines the number of times the timer should execute. The following will run every 20 seconds, and will only run 3 times: Server { timer 'date' 20 -limit 3 { Write-Host \" $( [DateTime] :: Now ) \" } }","title":"Timers"},{"location":"Tutorials/Timers/#timers","text":"A timer in Pode is a short-running async task. All timers in Pode run in the same separate runspace along side your main server logic. Timers have unique names, and iterate on a defined number of seconds. Warning Since all timers are run within the same runspace, it is wise to keep them as short-running as possible. If you require something long-running we recommend you use Schedules instead.","title":"Timers"},{"location":"Tutorials/Timers/#create-a-timer","text":"To create a new timer in your server you use the timer function. The make-up of the function is as follows: timer < name > < interval > < scriptblock > [ -skip < int >] [ -limit < int >] # or shorthand: timer < name > < interval > < scriptblock > [ -s < int >] [ -l < int >] Each timer must have a <name> , an <interval> , and a <scriptblock> for the main logic. The <interval> must be a positive number of seconds, and the <name> must be unique across all timers. To create a basic timer , the following example will work; this will loop every 5 seconds outputting the date/time: Server { timer 'date' 5 { Write-Host \" $( [DateTime] :: Now ) \" } }","title":"Create a Timer"},{"location":"Tutorials/Timers/#delayed-start","text":"The -skip <int> parameter will cause the timer to skip its first initial triggers. For example, if you have a timer run every 10 seconds, and you pass -skip 5 , then the timer will first run after 50 seconds (10secs * skip 5). The following will create a timer that runs every 10 seconds, and skips the first 5 iterations: Server { timer 'date' 10 -skip 5 { Write-Host \" $( [DateTime] :: Now ) \" } } Note When a timer is created, the logic will run once and then be placed onto the separate runspace. To avoid the timer running the first time on the main runspace you can pass -skip 1 .","title":"Delayed Start"},{"location":"Tutorials/Timers/#run-x-times","text":"Normally a timer will run forever, or at least until you terminate the server. Sometimes you might want a timer to end early, or only run once. To do this you use the -limit <int> parameter, which defines the number of times the timer should execute. The following will run every 20 seconds, and will only run 3 times: Server { timer 'date' 20 -limit 3 { Write-Host \" $( [DateTime] :: Now ) \" } }","title":"Run X Times"},{"location":"Tutorials/Authentication/Basic/","text":"Basic Authentication Basic authentication is when you pass an encoded username:password value on the header of your requests: @{ 'Authorization' = 'Basic <base64 encoded username:password>' } . Setup To setup and start using Basic authentication in Pode you can call auth use <name> -t basic in your server script, the validator script you need to supply will have the username/password passed as arguments to the scriptblock: Server { auth use login -t basic -v { param ( $username , $password ) # check if the user is valid return @{ 'user' = $user } } } By default, Pode will check if the request's header contains an Authorization key, and whether the value of that key starts with Basic . The auth use action can be supplied options via -o to override the start name of the value, as well as the encoding that Pode uses. For example, to use ASCII encoding rather than the default ISO-8859-1 you could do: Server { auth use login -t basic -v { # check } -o @{ 'Encoding' = 'ASCII' } } More options can be seen further below. Validating Once configured you can start using Basic authentication to validate incoming requests. You can either configure the validation to happen on every route as global middleware , or as custom route middleware. The following will use Basic authentication to validate every request on every route : Server { middleware ( auth check login ) } Whereas the following example will use Basic authentication to only validate requests on specific a route : Server { route get '/info' ( auth check login ) { # logic } } Full Example The following full example of Basic authentication will setup and configure authentication, validate that a users username/password is valid, and then validate on a specific route : Server { listen * : 8080 http # setup basic authentication to validate a user auth use login -t basic -v { param ( $username , $password ) # here you'd check a real user storage, this is just for example if ( $username -eq 'morty' -and $password -eq 'pickle' ) { return @{ 'user' = @{ 'ID' = 'M0R7Y302' 'Name' = 'Morty' ; 'Type' = 'Human' ; } } } return $null } # check the request on this route against the authentication route get '/cpu' ( auth check login ) { json @{ 'cpu' = 82 } } # this route will not be validated against the authentication route get '/memory' { json @{ 'memory' = 14 } } } Use Options Name Description Default Encoding Defines which encoding to use when decoding the Authorization header ISO-8859-1 Name Defines the name part of the header, in front of the encoded sting, such as the Basic part of Basic <username:password> Basic","title":"Basic"},{"location":"Tutorials/Authentication/Basic/#basic-authentication","text":"Basic authentication is when you pass an encoded username:password value on the header of your requests: @{ 'Authorization' = 'Basic <base64 encoded username:password>' } .","title":"Basic Authentication"},{"location":"Tutorials/Authentication/Basic/#setup","text":"To setup and start using Basic authentication in Pode you can call auth use <name> -t basic in your server script, the validator script you need to supply will have the username/password passed as arguments to the scriptblock: Server { auth use login -t basic -v { param ( $username , $password ) # check if the user is valid return @{ 'user' = $user } } } By default, Pode will check if the request's header contains an Authorization key, and whether the value of that key starts with Basic . The auth use action can be supplied options via -o to override the start name of the value, as well as the encoding that Pode uses. For example, to use ASCII encoding rather than the default ISO-8859-1 you could do: Server { auth use login -t basic -v { # check } -o @{ 'Encoding' = 'ASCII' } } More options can be seen further below.","title":"Setup"},{"location":"Tutorials/Authentication/Basic/#validating","text":"Once configured you can start using Basic authentication to validate incoming requests. You can either configure the validation to happen on every route as global middleware , or as custom route middleware. The following will use Basic authentication to validate every request on every route : Server { middleware ( auth check login ) } Whereas the following example will use Basic authentication to only validate requests on specific a route : Server { route get '/info' ( auth check login ) { # logic } }","title":"Validating"},{"location":"Tutorials/Authentication/Basic/#full-example","text":"The following full example of Basic authentication will setup and configure authentication, validate that a users username/password is valid, and then validate on a specific route : Server { listen * : 8080 http # setup basic authentication to validate a user auth use login -t basic -v { param ( $username , $password ) # here you'd check a real user storage, this is just for example if ( $username -eq 'morty' -and $password -eq 'pickle' ) { return @{ 'user' = @{ 'ID' = 'M0R7Y302' 'Name' = 'Morty' ; 'Type' = 'Human' ; } } } return $null } # check the request on this route against the authentication route get '/cpu' ( auth check login ) { json @{ 'cpu' = 82 } } # this route will not be validated against the authentication route get '/memory' { json @{ 'memory' = 14 } } }","title":"Full Example"},{"location":"Tutorials/Authentication/Basic/#use-options","text":"Name Description Default Encoding Defines which encoding to use when decoding the Authorization header ISO-8859-1 Name Defines the name part of the header, in front of the encoded sting, such as the Basic part of Basic <username:password> Basic","title":"Use Options"},{"location":"Tutorials/Authentication/Custom/","text":"Custom Authentication Custom authentication works much like the inbuilt types, but allows you to specify your own parsing logic, as well as any custom options that might be required. Setup and Parsing To setup and start using Custom authentication in Pode you can set auth use -c <name> in you server script. The <name> can be anything you want, even the name of an inbuilt method (it will still use your custom logic!). Let's say we wanted something similar to Form authentication but it requires a third piece of information: ClientName . To setup Custom authentication for this method, you'll need to specify the parsing scriptblock under -p , as well as the validator script too. The parsing script will be passed the current web event (containing the Request / Response objects, much like a route ). In this script you can parse the request payload/headers for any credential information that needs validating. Once sourced, the data returned from the script should be either a hashtable or an array ; this data will then splatted onto the validator scriptblock ( info ): Server { # here we're calling the custom method \"client\" auth use -c client -p { # the current web event, and auth method options supplied param ( $event , $opts ) # get client/user/pass field names to get from payload $clientField = ( coalesce $opts . ClientField 'client' ) $userField = ( coalesce $opts . UsernameField 'username' ) $passField = ( coalesce $opts . PasswordField 'password' ) # get the client/user/pass from the post data $client = $event . Data . $clientField $username = $event . Data . $userField $password = $event . Data . $passField # return the data, to be passed to the validator script return @( $client , $username , $password ) } ` -v { param ( $client , $username , $password ) # check if the client is valid return @{ 'user' = $user } } } Validating Once configured you can start using the Custom authentication to validate incoming requests. You can either configure the validation to happen on every route as global middleware , or as custom route middleware. The following will use Custom authentication to validate every request on every route : Server { middleware ( auth check client ) } Whereas the following example will use Custom authentication to only validate requests on specific a route : Server { route get '/info' ( auth check client ) { # logic } } Full Example The following full example of Custom authentication will setup and configure authentication, validate that a users client/username/password is valid, and then validate on a specific route : Server { listen * : 8080 http # here we're calling the custom method \"client\" auth use -c client -p { # the current web event, and auth method options supplied param ( $event , $opts ) # get client/user/pass field names to get from payload $clientField = ( coalesce $opts . ClientField 'client' ) $userField = ( coalesce $opts . UsernameField 'username' ) $passField = ( coalesce $opts . PasswordField 'password' ) # get the client/user/pass from the post data $client = $event . Data . $clientField $username = $event . Data . $userField $password = $event . Data . $passField # return the data, to be passed to the validator script return @( $client , $username , $password ) } ` -v { param ( $client , $username , $password ) # check if the client is valid return @{ 'user' = $user } } # check the request on this route against the authentication route get '/cpu' ( auth check client ) { json @{ 'cpu' = 82 } } # this route will not be validated against the authentication route get '/memory' { json @{ 'memory' = 14 } } } Below is an example HTML page that would POST the client/username/password to the server above: < form action = \"/login\" method = \"post\" > < div > < label > Client: </ label > < input type = \"text\" name = \"client\" /> </ div > < div > < label > Username: </ label > < input type = \"text\" name = \"username\" /> </ div > < div > < label > Password: </ label > < input type = \"password\" name = \"password\" /> </ div > < div > < input type = \"submit\" value = \"Login\" /> </ div > </ form > Use Options Info There are no use options for custom types, unless you define your own.","title":"Custom"},{"location":"Tutorials/Authentication/Custom/#custom-authentication","text":"Custom authentication works much like the inbuilt types, but allows you to specify your own parsing logic, as well as any custom options that might be required.","title":"Custom Authentication"},{"location":"Tutorials/Authentication/Custom/#setup-and-parsing","text":"To setup and start using Custom authentication in Pode you can set auth use -c <name> in you server script. The <name> can be anything you want, even the name of an inbuilt method (it will still use your custom logic!). Let's say we wanted something similar to Form authentication but it requires a third piece of information: ClientName . To setup Custom authentication for this method, you'll need to specify the parsing scriptblock under -p , as well as the validator script too. The parsing script will be passed the current web event (containing the Request / Response objects, much like a route ). In this script you can parse the request payload/headers for any credential information that needs validating. Once sourced, the data returned from the script should be either a hashtable or an array ; this data will then splatted onto the validator scriptblock ( info ): Server { # here we're calling the custom method \"client\" auth use -c client -p { # the current web event, and auth method options supplied param ( $event , $opts ) # get client/user/pass field names to get from payload $clientField = ( coalesce $opts . ClientField 'client' ) $userField = ( coalesce $opts . UsernameField 'username' ) $passField = ( coalesce $opts . PasswordField 'password' ) # get the client/user/pass from the post data $client = $event . Data . $clientField $username = $event . Data . $userField $password = $event . Data . $passField # return the data, to be passed to the validator script return @( $client , $username , $password ) } ` -v { param ( $client , $username , $password ) # check if the client is valid return @{ 'user' = $user } } }","title":"Setup and Parsing"},{"location":"Tutorials/Authentication/Custom/#validating","text":"Once configured you can start using the Custom authentication to validate incoming requests. You can either configure the validation to happen on every route as global middleware , or as custom route middleware. The following will use Custom authentication to validate every request on every route : Server { middleware ( auth check client ) } Whereas the following example will use Custom authentication to only validate requests on specific a route : Server { route get '/info' ( auth check client ) { # logic } }","title":"Validating"},{"location":"Tutorials/Authentication/Custom/#full-example","text":"The following full example of Custom authentication will setup and configure authentication, validate that a users client/username/password is valid, and then validate on a specific route : Server { listen * : 8080 http # here we're calling the custom method \"client\" auth use -c client -p { # the current web event, and auth method options supplied param ( $event , $opts ) # get client/user/pass field names to get from payload $clientField = ( coalesce $opts . ClientField 'client' ) $userField = ( coalesce $opts . UsernameField 'username' ) $passField = ( coalesce $opts . PasswordField 'password' ) # get the client/user/pass from the post data $client = $event . Data . $clientField $username = $event . Data . $userField $password = $event . Data . $passField # return the data, to be passed to the validator script return @( $client , $username , $password ) } ` -v { param ( $client , $username , $password ) # check if the client is valid return @{ 'user' = $user } } # check the request on this route against the authentication route get '/cpu' ( auth check client ) { json @{ 'cpu' = 82 } } # this route will not be validated against the authentication route get '/memory' { json @{ 'memory' = 14 } } } Below is an example HTML page that would POST the client/username/password to the server above: < form action = \"/login\" method = \"post\" > < div > < label > Client: </ label > < input type = \"text\" name = \"client\" /> </ div > < div > < label > Username: </ label > < input type = \"text\" name = \"username\" /> </ div > < div > < label > Password: </ label > < input type = \"password\" name = \"password\" /> </ div > < div > < input type = \"submit\" value = \"Login\" /> </ div > </ form >","title":"Full Example"},{"location":"Tutorials/Authentication/Custom/#use-options","text":"Info There are no use options for custom types, unless you define your own.","title":"Use Options"},{"location":"Tutorials/Authentication/Form/","text":"Form Authentication Form authentication is for when you're using a <form> in HTML, and you submit the form. The method expects a username and password to be passed from the form input fields. Setup To setup and start using Form authentication in Pode you specify auth use <name> -t form in your server script, the validator script you need to supply will have the username/password supplied as arguments to the scriptblock: Server { auth use login -t form -v { param ( $username , $password ) # check if the user is valid return @{ 'user' = $user } } } By default, Pode will check if the request's payload (from POST) contains a username and password field. The auth use action can be supplied options via -o to override the names of these fields for anything custom. For example, to look for the field email rather than rather than the default username you could do: Server { auth use login -t form -v { # check } -o @{ 'UsernameField' = 'email' } } More options can be seen further below. Validating Once configured you can start using Form authentication to validate incoming requests. You can either configure the validation to happen on every route as global middleware , or as custom route middleware. The following will use Form authentication to validate every request on every route : Server { middleware ( auth check login ) } Whereas the following example will use Form authentication to only validate requests on specific a route : Server { route get '/info' ( auth check login ) { # logic } } Full Example The following full example of Form authentication will setup and configure authentication, validate that a users username/password is valid, and then validate on a specific route : Server { listen * : 8080 http # setup form authentication to validate a user auth use login -t form -v { param ( $username , $password ) # here you'd check a real user storage, this is just for example if ( $username -eq 'morty' -and $password -eq 'pickle' ) { return @{ 'user' = @{ 'ID' = 'M0R7Y302' 'Name' = 'Morty' ; 'Type' = 'Human' ; } } } return $null } # check the request on this route against the authentication route get '/cpu' ( auth check login ) { json @{ 'cpu' = 82 } } # this route will not be validated against the authentication route get '/memory' { json @{ 'memory' = 14 } } } Below is an example HTML page that would POST the username/password to the server above: < form action = \"/login\" method = \"post\" > < div > < label > Username: </ label > < input type = \"text\" name = \"username\" /> </ div > < div > < label > Password: </ label > < input type = \"password\" name = \"password\" /> </ div > < div > < input type = \"submit\" value = \"Login\" /> </ div > </ form > Use Options Name Description Default UsernameField Defines the name of field which the username will be passed in from the <form> username PasswordField Defines the name of field which the password will be passed in from the <form> password","title":"Form"},{"location":"Tutorials/Authentication/Form/#form-authentication","text":"Form authentication is for when you're using a <form> in HTML, and you submit the form. The method expects a username and password to be passed from the form input fields.","title":"Form Authentication"},{"location":"Tutorials/Authentication/Form/#setup","text":"To setup and start using Form authentication in Pode you specify auth use <name> -t form in your server script, the validator script you need to supply will have the username/password supplied as arguments to the scriptblock: Server { auth use login -t form -v { param ( $username , $password ) # check if the user is valid return @{ 'user' = $user } } } By default, Pode will check if the request's payload (from POST) contains a username and password field. The auth use action can be supplied options via -o to override the names of these fields for anything custom. For example, to look for the field email rather than rather than the default username you could do: Server { auth use login -t form -v { # check } -o @{ 'UsernameField' = 'email' } } More options can be seen further below.","title":"Setup"},{"location":"Tutorials/Authentication/Form/#validating","text":"Once configured you can start using Form authentication to validate incoming requests. You can either configure the validation to happen on every route as global middleware , or as custom route middleware. The following will use Form authentication to validate every request on every route : Server { middleware ( auth check login ) } Whereas the following example will use Form authentication to only validate requests on specific a route : Server { route get '/info' ( auth check login ) { # logic } }","title":"Validating"},{"location":"Tutorials/Authentication/Form/#full-example","text":"The following full example of Form authentication will setup and configure authentication, validate that a users username/password is valid, and then validate on a specific route : Server { listen * : 8080 http # setup form authentication to validate a user auth use login -t form -v { param ( $username , $password ) # here you'd check a real user storage, this is just for example if ( $username -eq 'morty' -and $password -eq 'pickle' ) { return @{ 'user' = @{ 'ID' = 'M0R7Y302' 'Name' = 'Morty' ; 'Type' = 'Human' ; } } } return $null } # check the request on this route against the authentication route get '/cpu' ( auth check login ) { json @{ 'cpu' = 82 } } # this route will not be validated against the authentication route get '/memory' { json @{ 'memory' = 14 } } } Below is an example HTML page that would POST the username/password to the server above: < form action = \"/login\" method = \"post\" > < div > < label > Username: </ label > < input type = \"text\" name = \"username\" /> </ div > < div > < label > Password: </ label > < input type = \"password\" name = \"password\" /> </ div > < div > < input type = \"submit\" value = \"Login\" /> </ div > </ form >","title":"Full Example"},{"location":"Tutorials/Authentication/Form/#use-options","text":"Name Description Default UsernameField Defines the name of field which the username will be passed in from the <form> username PasswordField Defines the name of field which the password will be passed in from the <form> password","title":"Use Options"},{"location":"Tutorials/Authentication/Overview/","text":"Authentication Overview Authentication can either be sessionless (requiring validation on every request), or session-persistent (only requiring validation once, and then checks against a session signed-cookie). Info To use session-persistent authentication you will also need to use the session middleware. To setup and use authentication in Pode you need to use the auth function and middleware. The auth function has two actions: use and check which are detailed below: Actions Use The auth use action allows you to specify and configure which authentication methods your server will use; you can have many methods configured, defining which one to validate against on the auth check action. The make-up of the use action is: auth use < name > -validator <{}| string > [ -options @{}] [ -parser {}] [ -type < string >] [ -custom ] # or shorthand: auth use < name > -v <{}| string > [ -o @{}] [ -p {}] [ -t < string >] [ -c ] A quick example of using the use action for Basic authentication is as follows: Server { auth use basic -v { param ( $username , $pass ) # logic to check user return @{ 'user' = $user } } } or, if you want to use Basic authentication but with a custom name (such as 'login'): Server { auth use login -t basic -v { param ( $username , $pass ) # logic to check user return @{ 'user' = $user } } } The <name> of the authentication method can be anything, so long as you specify the <type> as well. The <type> specified should be a valid inbuilt method (such as Basic or Form), unless you have stated that the method is custom ( -c ). If you do not specify a <type> then the <name> is used as the type instead - in which case the name needs to follow the same rules as <type> . The validator ( -v ) script is used to validate a user, checking if they exist and the password is correct (or checking if they exist in some data store). If the validator passes, then a user needs to be returned from the script via @{ 'user' = $user } - if $null or a null user is returned then the validator script is assumed to have failed, thus meaning the user will have failed to authenticate. Some authentication methods also have options ( -o ) that can be supplied as a hashtable, such as field name or encoding overrides. Available options will vary between authentication methods, and can be seen on their tutorial pages, such as Basic . If a custom ( -c ) authentication method is used, you must supply a parser ( -p ) script which can parse payloads/headers for credentials and then return this data as an array - which will then be supplied to the validator ( -v ) script. Check The auth check action allows you to define which authentication method to validate a request against. The action returns a valid middleware script, meaning you can either use this action on specific route definitions, or globally for all routes as middleware . If this action fails, then a 401 response is returned. The make-up of the check action is: auth check < name > [ -options @{}] # or shorthand: auth check < name > [ -o @{}] A quick example of using the check action against Basic authentication is as follows. The first example sets up the check as global middleware, whereas the second example sets up the check as custom route middleware: Server { # 1. apply the auth check as global middleware middleware ( auth check basic ) # 2. or, apply auth check as custom route middleware route get '/users' ( auth check basic ) { # route logic } } On success, this action will then allow the route logic to be invoked. If session middleware has been configured then an authenticated session is also created for future requests, using a signed session-cookie. When the user makes another call using the same authenticated session and that cookie is passed, then the auth check action will detect the already authenticated session and skip the validator script. If you're using sessions and you don't want the auth check to check the session, or store the user against the session, then pass -o @{ 'Session' = $false } to the auth check call. Parameters The following table contains options that you can supply to an auth check -o @{} call - these are all optional: Name Description Default FailureUrl The URL to redirect to should authentication fail empty FailureMessage Overrides any error message thrown during authentication validation empty FailureFlash If true, any error message thrown will be loaded into the session's flash messages under the auth-error key false SuccessUrl The URL to redirect to should authentication succeed empty Session If true, check if the session already has an authenticated user; storing the user in the session if they are authenticated true Login If true, check the authentication status in the session and redirect to the SuccessUrl if the user is authenticated. Otherwise proceed to the page with no authentication required false Logout If true, purge the session and redirect to the FailureUrl false Info The Login option allows you to have authentication on your login pages, such that if there is no user in a current session then the login page displays - rather then being 401'd. Whereas if there is an authenticated user in the session it will auto-redirect to the SuccessUrl . Users After a successful validation, an Auth object will be created for use against the Request. This Auth object will be accessible via the argument supplied to routes adn middleware (though it will only be available in middleware created after auth check ). The object will further contain: Name Description User Details about the authenticated user IsAuthenticated States if the request is for an authenticated user, can be $true , $false or $null Store States whether the authentication is for a session, and will be stored as a cookie The following example get the user's name from the Auth object: route get '/' ( auth check form ) { param ( $e ) view 'index' -data @{ 'Username' = $e . Auth . User . Name ; } } Inbuilt Validators Overtime Pode will start to support some inbuilt validators for authentication - such as Windows Active Directory. More information can be found on the validators page, but to use an inbuilt script you just need to specify the name. For example, the below would use the inbuilt validator script for Windows AD: Server { auth use basic -v 'windows-ad' }","title":"Overview"},{"location":"Tutorials/Authentication/Overview/#authentication-overview","text":"Authentication can either be sessionless (requiring validation on every request), or session-persistent (only requiring validation once, and then checks against a session signed-cookie). Info To use session-persistent authentication you will also need to use the session middleware. To setup and use authentication in Pode you need to use the auth function and middleware. The auth function has two actions: use and check which are detailed below:","title":"Authentication Overview"},{"location":"Tutorials/Authentication/Overview/#actions","text":"","title":"Actions"},{"location":"Tutorials/Authentication/Overview/#use","text":"The auth use action allows you to specify and configure which authentication methods your server will use; you can have many methods configured, defining which one to validate against on the auth check action. The make-up of the use action is: auth use < name > -validator <{}| string > [ -options @{}] [ -parser {}] [ -type < string >] [ -custom ] # or shorthand: auth use < name > -v <{}| string > [ -o @{}] [ -p {}] [ -t < string >] [ -c ] A quick example of using the use action for Basic authentication is as follows: Server { auth use basic -v { param ( $username , $pass ) # logic to check user return @{ 'user' = $user } } } or, if you want to use Basic authentication but with a custom name (such as 'login'): Server { auth use login -t basic -v { param ( $username , $pass ) # logic to check user return @{ 'user' = $user } } } The <name> of the authentication method can be anything, so long as you specify the <type> as well. The <type> specified should be a valid inbuilt method (such as Basic or Form), unless you have stated that the method is custom ( -c ). If you do not specify a <type> then the <name> is used as the type instead - in which case the name needs to follow the same rules as <type> . The validator ( -v ) script is used to validate a user, checking if they exist and the password is correct (or checking if they exist in some data store). If the validator passes, then a user needs to be returned from the script via @{ 'user' = $user } - if $null or a null user is returned then the validator script is assumed to have failed, thus meaning the user will have failed to authenticate. Some authentication methods also have options ( -o ) that can be supplied as a hashtable, such as field name or encoding overrides. Available options will vary between authentication methods, and can be seen on their tutorial pages, such as Basic . If a custom ( -c ) authentication method is used, you must supply a parser ( -p ) script which can parse payloads/headers for credentials and then return this data as an array - which will then be supplied to the validator ( -v ) script.","title":"Use"},{"location":"Tutorials/Authentication/Overview/#check","text":"The auth check action allows you to define which authentication method to validate a request against. The action returns a valid middleware script, meaning you can either use this action on specific route definitions, or globally for all routes as middleware . If this action fails, then a 401 response is returned. The make-up of the check action is: auth check < name > [ -options @{}] # or shorthand: auth check < name > [ -o @{}] A quick example of using the check action against Basic authentication is as follows. The first example sets up the check as global middleware, whereas the second example sets up the check as custom route middleware: Server { # 1. apply the auth check as global middleware middleware ( auth check basic ) # 2. or, apply auth check as custom route middleware route get '/users' ( auth check basic ) { # route logic } } On success, this action will then allow the route logic to be invoked. If session middleware has been configured then an authenticated session is also created for future requests, using a signed session-cookie. When the user makes another call using the same authenticated session and that cookie is passed, then the auth check action will detect the already authenticated session and skip the validator script. If you're using sessions and you don't want the auth check to check the session, or store the user against the session, then pass -o @{ 'Session' = $false } to the auth check call.","title":"Check"},{"location":"Tutorials/Authentication/Overview/#parameters","text":"The following table contains options that you can supply to an auth check -o @{} call - these are all optional: Name Description Default FailureUrl The URL to redirect to should authentication fail empty FailureMessage Overrides any error message thrown during authentication validation empty FailureFlash If true, any error message thrown will be loaded into the session's flash messages under the auth-error key false SuccessUrl The URL to redirect to should authentication succeed empty Session If true, check if the session already has an authenticated user; storing the user in the session if they are authenticated true Login If true, check the authentication status in the session and redirect to the SuccessUrl if the user is authenticated. Otherwise proceed to the page with no authentication required false Logout If true, purge the session and redirect to the FailureUrl false Info The Login option allows you to have authentication on your login pages, such that if there is no user in a current session then the login page displays - rather then being 401'd. Whereas if there is an authenticated user in the session it will auto-redirect to the SuccessUrl .","title":"Parameters"},{"location":"Tutorials/Authentication/Overview/#users","text":"After a successful validation, an Auth object will be created for use against the Request. This Auth object will be accessible via the argument supplied to routes adn middleware (though it will only be available in middleware created after auth check ). The object will further contain: Name Description User Details about the authenticated user IsAuthenticated States if the request is for an authenticated user, can be $true , $false or $null Store States whether the authentication is for a session, and will be stored as a cookie The following example get the user's name from the Auth object: route get '/' ( auth check form ) { param ( $e ) view 'index' -data @{ 'Username' = $e . Auth . User . Name ; } }","title":"Users"},{"location":"Tutorials/Authentication/Overview/#inbuilt-validators","text":"Overtime Pode will start to support some inbuilt validators for authentication - such as Windows Active Directory. More information can be found on the validators page, but to use an inbuilt script you just need to specify the name. For example, the below would use the inbuilt validator script for Windows AD: Server { auth use basic -v 'windows-ad' }","title":"Inbuilt Validators"},{"location":"Tutorials/Authentication/Validators/","text":"Inbuilt Validators To make authentication easier, Pode will start to support inbuilt validators. This will allow you to specify the name of a validator on the auth use function, rather than defining a scriptblock. Using one of the below validators is simple, just pass its name to auth use . For example, the below would define a login method using Basic authentication for Windows AD: Server { auth use login -t basic -v 'windows-ad' } Windows AD Name: windows-ad Support: Windows (PowerShell, and PS Core v6.1+ only) Note: Example of Windows AD on Linux below This will validate a user's credentials, supplied via a web-form against the default DNS domain: Server { auth use login -t form -v 'windows-ad' } This will also validate a user's credentials, but with the domain to use specified: Server { auth use login -t form -v 'windows-ad' -o @{ 'fqdn' = 'test.example.com' } } The User object returned, accessible on routes , will contain the Username and FQDN. The inbuilt support is only for Windows, but you can use libraries such as Novell.Directory.Ldap.NETStandard with dotnet core on *nix environments: Server { auth use login -t form -v { param ( $username , $password ) Add-Type -Path '<path-to-dll>' try { $ldap = New-Object Novell . Directory . Ldap . LdapConnection $ldap . Connect ( 'ad-server-name' , 389 ) $ldap . Bind ( \"<domain>\\$username\" , $password ) } catch { return $null } finally { $ldap . Dispose () } return @{ 'user' = @{ 'username' = \"<domain>\\$username\" } } } }","title":"Validators"},{"location":"Tutorials/Authentication/Validators/#inbuilt-validators","text":"To make authentication easier, Pode will start to support inbuilt validators. This will allow you to specify the name of a validator on the auth use function, rather than defining a scriptblock. Using one of the below validators is simple, just pass its name to auth use . For example, the below would define a login method using Basic authentication for Windows AD: Server { auth use login -t basic -v 'windows-ad' }","title":"Inbuilt Validators"},{"location":"Tutorials/Authentication/Validators/#windows-ad","text":"Name: windows-ad Support: Windows (PowerShell, and PS Core v6.1+ only) Note: Example of Windows AD on Linux below This will validate a user's credentials, supplied via a web-form against the default DNS domain: Server { auth use login -t form -v 'windows-ad' } This will also validate a user's credentials, but with the domain to use specified: Server { auth use login -t form -v 'windows-ad' -o @{ 'fqdn' = 'test.example.com' } } The User object returned, accessible on routes , will contain the Username and FQDN. The inbuilt support is only for Windows, but you can use libraries such as Novell.Directory.Ldap.NETStandard with dotnet core on *nix environments: Server { auth use login -t form -v { param ( $username , $password ) Add-Type -Path '<path-to-dll>' try { $ldap = New-Object Novell . Directory . Ldap . LdapConnection $ldap . Connect ( 'ad-server-name' , 389 ) $ldap . Bind ( \"<domain>\\$username\" , $password ) } catch { return $null } finally { $ldap . Dispose () } return @{ 'user' = @{ 'username' = \"<domain>\\$username\" } } } }","title":"Windows AD"},{"location":"Tutorials/Logging/Custom/","text":"Custom Logging Sometimes you don't want to log to a file, or the terminal; instead you want to log to something better, like LogStash, Splunk, or any other central logging platform. Although Pode doesn't have these inbuilt (yet!) it is possible to create a custom logger , where you define a scriptblock with logic to send logs to these platforms. Setup To create a custom logger you need to supply a scriptblock to the logger function, as well as the -Custom ( -c ) flag. The following example will output the web request method/resource to the terminal; the scriptblock will be supplied a single argument that has a log object which contains details of the request/response: Server { listen * : 8080 http logger -c terminal { param ( $event ) $method = $event . Log . Request . Method $resource = $event . Log . Request . Resource \"[ $( $method ) ] $( $resource ) \" | Out-Default } } The object supplied to the scriptblock will have a .Log object, which will look something similar to the below hashtable: @{ 'Host' = '10.10.0.3' ; 'RfcUserIdentity' = '-' ; 'User' = '-' ; 'Date' = '14/Jun/2018:20:23:52 +01:00' ; 'Request' = @{ 'Method' = 'GET' ; 'Resource' = '/api/users' ; 'Protocol' = \"HTTP/1.1\" ; 'Referrer' = '-' ; 'Agent' = '<user-agent>' ; }; 'Response' = @{ 'StatusCode' = '200' ; 'StautsDescription' = 'OK' 'Size' = '9001' ; }; }","title":"Custom"},{"location":"Tutorials/Logging/Custom/#custom-logging","text":"Sometimes you don't want to log to a file, or the terminal; instead you want to log to something better, like LogStash, Splunk, or any other central logging platform. Although Pode doesn't have these inbuilt (yet!) it is possible to create a custom logger , where you define a scriptblock with logic to send logs to these platforms.","title":"Custom Logging"},{"location":"Tutorials/Logging/Custom/#setup","text":"To create a custom logger you need to supply a scriptblock to the logger function, as well as the -Custom ( -c ) flag. The following example will output the web request method/resource to the terminal; the scriptblock will be supplied a single argument that has a log object which contains details of the request/response: Server { listen * : 8080 http logger -c terminal { param ( $event ) $method = $event . Log . Request . Method $resource = $event . Log . Request . Resource \"[ $( $method ) ] $( $resource ) \" | Out-Default } } The object supplied to the scriptblock will have a .Log object, which will look something similar to the below hashtable: @{ 'Host' = '10.10.0.3' ; 'RfcUserIdentity' = '-' ; 'User' = '-' ; 'Date' = '14/Jun/2018:20:23:52 +01:00' ; 'Request' = @{ 'Method' = 'GET' ; 'Resource' = '/api/users' ; 'Protocol' = \"HTTP/1.1\" ; 'Referrer' = '-' ; 'Agent' = '<user-agent>' ; }; 'Response' = @{ 'StatusCode' = '200' ; 'StautsDescription' = 'OK' 'Size' = '9001' ; }; }","title":"Setup"},{"location":"Tutorials/Logging/File/","text":"Logging to File Setup To start logging requests to your server into a file, you can do the following: Server { listen * : 8080 http logger file } This will cause Pode to create a new /logs directory at the root of your server, and start logging requests in file split down by day - so if you log for 7 days, you'll get 7 files. When logging to a file, you can configure where Pode stores your logs and for how long to keep them using a hashtable. The following example will log to D:\\ and only keep logs for 3 days: Server { listen * : 8080 http logger file @{ 'Path' = 'D:\\Logs' ; 'MaxDays' = 3 ; } } Note Pode will automatically clear down logs for you if you specify a maximum number of days to keep them, otherwise they'll be kept forever. Options Name Description Default Path A relative or absolute path to a directory that your logs should be placed ./logs MaxDays The maximum number of days to keep logs forever","title":"File"},{"location":"Tutorials/Logging/File/#logging-to-file","text":"","title":"Logging to File"},{"location":"Tutorials/Logging/File/#setup","text":"To start logging requests to your server into a file, you can do the following: Server { listen * : 8080 http logger file } This will cause Pode to create a new /logs directory at the root of your server, and start logging requests in file split down by day - so if you log for 7 days, you'll get 7 files. When logging to a file, you can configure where Pode stores your logs and for how long to keep them using a hashtable. The following example will log to D:\\ and only keep logs for 3 days: Server { listen * : 8080 http logger file @{ 'Path' = 'D:\\Logs' ; 'MaxDays' = 3 ; } } Note Pode will automatically clear down logs for you if you specify a maximum number of days to keep them, otherwise they'll be kept forever.","title":"Setup"},{"location":"Tutorials/Logging/File/#options","text":"Name Description Default Path A relative or absolute path to a directory that your logs should be placed ./logs MaxDays The maximum number of days to keep logs forever","title":"Options"},{"location":"Tutorials/Logging/Overview/","text":"Logging Overview Logging in Pode allows you to log web events onto the terminal , into a file , or into some custom logging platform (such as LogStash or Splunk). To start logging requests to your server you use the logger function. Tip You can have many loggers defined, so you could log to the terminal, a file, and other custom tools - you aren't restricted to just one logger! When logging to the terminal, or a file, Pode will write logs using Combined Log Format . For custom loggers Pode will pass to your scriptblock a single argument that contains the relevant request information; this log object will look like the following: @{ 'Host' = '10.10.0.3' ; 'RfcUserIdentity' = '-' ; 'User' = '-' ; 'Date' = '14/Jun/2018:20:23:52 +01:00' ; 'Request' = @{ 'Method' = 'GET' ; 'Resource' = '/api/users' ; 'Protocol' = \"HTTP/1.1\" ; 'Referrer' = '-' ; 'Agent' = '<user-agent>' ; }; 'Response' = @{ 'StatusCode' = '200' ; 'StautsDescription' = 'OK' 'Size' = '9001' ; }; }","title":"Overview"},{"location":"Tutorials/Logging/Overview/#logging-overview","text":"Logging in Pode allows you to log web events onto the terminal , into a file , or into some custom logging platform (such as LogStash or Splunk). To start logging requests to your server you use the logger function. Tip You can have many loggers defined, so you could log to the terminal, a file, and other custom tools - you aren't restricted to just one logger! When logging to the terminal, or a file, Pode will write logs using Combined Log Format . For custom loggers Pode will pass to your scriptblock a single argument that contains the relevant request information; this log object will look like the following: @{ 'Host' = '10.10.0.3' ; 'RfcUserIdentity' = '-' ; 'User' = '-' ; 'Date' = '14/Jun/2018:20:23:52 +01:00' ; 'Request' = @{ 'Method' = 'GET' ; 'Resource' = '/api/users' ; 'Protocol' = \"HTTP/1.1\" ; 'Referrer' = '-' ; 'Agent' = '<user-agent>' ; }; 'Response' = @{ 'StatusCode' = '200' ; 'StautsDescription' = 'OK' 'Size' = '9001' ; }; }","title":"Logging Overview"},{"location":"Tutorials/Logging/Terminal/","text":"Logging to Terminal Setup This tutorial will be short and sweet! To start logging requests to your server onto the terminal, you simply do the following: Server { listen * : 8080 http # just this line! logger terminal } And that's it, done!","title":"Terminal"},{"location":"Tutorials/Logging/Terminal/#logging-to-terminal","text":"","title":"Logging to Terminal"},{"location":"Tutorials/Logging/Terminal/#setup","text":"This tutorial will be short and sweet! To start logging requests to your server onto the terminal, you simply do the following: Server { listen * : 8080 http # just this line! logger terminal } And that's it, done!","title":"Setup"},{"location":"Tutorials/Middleware/AccessRules/","text":"Access Rules Access rules in Pode are a legacy form of middleware, that allow you to specify allow/deny rules for IP addresses and subnet masks. This means you can deny certain IPs from accessing the server, and vice-versa by allowing them. Usage To setup access rules in Pode you use the access function, along with an action of either allow or deny . The make-up of the access function is as follows: access < allow | deny > ip < address | subnet > You can either put a rule in for a specify IP address, a subnet mask, or for every address (using all ). You can also supply an array of addresses/subnets as well, rather than one at a time. Info If a requests hits your server from an address that you've denied access, then a 403 response is returned and the connection immediately closed. For SMTP/TCP servers the connection is just closed with no response. The following example will allow access for requests from localhost: Server { access allow ip '127.0.0.1' } Whereas the following example will deny access to requests from a subnet: Server { access deny ip '10.10.0.0/24' } To allow access to requests from multiple addresses in one line, the following example will work: Server { access allow ip @( '192.168.1.1' , '192.168.1.2' ) } Finally, to allow or deny access to requests from every address you can use the all keyword: Server { access deny ip all } Overriding Since access rules are a legacy form of middleware in Pode, then when you setup rules via the access function the point at which the rules are checked on the request lifecycle is fixed (see here ). This also mean you can override the inbuilt access rule logic, with your own custom logic, using the middleware function. To override the access rule logic you can pass @access to the -Name parameter of the middleware function. The following example uses access rules, and defines middleware that will override the inbuilt access logic: Server { # attach to port 8080 listen * : 8080 http # assign access rule to deny localhost access deny ip @( '127.0.0.1' , '[::1]' ) # create middleware to override the inbuilt access rule logic. # this will ignore the 'deny' part, and just allow the request middleware -name '@access' { return $true } # basic route route get '/' { # logic } }","title":"Access Rules"},{"location":"Tutorials/Middleware/AccessRules/#access-rules","text":"Access rules in Pode are a legacy form of middleware, that allow you to specify allow/deny rules for IP addresses and subnet masks. This means you can deny certain IPs from accessing the server, and vice-versa by allowing them.","title":"Access Rules"},{"location":"Tutorials/Middleware/AccessRules/#usage","text":"To setup access rules in Pode you use the access function, along with an action of either allow or deny . The make-up of the access function is as follows: access < allow | deny > ip < address | subnet > You can either put a rule in for a specify IP address, a subnet mask, or for every address (using all ). You can also supply an array of addresses/subnets as well, rather than one at a time. Info If a requests hits your server from an address that you've denied access, then a 403 response is returned and the connection immediately closed. For SMTP/TCP servers the connection is just closed with no response. The following example will allow access for requests from localhost: Server { access allow ip '127.0.0.1' } Whereas the following example will deny access to requests from a subnet: Server { access deny ip '10.10.0.0/24' } To allow access to requests from multiple addresses in one line, the following example will work: Server { access allow ip @( '192.168.1.1' , '192.168.1.2' ) } Finally, to allow or deny access to requests from every address you can use the all keyword: Server { access deny ip all }","title":"Usage"},{"location":"Tutorials/Middleware/AccessRules/#overriding","text":"Since access rules are a legacy form of middleware in Pode, then when you setup rules via the access function the point at which the rules are checked on the request lifecycle is fixed (see here ). This also mean you can override the inbuilt access rule logic, with your own custom logic, using the middleware function. To override the access rule logic you can pass @access to the -Name parameter of the middleware function. The following example uses access rules, and defines middleware that will override the inbuilt access logic: Server { # attach to port 8080 listen * : 8080 http # assign access rule to deny localhost access deny ip @( '127.0.0.1' , '[::1]' ) # create middleware to override the inbuilt access rule logic. # this will ignore the 'deny' part, and just allow the request middleware -name '@access' { return $true } # basic route route get '/' { # logic } }","title":"Overriding"},{"location":"Tutorials/Middleware/Overview/","text":"Middleware Overview When working with web servers in Pode - rest apis, routes, web-pages, etc. - they have support for using middleware . Middleware in Pode allows you to observe and edit the request/response objects for a current web event - you can alter the response, add custom objects to the web event for later use, or terminate the response without processing the route logic. Middleware is supported as a general middleware function, as well as on the route function for custom middleware - like authentication. Pode itself has some inbuilt middleware, which is overridable so you can use your own custom middleware. For example, Pode has inbuilt middleware for rate limiting, but you can override this with middleware and the name @limit (more on the Access Rules and Rate Limiting page). Global Middleware To setup and use middleware in Pode you use the middleware function. This will setup global middleware that will run, in the order created, on every request prior to route logic being invoked. The make-up of the middleware function is as follows: middleware [< route >] < scriptblock > [ -name < string >] The middleware function takes a scriptblock, of which itself accepts a single parameter for the current web event (similar to a route ). The event object passed contains the current Request and Response objects - you can also add more custom objects to it, as the event is just a hashtable . The -Name parameter is defined later, but is solely used for allowing you to override the inbuilt middleware of Pode. The route value allows you to specify which routes to run the middleware against. If you want to keep processing and proceed to the next middleware/route then return $true from the scriptblock, otherwise return $false and the response will be closed immediately. The following example is middleware that observes the user agent of the request. If the request comes from a PowerShell session then stop processing and return forbidden, otherwise create a new Agent key on the session for later middleware / route logic: Server { middleware { # event which contains the Request/Response, and other keys param ( $event ) # if the user agent is powershell, deny access if ( $event . Request . UserAgent -ilike '*powershell*' ) { # forbidden status 403 # stop processing return $false } # create a new key on the event for the next middleware/route $event . Agent = $event . Request . UserAgent # continue processing other middleware return $true } } Where as the following example is middleware that will only be run on requests against the /api route. Here, it will run Basic authentication on every API request: Server { middleware '/api' ( auth check basic ) } Route Middleware Custom middleware on a route is basically the same as above however, you don't use the middleware function and instead insert it straight on the route . Normally a route is defined as follows: route < method > < path > < logic > but when you need to add custom middleware to a route, the make-up of the route looks like: route < method > < path > < middleware > < logic > The middleware on a route can either be a single scriptblock or an an array of scriptblocks . Middleware defined on routes will be run before the route itself, but after any global middleware that may have been configured. The following example defines a scriptblock to reject calls that come from a specific IP address on a specific route : Server { # custom middleware to reject access to a specific IP address $reject_ip = { # same event object as supplied to global middleware/routes param ( $event ) # forbid access to the stated IP address if ( $event . Request . RemoteEndPoint . Address . IPAddressToString -ieq '10.10.1.8' ) { status 403 return $false } # allow the next custom middleware or the route itself to run return $true } # the middleware above is linked to this route, and checked before running the route logic route get '/users' $reject_ip { # route logic } # this route has no custom middleware, and just runs the route logic route get '/alive' { # route logic } } Order of Running Although you can define your own custom middleware, Pode does have some legacy middleware with a predefined run order. This order of running is as follows: Access Rules - allowing/denying IP addresses (if access logic is defined) Rate limiting - limiting access to IP addresses (if limit logic is defined) Public content - static content such as images/css/js/html in the /public directory (or other defined static paths) Body parsing - parsing request payload a JSON or XML Querystring - getting any query string parameters currently on the request URL Custom middleware - runs any defined middleware in the order it was created Route middleware - runs any route middleware for the current route being processed Route - finally, the route itself is processed Note This order will be fully customisable in future releases, which will also remove the overriding logic below. Overriding Inbuilt Pode has inbuilt middleware as defined in the order of running above. Sometimes you probably don't want to use the inbuilt rate limiting, and use a custom rate limiting library that utilises REDIS instead. Each of the inbuilt middlewares have a defined name, that you can pass to the middleware function via the -Name parameter: Access control - @access Rate limiting - @limit Public content - @public Body parsing - @body Querystring - @query The following example uses rate limiting, and defines middleware that will override the inbuilt rate limiting logic: Server { # attach to port 8080 listen * : 8080 http # assign rate limiting to localhost, and allow 8 request per 5 seconds limit ip @( '127.0.0.1' , '[::1]' ) 8 5 # create middleware to override the inbuilt rate limiting (to stop the limiting) middleware -name '@limit' { return $true } # basic route route get '/' { # logic } }","title":"Overview"},{"location":"Tutorials/Middleware/Overview/#middleware-overview","text":"When working with web servers in Pode - rest apis, routes, web-pages, etc. - they have support for using middleware . Middleware in Pode allows you to observe and edit the request/response objects for a current web event - you can alter the response, add custom objects to the web event for later use, or terminate the response without processing the route logic. Middleware is supported as a general middleware function, as well as on the route function for custom middleware - like authentication. Pode itself has some inbuilt middleware, which is overridable so you can use your own custom middleware. For example, Pode has inbuilt middleware for rate limiting, but you can override this with middleware and the name @limit (more on the Access Rules and Rate Limiting page).","title":"Middleware Overview"},{"location":"Tutorials/Middleware/Overview/#global-middleware","text":"To setup and use middleware in Pode you use the middleware function. This will setup global middleware that will run, in the order created, on every request prior to route logic being invoked. The make-up of the middleware function is as follows: middleware [< route >] < scriptblock > [ -name < string >] The middleware function takes a scriptblock, of which itself accepts a single parameter for the current web event (similar to a route ). The event object passed contains the current Request and Response objects - you can also add more custom objects to it, as the event is just a hashtable . The -Name parameter is defined later, but is solely used for allowing you to override the inbuilt middleware of Pode. The route value allows you to specify which routes to run the middleware against. If you want to keep processing and proceed to the next middleware/route then return $true from the scriptblock, otherwise return $false and the response will be closed immediately. The following example is middleware that observes the user agent of the request. If the request comes from a PowerShell session then stop processing and return forbidden, otherwise create a new Agent key on the session for later middleware / route logic: Server { middleware { # event which contains the Request/Response, and other keys param ( $event ) # if the user agent is powershell, deny access if ( $event . Request . UserAgent -ilike '*powershell*' ) { # forbidden status 403 # stop processing return $false } # create a new key on the event for the next middleware/route $event . Agent = $event . Request . UserAgent # continue processing other middleware return $true } } Where as the following example is middleware that will only be run on requests against the /api route. Here, it will run Basic authentication on every API request: Server { middleware '/api' ( auth check basic ) }","title":"Global Middleware"},{"location":"Tutorials/Middleware/Overview/#route-middleware","text":"Custom middleware on a route is basically the same as above however, you don't use the middleware function and instead insert it straight on the route . Normally a route is defined as follows: route < method > < path > < logic > but when you need to add custom middleware to a route, the make-up of the route looks like: route < method > < path > < middleware > < logic > The middleware on a route can either be a single scriptblock or an an array of scriptblocks . Middleware defined on routes will be run before the route itself, but after any global middleware that may have been configured. The following example defines a scriptblock to reject calls that come from a specific IP address on a specific route : Server { # custom middleware to reject access to a specific IP address $reject_ip = { # same event object as supplied to global middleware/routes param ( $event ) # forbid access to the stated IP address if ( $event . Request . RemoteEndPoint . Address . IPAddressToString -ieq '10.10.1.8' ) { status 403 return $false } # allow the next custom middleware or the route itself to run return $true } # the middleware above is linked to this route, and checked before running the route logic route get '/users' $reject_ip { # route logic } # this route has no custom middleware, and just runs the route logic route get '/alive' { # route logic } }","title":"Route Middleware"},{"location":"Tutorials/Middleware/Overview/#order-of-running","text":"Although you can define your own custom middleware, Pode does have some legacy middleware with a predefined run order. This order of running is as follows: Access Rules - allowing/denying IP addresses (if access logic is defined) Rate limiting - limiting access to IP addresses (if limit logic is defined) Public content - static content such as images/css/js/html in the /public directory (or other defined static paths) Body parsing - parsing request payload a JSON or XML Querystring - getting any query string parameters currently on the request URL Custom middleware - runs any defined middleware in the order it was created Route middleware - runs any route middleware for the current route being processed Route - finally, the route itself is processed Note This order will be fully customisable in future releases, which will also remove the overriding logic below.","title":"Order of Running"},{"location":"Tutorials/Middleware/Overview/#overriding-inbuilt","text":"Pode has inbuilt middleware as defined in the order of running above. Sometimes you probably don't want to use the inbuilt rate limiting, and use a custom rate limiting library that utilises REDIS instead. Each of the inbuilt middlewares have a defined name, that you can pass to the middleware function via the -Name parameter: Access control - @access Rate limiting - @limit Public content - @public Body parsing - @body Querystring - @query The following example uses rate limiting, and defines middleware that will override the inbuilt rate limiting logic: Server { # attach to port 8080 listen * : 8080 http # assign rate limiting to localhost, and allow 8 request per 5 seconds limit ip @( '127.0.0.1' , '[::1]' ) 8 5 # create middleware to override the inbuilt rate limiting (to stop the limiting) middleware -name '@limit' { return $true } # basic route route get '/' { # logic } }","title":"Overriding Inbuilt"},{"location":"Tutorials/Middleware/RateLimiting/","text":"Rate Limiting Rate limiting in Pode is a legacy form of middleware, that allows you to specify a maximum number of requests for an IP address or subnet masks over a period of seconds. When rate limiting a subnet you can choose to either individually limit each IP address in a subnet, or you can group all IPs in a subnet together under a single limit. Usage To setup rate limiting in Pode you use the limit function, along with a maximum number of requests (the limit) and a defined period of seconds to limit. The make-up of the limit function is as follows: limit ip < address | subnet > -limit < int > -seconds < int > [ -group ] # or shorthand limit ip < address | subnet > -l < int > -s < int > [ -g ] You can either rate limit a specific IP address, a subnet mask, or for every address (using all ). You can also supply an array of addresses/subnets as well, rather than one at a time. Info If an IP address or subnet hits the limit within the given period of seconds, then a 429 response is returned and the connection immediately closed. For SMTP/TCP servers the connection is just closed with no response. The following example will limit requests from localhost to 5 requests per second: Server { limit ip '127.0.0.1' -l 5 -s 1 } Whereas the following example will rate limit requests from a subnet. By default this will give each IP address governed by a subnet their own limit: Server { limit ip '10.10.0.0/24' -l 5 -s 1 } To treat all IP addresses governed by a subnet using the same shared limit, you can supply the -group flag: Server { limit ip -g '10.10.0.0/24' -l 5 -s 1 } To rate limit requests from multiple addresses in one line, the following example will work: Server { limit ip @( '192.168.1.1' , '192.168.1.2' ) -l 10 -s 2 } Finally, to rate limit requests from every address you can use the all keyword: Server { limit ip all -l 60 -s 10 } Overriding Since rate limiting is a legacy form of middleware in Pode, then when you setup rules via the limit function the point at which the limit is checked on the request lifecycle is fixed (see here ). This also mean you can override the inbuilt rate limiting logic, with your own custom logic, using the middleware function. To override the rate limiting logic you can pass @limit to the -Name parameter of the middleware function. The following example uses rate limiting, and defines middleware that will override the inbuilt limiting logic: Server { # attach to port 8080 listen * : 8080 http # assign limiting to localhost limit ip @( '127.0.0.1' , '[::1]' ) -limit 10 -seconds 2 # create middleware to override the inbuilt rate limiting logic. # this will ignore the limiting part, and just allow the request middleware -name '@limit' { return $true } # basic route route get '/' { # logic } }","title":"Rate Limiting"},{"location":"Tutorials/Middleware/RateLimiting/#rate-limiting","text":"Rate limiting in Pode is a legacy form of middleware, that allows you to specify a maximum number of requests for an IP address or subnet masks over a period of seconds. When rate limiting a subnet you can choose to either individually limit each IP address in a subnet, or you can group all IPs in a subnet together under a single limit.","title":"Rate Limiting"},{"location":"Tutorials/Middleware/RateLimiting/#usage","text":"To setup rate limiting in Pode you use the limit function, along with a maximum number of requests (the limit) and a defined period of seconds to limit. The make-up of the limit function is as follows: limit ip < address | subnet > -limit < int > -seconds < int > [ -group ] # or shorthand limit ip < address | subnet > -l < int > -s < int > [ -g ] You can either rate limit a specific IP address, a subnet mask, or for every address (using all ). You can also supply an array of addresses/subnets as well, rather than one at a time. Info If an IP address or subnet hits the limit within the given period of seconds, then a 429 response is returned and the connection immediately closed. For SMTP/TCP servers the connection is just closed with no response. The following example will limit requests from localhost to 5 requests per second: Server { limit ip '127.0.0.1' -l 5 -s 1 } Whereas the following example will rate limit requests from a subnet. By default this will give each IP address governed by a subnet their own limit: Server { limit ip '10.10.0.0/24' -l 5 -s 1 } To treat all IP addresses governed by a subnet using the same shared limit, you can supply the -group flag: Server { limit ip -g '10.10.0.0/24' -l 5 -s 1 } To rate limit requests from multiple addresses in one line, the following example will work: Server { limit ip @( '192.168.1.1' , '192.168.1.2' ) -l 10 -s 2 } Finally, to rate limit requests from every address you can use the all keyword: Server { limit ip all -l 60 -s 10 }","title":"Usage"},{"location":"Tutorials/Middleware/RateLimiting/#overriding","text":"Since rate limiting is a legacy form of middleware in Pode, then when you setup rules via the limit function the point at which the limit is checked on the request lifecycle is fixed (see here ). This also mean you can override the inbuilt rate limiting logic, with your own custom logic, using the middleware function. To override the rate limiting logic you can pass @limit to the -Name parameter of the middleware function. The following example uses rate limiting, and defines middleware that will override the inbuilt limiting logic: Server { # attach to port 8080 listen * : 8080 http # assign limiting to localhost limit ip @( '127.0.0.1' , '[::1]' ) -limit 10 -seconds 2 # create middleware to override the inbuilt rate limiting logic. # this will ignore the limiting part, and just allow the request middleware -name '@limit' { return $true } # basic route route get '/' { # logic } }","title":"Overriding"},{"location":"Tutorials/Middleware/Sessions/","text":"Sessions Session middleware is supported on web requests and responses, in the form of signed-cookies and server-side data storage. When configured, the middleware will check for a session-cookie on the request; if a cookie is not found on the request, or the session is not in the store, then a new session is created and attached to the response. If there is a session, then the appropriate data is loaded from the store. The age of the session-cookie can be specified, as well as whether to extend the duration each time on each request. A secret-key to sign cookies can be supplied, as well as the ability to specify custom data stores - the default is in-mem, custom could be anything like redis/mongo. Usage To setup and configure the using sessions in Pode, you can use the session function. This function will return valid middleware that can be supplied to the middleware function. To use the session function you must supply a hashtable that defines options to configure sessions, and the way they work. The following is an example of how to setup session middleware, with a hashtable that defines all possible options that could be supplied: Server { middleware ( session @{ 'Secret' = 'schwifty' ; # secret-key used to sign session cookie 'Name' = 'pode.sid' ; # session cookie name (def: pode.sid) 'Duration' = 120 ; # duration of the cookie, in seconds 'Extend' = $true ; # extend the duration of the cookie on each call 'GenerateId' = { # custom SessionId generator (def: guid) return [System.IO.Path] :: GetRandomFileName () }; 'Store' = $null ; # custom object with required methods (def: in-mem) }) } GenerateId If supplied, the GenerateId script must be a scriptblock that returns a valid string. The string itself should be a random unique value, that can be used as a unique session identifier. If no GenerateId script is supplied, then the default sessionId is a guid . Store If supplied, the Store must be a valid psobject with the following required ScriptMethod members: [hashtable] Get ( [string] $sessionId ) [void] Set ( [string] $sessionId , [hashtable] $data , [datetime] $expiry ) [void] Delete ( [string] $sessionId ) If no store is supplied, then a default in-memory store is used - with auto-cleanup for expired sessions. For example, the Delete method could be done as follows: $store = New-Object -TypeName psobject $store | Add-Member -MemberType ScriptMethod -Name Delete -Value { param ( $sessionId ) Remove-RedisKey $sessionId | Out-Null } return $store Session Data To add data to a session you can utilise the .Session.Data object within the argument supplied to a route - or other middleware. The data will be saved at the end of the route logic automatically using endware . When a request comes in using the same session, the data is loaded from the store. Example An example of using sessions in a route to increment a views counter could be done as follows (the counter will continue to increment on each call to the route until the session expires after 2mins): Server { middleware ( session @{ 'secret' = 'schwifty' ; 'duration' = 120 ; }) route 'get' '/' { param ( $s ) $s . Session . Data . Views ++ json @{ 'Views' = $s . Session . Data . Views } } }","title":"Sessions"},{"location":"Tutorials/Middleware/Sessions/#sessions","text":"Session middleware is supported on web requests and responses, in the form of signed-cookies and server-side data storage. When configured, the middleware will check for a session-cookie on the request; if a cookie is not found on the request, or the session is not in the store, then a new session is created and attached to the response. If there is a session, then the appropriate data is loaded from the store. The age of the session-cookie can be specified, as well as whether to extend the duration each time on each request. A secret-key to sign cookies can be supplied, as well as the ability to specify custom data stores - the default is in-mem, custom could be anything like redis/mongo.","title":"Sessions"},{"location":"Tutorials/Middleware/Sessions/#usage","text":"To setup and configure the using sessions in Pode, you can use the session function. This function will return valid middleware that can be supplied to the middleware function. To use the session function you must supply a hashtable that defines options to configure sessions, and the way they work. The following is an example of how to setup session middleware, with a hashtable that defines all possible options that could be supplied: Server { middleware ( session @{ 'Secret' = 'schwifty' ; # secret-key used to sign session cookie 'Name' = 'pode.sid' ; # session cookie name (def: pode.sid) 'Duration' = 120 ; # duration of the cookie, in seconds 'Extend' = $true ; # extend the duration of the cookie on each call 'GenerateId' = { # custom SessionId generator (def: guid) return [System.IO.Path] :: GetRandomFileName () }; 'Store' = $null ; # custom object with required methods (def: in-mem) }) }","title":"Usage"},{"location":"Tutorials/Middleware/Sessions/#generateid","text":"If supplied, the GenerateId script must be a scriptblock that returns a valid string. The string itself should be a random unique value, that can be used as a unique session identifier. If no GenerateId script is supplied, then the default sessionId is a guid .","title":"GenerateId"},{"location":"Tutorials/Middleware/Sessions/#store","text":"If supplied, the Store must be a valid psobject with the following required ScriptMethod members: [hashtable] Get ( [string] $sessionId ) [void] Set ( [string] $sessionId , [hashtable] $data , [datetime] $expiry ) [void] Delete ( [string] $sessionId ) If no store is supplied, then a default in-memory store is used - with auto-cleanup for expired sessions. For example, the Delete method could be done as follows: $store = New-Object -TypeName psobject $store | Add-Member -MemberType ScriptMethod -Name Delete -Value { param ( $sessionId ) Remove-RedisKey $sessionId | Out-Null } return $store","title":"Store"},{"location":"Tutorials/Middleware/Sessions/#session-data","text":"To add data to a session you can utilise the .Session.Data object within the argument supplied to a route - or other middleware. The data will be saved at the end of the route logic automatically using endware . When a request comes in using the same session, the data is loaded from the store.","title":"Session Data"},{"location":"Tutorials/Middleware/Sessions/#example","text":"An example of using sessions in a route to increment a views counter could be done as follows (the counter will continue to increment on each call to the route until the session expires after 2mins): Server { middleware ( session @{ 'secret' = 'schwifty' ; 'duration' = 120 ; }) route 'get' '/' { param ( $s ) $s . Session . Data . Views ++ json @{ 'Views' = $s . Session . Data . Views } } }","title":"Example"},{"location":"Tutorials/Misc/CronExpressions/","text":"Cron Expressions Schedules and Auto Server Restarting in Pode use cron expressions to define when they trigger. This page is a brief overview of the expressions supported by Pode. Basic Pode supports all basic features of cron expressions in the following format: <min> <hour> <day-of-month> <month> <day-of-week> For example, if you wanted to run a schedule that triggers every midnight on a Tuesday, the following would work: 0 0 * * TUE Whereas if you wanted a schedule to trigger on the 15th of each month, at 1am: 0 1 15 * * * Predefined The following table outlines some of the predefined cron expressions supported by Pode; you can use these in place of normal cron expressions: Predefined Expression @minutely * * * * * @hourly 0 * * * * @daily 0 0 * * * @weekly 0 0 * * 0 @monthly 0 0 1 * * @quaterly 0 0 1 1,4,8,7,10 @yearly 0 0 1 1 * @annually 0 0 1 1 * @twice-hourly 0,30 * * * * @twice-daily 0,12 0 * * * @twice-weekly 0 0 * * 0,4 @twice-monthly 0 0 1,15 * * @twice-yearly 0 0 1 1,6 * @twice-annually 0 0 1 1,6 * Advanced Pode does have some support for advanced cron features, including its own placeholder: R . R : using this on an atom will use a random value between that atom's constraints, and when the expression is triggered the atom is re-randomised - you can force an initial trigger value using /R . For example: 30/R * * * * will trigger on 30mins, then a random minute afterwards; whereas using R * * * * will always trigger on a random minute between 0-59.","title":"Cron Expressions"},{"location":"Tutorials/Misc/CronExpressions/#cron-expressions","text":"Schedules and Auto Server Restarting in Pode use cron expressions to define when they trigger. This page is a brief overview of the expressions supported by Pode.","title":"Cron Expressions"},{"location":"Tutorials/Misc/CronExpressions/#basic","text":"Pode supports all basic features of cron expressions in the following format: <min> <hour> <day-of-month> <month> <day-of-week> For example, if you wanted to run a schedule that triggers every midnight on a Tuesday, the following would work: 0 0 * * TUE Whereas if you wanted a schedule to trigger on the 15th of each month, at 1am: 0 1 15 * * *","title":"Basic"},{"location":"Tutorials/Misc/CronExpressions/#predefined","text":"The following table outlines some of the predefined cron expressions supported by Pode; you can use these in place of normal cron expressions: Predefined Expression @minutely * * * * * @hourly 0 * * * * @daily 0 0 * * * @weekly 0 0 * * 0 @monthly 0 0 1 * * @quaterly 0 0 1 1,4,8,7,10 @yearly 0 0 1 1 * @annually 0 0 1 1 * @twice-hourly 0,30 * * * * @twice-daily 0,12 0 * * * @twice-weekly 0 0 * * 0,4 @twice-monthly 0 0 1,15 * * @twice-yearly 0 0 1 1,6 * @twice-annually 0 0 1 1,6 *","title":"Predefined"},{"location":"Tutorials/Misc/CronExpressions/#advanced","text":"Pode does have some support for advanced cron features, including its own placeholder: R . R : using this on an atom will use a random value between that atom's constraints, and when the expression is triggered the atom is re-randomised - you can force an initial trigger value using /R . For example: 30/R * * * * will trigger on 30mins, then a random minute afterwards; whereas using R * * * * will always trigger on a random minute between 0-59.","title":"Advanced"},{"location":"Tutorials/Misc/DesktopApp/","text":"Desktop Application Normally in Pode you define a server and run it however, using the gui function Pode can serve the server up as a desktop application. Warning Currently only supported on Windows due to using WPF. (Though it appears WPF could soon be supported on .NET Core 3) Setting Server to run as Application To serve up you server as a desktop application you can just write you Pode server script as normal. The only difference is you can use the gui function to display the application. The make-up of the function is as follows: gui < name > [ -options @{}] The gui must have a name supplied - this is the title of the application's window. The options are a hashtable that define further feature to customise the window. The following will create a basic web server with a single page, but when the server is run it will pop up as a desktop application: Server { gui 'Basic Server' listen localhost : 8080 http route get '/' { view 'index' } } The page used is as follows: < html > < head > < link rel = \"stylesheet\" type = \"text/css\" href = \"/styles/main.css\" > </ head > < body > < h1 > Hello, world! </ h1 > < p > Welcome to a very simple desktop app! </ p > </ body > </ html > Simple script to load Application When you run the server from your terminal, the application will open and the terminal will remain visible. However, you could have a script which opens PowerShell as hidden and launches the server. The following is a basic example of a .bat file which could be double-clicked to open the application, and then hide the terminal: powershell.exe -noprofile -windowstyle hidden -command .\\you-server-script.ps1 exit","title":"Desktop Application"},{"location":"Tutorials/Misc/DesktopApp/#desktop-application","text":"Normally in Pode you define a server and run it however, using the gui function Pode can serve the server up as a desktop application. Warning Currently only supported on Windows due to using WPF. (Though it appears WPF could soon be supported on .NET Core 3)","title":"Desktop Application"},{"location":"Tutorials/Misc/DesktopApp/#setting-server-to-run-as-application","text":"To serve up you server as a desktop application you can just write you Pode server script as normal. The only difference is you can use the gui function to display the application. The make-up of the function is as follows: gui < name > [ -options @{}] The gui must have a name supplied - this is the title of the application's window. The options are a hashtable that define further feature to customise the window. The following will create a basic web server with a single page, but when the server is run it will pop up as a desktop application: Server { gui 'Basic Server' listen localhost : 8080 http route get '/' { view 'index' } } The page used is as follows: < html > < head > < link rel = \"stylesheet\" type = \"text/css\" href = \"/styles/main.css\" > </ head > < body > < h1 > Hello, world! </ h1 > < p > Welcome to a very simple desktop app! </ p > </ body > </ html >","title":"Setting Server to run as Application"},{"location":"Tutorials/Misc/DesktopApp/#simple-script-to-load-application","text":"When you run the server from your terminal, the application will open and the terminal will remain visible. However, you could have a script which opens PowerShell as hidden and launches the server. The following is a basic example of a .bat file which could be double-clicked to open the application, and then hide the terminal: powershell.exe -noprofile -windowstyle hidden -command .\\you-server-script.ps1 exit","title":"Simple script to load Application"},{"location":"Tutorials/Misc/UploadFiles/","text":"Uploading Files Pode's inbuilt middleware supports parsing a request's body/payload and query string, and this also extends to uploading files via a <form> . Like how POST data can be accessed in a route via the passed web event as $e.Data[<name>] , uploaded files can be accessed via $e.Files[<filename>] . Important In order for uploaded files to work, your <form> must contain enctype=\"multipart/form-data\" Web Form The following HTML is an example of a <form> for a simple sign-up flow. Here the form will POST the username, password, and an avatar (our file to upload). < html > < head > < title > Sign Up </ title > </ head > < body > < form action = \"/signup\" method = \"post\" enctype = \"multipart/form-data\" > < div > < label > Username: </ label > < input type = \"text\" name = \"username\" /> </ div > < div > < label > Password: </ label > < input type = \"password\" name = \"password\" /> </ div > < div > < label > Avatar: </ label > < input type = \"file\" name = \"avatar\" /> </ div > < div > < input type = \"submit\" value = \"Submit\" /> </ div > </ form > </ body > </ html > You can upload multiple files from one <form> The inputs will be POSTed to the server, and accessible via the web event's .Data and .Files . For the .Data : $e . Data [ 'username' ] # the username entered $e . Data [ 'password' ] # the password entered $e . Data [ 'avatar' ] # the name of the file (assume image.png) For the .Files : $e . Files [ 'image.png' ] # the bytes of the uploaded file Script Inbuilt Save The following script is an example Pode server script that will save the uploaded file, from the above <form> : Server { # listen on localhost:8085 listen * : 8085 http engine html # GET request for web page on \"localhost:8085/\" route get '/' { view 'signup' } # POST request to save the avatar and create user route post '/signup' { param ( $e ) # do some logic here to create user New-User -Username $e . Data [ 'username' ] -Password $e . Data [ 'password' ] # upload the avatar - this will retrieve the filename from $e.Data, # and the bytes from $e.Files, saving to the server's root path save 'avatar' } } Custom Save If you need to save the uploaded file elsewhere, then you can retrieve the raw bytes of the avatar file as follows: route post '/upload' { param ( $e ) # using .Data will get you the file's name $filename = $e . Data [ 'avatar' ] # with the filename, you can get the file's bytes from .File # as well as the Bytes, you can also get the ContentType $bytes = $e . Files [ $filename ]. Bytes # with the bytes, you can upload the file where ever you want }","title":"Uploading Files"},{"location":"Tutorials/Misc/UploadFiles/#uploading-files","text":"Pode's inbuilt middleware supports parsing a request's body/payload and query string, and this also extends to uploading files via a <form> . Like how POST data can be accessed in a route via the passed web event as $e.Data[<name>] , uploaded files can be accessed via $e.Files[<filename>] . Important In order for uploaded files to work, your <form> must contain enctype=\"multipart/form-data\"","title":"Uploading Files"},{"location":"Tutorials/Misc/UploadFiles/#web-form","text":"The following HTML is an example of a <form> for a simple sign-up flow. Here the form will POST the username, password, and an avatar (our file to upload). < html > < head > < title > Sign Up </ title > </ head > < body > < form action = \"/signup\" method = \"post\" enctype = \"multipart/form-data\" > < div > < label > Username: </ label > < input type = \"text\" name = \"username\" /> </ div > < div > < label > Password: </ label > < input type = \"password\" name = \"password\" /> </ div > < div > < label > Avatar: </ label > < input type = \"file\" name = \"avatar\" /> </ div > < div > < input type = \"submit\" value = \"Submit\" /> </ div > </ form > </ body > </ html > You can upload multiple files from one <form> The inputs will be POSTed to the server, and accessible via the web event's .Data and .Files . For the .Data : $e . Data [ 'username' ] # the username entered $e . Data [ 'password' ] # the password entered $e . Data [ 'avatar' ] # the name of the file (assume image.png) For the .Files : $e . Files [ 'image.png' ] # the bytes of the uploaded file","title":"Web Form"},{"location":"Tutorials/Misc/UploadFiles/#script","text":"","title":"Script"},{"location":"Tutorials/Misc/UploadFiles/#inbuilt-save","text":"The following script is an example Pode server script that will save the uploaded file, from the above <form> : Server { # listen on localhost:8085 listen * : 8085 http engine html # GET request for web page on \"localhost:8085/\" route get '/' { view 'signup' } # POST request to save the avatar and create user route post '/signup' { param ( $e ) # do some logic here to create user New-User -Username $e . Data [ 'username' ] -Password $e . Data [ 'password' ] # upload the avatar - this will retrieve the filename from $e.Data, # and the bytes from $e.Files, saving to the server's root path save 'avatar' } }","title":"Inbuilt Save"},{"location":"Tutorials/Misc/UploadFiles/#custom-save","text":"If you need to save the uploaded file elsewhere, then you can retrieve the raw bytes of the avatar file as follows: route post '/upload' { param ( $e ) # using .Data will get you the file's name $filename = $e . Data [ 'avatar' ] # with the filename, you can get the file's bytes from .File # as well as the Bytes, you can also get the ContentType $bytes = $e . Files [ $filename ]. Bytes # with the bytes, you can upload the file where ever you want }","title":"Custom Save"},{"location":"Tutorials/Routes/ErrorPages/","text":"Error Pages and Status Codes During web requests, Pode has some default status codes that can be returned: 200 on success 400 when the query string or payload are invalid 403 when access to the server is unauthorised 404 if the route can't be found 429 if the rate limit is reached 500 for a complete failure When viewed through a browser, status codes that are 400+ will be rendered as an error page. Pode itself has an inbuilt error page, but you can override this page using custom error pages ( described below ). These pages are supplied the status code, description and URL that triggered the error. They're also supplied details of any exception supplied to the status function, which can be rendered if enabled via the pode.json configuration file. Status Codes The status function allows you to set your own status code on the response, as well as a custom description. If the status code was triggered by an exception occurring, then you can also supply this to status so it can be rendered on the error page . The make-up of the status function is as follows: status < int > [ -description < string >] [ -exception < exception >] # or shorthand status < int > [ -d < string >] [ -e < exception >] The following example will set the status code of the response to be 418 : Server { listen * : 8080 http route get '/teapot' { status 418 } } Where as this example will return a 500 with a custom description, and the exception that caused the error: Server { listen * : 8080 http route get '/eek' { try { # logic } catch { status 500 -d 'oh no! something went wrong!' -e $_ } } } Error Pages When a response is returned with a status code of 400+, then Pode will render these as styled error pages. By default, Pode has an inbuilt error page that will be used (this shows the status code, description, the URL and if enabled the exception message/stacktrace). Custom However, Pode also supports custom error pages, so you can stylise your own! To use your own custom error pages you place the pages within an /errors directory at the root of your server (similar to /views and /public ). These pages should be called the name of the status code, plus a relevant extension: <code>.<ext> . Or, you can use default.<ext> as a catch-all for all status codes: /errors default.html 404.html 500.html Important The extension used will determine the view engine that will be used to render the error pages, such as html or pode . If you're using a dynamic view engine to render the error pages, then like views , there will be a $data variable that you can use within the view file. The $data variable will have the following structure: @{ 'Url' = [string] ; 'Status' = @{ 'Code' = [int] ; 'Description' = [string] ; }; 'Exception' = @{ 'Message' = [string] ; 'StackTrace' = [string] ; 'Line' = [string] ; 'Category' = [string] ; }; } Note If you've disabled the showing of exceptions, then the Exception value will be $null Exceptions Above you'll see that the exception supplied to status will also be supplied to any dynamic error pages. By default, this is disabled, but you can enable the viewing of exceptions on the error page by using the pode.json configuration file: { \"web\" : { \"errorPages\" : { \"showExceptions\" : true } } } Once set to true , any available exception details for status codes will be available to error pages. Example The following is a simple example default.pode dynamic error page, which will render the status code and description - and if available, the exception message and stacktrace: < html > < head > < title > $($data.status.code) Error </ title > </ head > < body > < h1 > $($data.status.code) Error </ h1 > < p > Description: $($data.status.description) </ p > $(if ($data.exception) { \" < pre > $($data.exception.message) $($data.exception.stacktrace) </ pre > \" }) </ body > </ html >","title":"Error Pages"},{"location":"Tutorials/Routes/ErrorPages/#error-pages-and-status-codes","text":"During web requests, Pode has some default status codes that can be returned: 200 on success 400 when the query string or payload are invalid 403 when access to the server is unauthorised 404 if the route can't be found 429 if the rate limit is reached 500 for a complete failure When viewed through a browser, status codes that are 400+ will be rendered as an error page. Pode itself has an inbuilt error page, but you can override this page using custom error pages ( described below ). These pages are supplied the status code, description and URL that triggered the error. They're also supplied details of any exception supplied to the status function, which can be rendered if enabled via the pode.json configuration file.","title":"Error Pages and Status Codes"},{"location":"Tutorials/Routes/ErrorPages/#status-codes","text":"The status function allows you to set your own status code on the response, as well as a custom description. If the status code was triggered by an exception occurring, then you can also supply this to status so it can be rendered on the error page . The make-up of the status function is as follows: status < int > [ -description < string >] [ -exception < exception >] # or shorthand status < int > [ -d < string >] [ -e < exception >] The following example will set the status code of the response to be 418 : Server { listen * : 8080 http route get '/teapot' { status 418 } } Where as this example will return a 500 with a custom description, and the exception that caused the error: Server { listen * : 8080 http route get '/eek' { try { # logic } catch { status 500 -d 'oh no! something went wrong!' -e $_ } } }","title":"Status Codes"},{"location":"Tutorials/Routes/ErrorPages/#error-pages","text":"When a response is returned with a status code of 400+, then Pode will render these as styled error pages. By default, Pode has an inbuilt error page that will be used (this shows the status code, description, the URL and if enabled the exception message/stacktrace).","title":"Error Pages"},{"location":"Tutorials/Routes/ErrorPages/#custom","text":"However, Pode also supports custom error pages, so you can stylise your own! To use your own custom error pages you place the pages within an /errors directory at the root of your server (similar to /views and /public ). These pages should be called the name of the status code, plus a relevant extension: <code>.<ext> . Or, you can use default.<ext> as a catch-all for all status codes: /errors default.html 404.html 500.html Important The extension used will determine the view engine that will be used to render the error pages, such as html or pode . If you're using a dynamic view engine to render the error pages, then like views , there will be a $data variable that you can use within the view file. The $data variable will have the following structure: @{ 'Url' = [string] ; 'Status' = @{ 'Code' = [int] ; 'Description' = [string] ; }; 'Exception' = @{ 'Message' = [string] ; 'StackTrace' = [string] ; 'Line' = [string] ; 'Category' = [string] ; }; } Note If you've disabled the showing of exceptions, then the Exception value will be $null","title":"Custom"},{"location":"Tutorials/Routes/ErrorPages/#exceptions","text":"Above you'll see that the exception supplied to status will also be supplied to any dynamic error pages. By default, this is disabled, but you can enable the viewing of exceptions on the error page by using the pode.json configuration file: { \"web\" : { \"errorPages\" : { \"showExceptions\" : true } } } Once set to true , any available exception details for status codes will be available to error pages.","title":"Exceptions"},{"location":"Tutorials/Routes/ErrorPages/#example","text":"The following is a simple example default.pode dynamic error page, which will render the status code and description - and if available, the exception message and stacktrace: < html > < head > < title > $($data.status.code) Error </ title > </ head > < body > < h1 > $($data.status.code) Error </ h1 > < p > Description: $($data.status.description) </ p > $(if ($data.exception) { \" < pre > $($data.exception.message) $($data.exception.stacktrace) </ pre > \" }) </ body > </ html >","title":"Example"},{"location":"Tutorials/Routes/FlashMessages/","text":"Flash Messages Flash messages allow you to pass temporary messages - info/error or other - across multiple web requests via a user's current session. For example, in sign-up logic you could set a flash error message for an invalid email address; retrieving the message from the session on a redirect for the view, allowing the view to render error messages. Important To use flash messages you need to have Session Middleware enabled. Usage The flash function allows you to add, get, and remove messages on a user's session. The make-up of the flash function is as follows: flash < action > [< key > < message >] Valid <action> values are: Add , Clear , Get , Keys , Remove . A <key> must be supplied on Add , Get , Remove actions. A <message> must be supplied on the Add action. If you supply multiple Add actions using the same <key> , then the messages will be grouped together as an array. The action of Get for a <key> will remove all messages from the current session for that <key> . The following is an example of adding a flash message to a session, this will add a message under the email-error key: flash add 'email-error' 'Invalid email address' Then to retrieve the message, you can do this in a route for a view : route get '/signup' { view 'signup' -d @{ 'errors' = @{ 'email' = ( flash get 'email-error' ) } } } Views The view function has a helper switch ( -FlashMessages ) to load all current flash messages in the session, into the views data - to save time writing lots of flash get calls. When used, all messages will be loaded into the $data argument supplied to dynamic views, and accessible under $data.flash . For example, somewhere we could have a sign-up flow which fails validation and adds two messages to the session: flash add 'email-error' 'Invalid email address' flash add 'name-error' 'No first/last name supplied' Then, within your route to load the sign-up view, you can use the switch to automatically load all current flash messages (note: -fm is an alias of -FlashMessages ): route get '/signup' { view -fm 'signup' } With this, the two flash messages for email-error and name-error are automatically added to a dynamic view's $data.flash property. You could get these back in the view, such as the snippet of a possible signup.pode : < html > < head > ... </ head > < body > < form action = \"/signup\" method = \"post\" > <!-- The email input control --> < label > Email Address: </ label > < input type = \"text\" id = \"email\" name = \"email\" /> <!-- Check if there's a flash error, and display it --> $(if ($data.flash['email-error']) { \" < p class = 'error' > $($data.flash['email-error']) </ p > \" }) </ form > </ body > </ html > Authentication When doing authentication checks, normally if the check fails Pode will throw an error and return with a 401 status code. However, you can tell auth check calls to load these errors in the session's flash messages under an auth-error key. To do this, you specify the FailureFlash option as $true to the auth check call. For example, here we have a login page, with the post login check. The check flags that any authentication errors should be loaded into the session's flash messages: route 'get' '/login' ( auth check login -o @{ 'login' = $true ; 'successUrl' = '/' }) { view -fm 'auth-login' } route 'post' '/login' ( auth check login -o @{ 'failureUrl' = '/login' ; 'successUrl' = '/' ; 'failureFlash' = $true ; }) {} Then, to load the authentication back for the user: < html > < head > ... </ head > < body > < form action = \"/login\" method = \"post\" > <!-- The username control --> < label > Username: </ label > < input type = \"text\" name = \"username\" /> <!-- The password control --> < label > Password: </ label > < input type = \"password\" name = \"password\" /> </ form > <!-- Check if there's a flash error, and display it --> $(if ($Data.flash['auth-error']) { \" < p class = 'error' > $($data.flash['auth-error']) </ p > \" }) </ body > </ html >","title":"Flash Messages"},{"location":"Tutorials/Routes/FlashMessages/#flash-messages","text":"Flash messages allow you to pass temporary messages - info/error or other - across multiple web requests via a user's current session. For example, in sign-up logic you could set a flash error message for an invalid email address; retrieving the message from the session on a redirect for the view, allowing the view to render error messages. Important To use flash messages you need to have Session Middleware enabled.","title":"Flash Messages"},{"location":"Tutorials/Routes/FlashMessages/#usage","text":"The flash function allows you to add, get, and remove messages on a user's session. The make-up of the flash function is as follows: flash < action > [< key > < message >] Valid <action> values are: Add , Clear , Get , Keys , Remove . A <key> must be supplied on Add , Get , Remove actions. A <message> must be supplied on the Add action. If you supply multiple Add actions using the same <key> , then the messages will be grouped together as an array. The action of Get for a <key> will remove all messages from the current session for that <key> . The following is an example of adding a flash message to a session, this will add a message under the email-error key: flash add 'email-error' 'Invalid email address' Then to retrieve the message, you can do this in a route for a view : route get '/signup' { view 'signup' -d @{ 'errors' = @{ 'email' = ( flash get 'email-error' ) } } }","title":"Usage"},{"location":"Tutorials/Routes/FlashMessages/#views","text":"The view function has a helper switch ( -FlashMessages ) to load all current flash messages in the session, into the views data - to save time writing lots of flash get calls. When used, all messages will be loaded into the $data argument supplied to dynamic views, and accessible under $data.flash . For example, somewhere we could have a sign-up flow which fails validation and adds two messages to the session: flash add 'email-error' 'Invalid email address' flash add 'name-error' 'No first/last name supplied' Then, within your route to load the sign-up view, you can use the switch to automatically load all current flash messages (note: -fm is an alias of -FlashMessages ): route get '/signup' { view -fm 'signup' } With this, the two flash messages for email-error and name-error are automatically added to a dynamic view's $data.flash property. You could get these back in the view, such as the snippet of a possible signup.pode : < html > < head > ... </ head > < body > < form action = \"/signup\" method = \"post\" > <!-- The email input control --> < label > Email Address: </ label > < input type = \"text\" id = \"email\" name = \"email\" /> <!-- Check if there's a flash error, and display it --> $(if ($data.flash['email-error']) { \" < p class = 'error' > $($data.flash['email-error']) </ p > \" }) </ form > </ body > </ html >","title":"Views"},{"location":"Tutorials/Routes/FlashMessages/#authentication","text":"When doing authentication checks, normally if the check fails Pode will throw an error and return with a 401 status code. However, you can tell auth check calls to load these errors in the session's flash messages under an auth-error key. To do this, you specify the FailureFlash option as $true to the auth check call. For example, here we have a login page, with the post login check. The check flags that any authentication errors should be loaded into the session's flash messages: route 'get' '/login' ( auth check login -o @{ 'login' = $true ; 'successUrl' = '/' }) { view -fm 'auth-login' } route 'post' '/login' ( auth check login -o @{ 'failureUrl' = '/login' ; 'successUrl' = '/' ; 'failureFlash' = $true ; }) {} Then, to load the authentication back for the user: < html > < head > ... </ head > < body > < form action = \"/login\" method = \"post\" > <!-- The username control --> < label > Username: </ label > < input type = \"text\" name = \"username\" /> <!-- The password control --> < label > Password: </ label > < input type = \"password\" name = \"password\" /> </ form > <!-- Check if there's a flash error, and display it --> $(if ($Data.flash['auth-error']) { \" < p class = 'error' > $($data.flash['auth-error']) </ p > \" }) </ body > </ html >","title":"Authentication"},{"location":"Tutorials/Routes/LoginPage/","text":"Creating a Login Page This is mostly a pure example of having a website with a login and home page - with a logout button. The pages will all be done using .pode files, and authentication will be done using Form authentication with sessions. Info This full example can be seen on GitHub in examples/web-auth-form.ps1 . File Structure Firstly, the file structure of this example will look as follows: server.ps1 /views index.pode login.pode /public styles/main.css Server To start off this script, you'll need to have the main server wrapper; here we'll use 2 threads to handle requests: Import-Module Pode Server -Thread 2 { # the rest of the logic goes here! } Next, we'll need to listen on an endpoint and then specify the engine as using .pode files: listen * : 8080 http engine pode To use sessions for our authentication (so we can stay logged in), we need to setup session middleware . Here our sessions will last for 2 minutes, and will be extended on each request: middleware ( session @{ 'secret' = 'schwify' ; 'duration' = 120 ; 'extend' = $true ; }) Once we have the sessions in, we need to configure the Form authentication - the username/password here are hardcoded, but normally you would validate against a database: auth use form -v { param ( $username , $password ) if ( $username -eq 'morty' -and $password -eq 'pickle' ) { return @{ 'user' = @{ 'ID' = 'M0R7Y302' ; 'Name' = 'Morty' ; 'Type' = 'Human' ; } } } # aww geez! no user was found return $null } This is where it gets interesting, below is the route for the root ( / ) endpoint. This will check the cookies in the request for a signed session cookie, if one is found then the index.pode page is displayed - after incrementing a page-view counter. However, if there is no session, or authentication fails, the user is redirected to the login page: route get '/' ( auth check form -o @{ 'failureUrl' = '/login' }) { param ( $s ) $s . Session . Data . Views ++ view 'index' -data @{ 'Username' = $s . Auth . User . Name ; 'Views' = $s . Session . Data . Views ; } } Next we have the login route , which is actually two routes. The GET /login is the page itself, whereas the POST /login is the authentication part (the endpoint the <form> element will hit). For the POST route, if authentication passes the user is logged in and redirected to the home page, but if it failed they're taken back to the login page. For the GET route we have a <\"login\" = $true> option; this basically means if the user navigates to the login page with an already validated session they're automatically taken back to the home page (the successUrl ). However if they have no session or authentication fails then instead of a 403 being displayed, the login page is displayed instead. route get '/login' ( auth check form -o @{ 'login' = $true ; 'successUrl' = '/' }) { param ( $s ) view 'login' } route post '/login' ( auth check form -o @{ 'failureUrl' = '/login' ; 'successUrl' = '/' ; }) {} Finally, we have the logout route . Here we have another option of <\"logout\" = $true> , which basically just means to kill the session and redirect to the login page: route 'post' '/logout' ( auth check form -o @{ 'logout' = $true ; 'failureUrl' = '/login' ; }) {} Full Server This is the full code for the server above: Import-Module Pode Server -Thread 2 { listen * : 8080 http # use pode template engine engine pode # setup session middleware middleware ( session @{ 'secret' = 'schwify' ; 'duration' = 120 ; 'extend' = $true ; }) # setup form authentication auth use form -v { param ( $username , $password ) if ( $username -eq 'morty' -and $password -eq 'pickle' ) { return @{ 'user' = @{ 'ID' = 'M0R7Y302' ; 'Name' = 'Morty' ; 'Type' = 'Human' ; } } } # aww geez! no user was found return $null } # the \"GET /\" endpoint for the homepage route get '/' ( auth check form -o @{ 'failureUrl' = '/login' }) { param ( $s ) $s . Session . Data . Views ++ view 'index' -data @{ 'Username' = $s . Auth . User . Name ; 'Views' = $s . Session . Data . Views ; } } # the \"GET /login\" endpoint for the login page route get '/login' ( auth check form -o @{ 'login' = $true ; 'successUrl' = '/' }) { param ( $s ) view 'login' } # the \"POST /login\" endpoint for user authentication route post '/login' ( auth check form -o @{ 'failureUrl' = '/login' ; 'successUrl' = '/' ; }) {} # the \"POST /logout\" endpoint for ending the session route 'post' '/logout' ( auth check form -o @{ 'logout' = $true ; 'failureUrl' = '/login' ; }) {} } Pages The following are the web pages used above, as well as the CSS style. The web pages have been created using .pode files, which allows you to embed PowerShell into the files. index.pode < html > < head > < title > Auth Home </ title > < link rel = \"stylesheet\" type = \"text/css\" href = \"/styles/main.css\" > </ head > < body > Hello, $($data.Username)! You have view this page $($data.Views) times! < form action = \"/logout\" method = \"post\" > < div > < input type = \"submit\" value = \"Logout\" /> </ div > </ form > </ body > </ html > login.pode < html > < head > < title > Auth Login </ title > < link rel = \"stylesheet\" type = \"text/css\" href = \"/styles/main.css\" > </ head > < body > Please Login: < form action = \"/login\" method = \"post\" > < div > < label > Username: </ label > < input type = \"text\" name = \"username\" /> </ div > < div > < label > Password: </ label > < input type = \"password\" name = \"password\" /> </ div > < div > < input type = \"submit\" value = \"Login\" /> </ div > </ form > </ body > </ html > styles/main.css body { background-color : rebeccapurple ; }","title":"Login Page"},{"location":"Tutorials/Routes/LoginPage/#creating-a-login-page","text":"This is mostly a pure example of having a website with a login and home page - with a logout button. The pages will all be done using .pode files, and authentication will be done using Form authentication with sessions. Info This full example can be seen on GitHub in examples/web-auth-form.ps1 .","title":"Creating a Login Page"},{"location":"Tutorials/Routes/LoginPage/#file-structure","text":"Firstly, the file structure of this example will look as follows: server.ps1 /views index.pode login.pode /public styles/main.css","title":"File Structure"},{"location":"Tutorials/Routes/LoginPage/#server","text":"To start off this script, you'll need to have the main server wrapper; here we'll use 2 threads to handle requests: Import-Module Pode Server -Thread 2 { # the rest of the logic goes here! } Next, we'll need to listen on an endpoint and then specify the engine as using .pode files: listen * : 8080 http engine pode To use sessions for our authentication (so we can stay logged in), we need to setup session middleware . Here our sessions will last for 2 minutes, and will be extended on each request: middleware ( session @{ 'secret' = 'schwify' ; 'duration' = 120 ; 'extend' = $true ; }) Once we have the sessions in, we need to configure the Form authentication - the username/password here are hardcoded, but normally you would validate against a database: auth use form -v { param ( $username , $password ) if ( $username -eq 'morty' -and $password -eq 'pickle' ) { return @{ 'user' = @{ 'ID' = 'M0R7Y302' ; 'Name' = 'Morty' ; 'Type' = 'Human' ; } } } # aww geez! no user was found return $null } This is where it gets interesting, below is the route for the root ( / ) endpoint. This will check the cookies in the request for a signed session cookie, if one is found then the index.pode page is displayed - after incrementing a page-view counter. However, if there is no session, or authentication fails, the user is redirected to the login page: route get '/' ( auth check form -o @{ 'failureUrl' = '/login' }) { param ( $s ) $s . Session . Data . Views ++ view 'index' -data @{ 'Username' = $s . Auth . User . Name ; 'Views' = $s . Session . Data . Views ; } } Next we have the login route , which is actually two routes. The GET /login is the page itself, whereas the POST /login is the authentication part (the endpoint the <form> element will hit). For the POST route, if authentication passes the user is logged in and redirected to the home page, but if it failed they're taken back to the login page. For the GET route we have a <\"login\" = $true> option; this basically means if the user navigates to the login page with an already validated session they're automatically taken back to the home page (the successUrl ). However if they have no session or authentication fails then instead of a 403 being displayed, the login page is displayed instead. route get '/login' ( auth check form -o @{ 'login' = $true ; 'successUrl' = '/' }) { param ( $s ) view 'login' } route post '/login' ( auth check form -o @{ 'failureUrl' = '/login' ; 'successUrl' = '/' ; }) {} Finally, we have the logout route . Here we have another option of <\"logout\" = $true> , which basically just means to kill the session and redirect to the login page: route 'post' '/logout' ( auth check form -o @{ 'logout' = $true ; 'failureUrl' = '/login' ; }) {}","title":"Server"},{"location":"Tutorials/Routes/LoginPage/#full-server","text":"This is the full code for the server above: Import-Module Pode Server -Thread 2 { listen * : 8080 http # use pode template engine engine pode # setup session middleware middleware ( session @{ 'secret' = 'schwify' ; 'duration' = 120 ; 'extend' = $true ; }) # setup form authentication auth use form -v { param ( $username , $password ) if ( $username -eq 'morty' -and $password -eq 'pickle' ) { return @{ 'user' = @{ 'ID' = 'M0R7Y302' ; 'Name' = 'Morty' ; 'Type' = 'Human' ; } } } # aww geez! no user was found return $null } # the \"GET /\" endpoint for the homepage route get '/' ( auth check form -o @{ 'failureUrl' = '/login' }) { param ( $s ) $s . Session . Data . Views ++ view 'index' -data @{ 'Username' = $s . Auth . User . Name ; 'Views' = $s . Session . Data . Views ; } } # the \"GET /login\" endpoint for the login page route get '/login' ( auth check form -o @{ 'login' = $true ; 'successUrl' = '/' }) { param ( $s ) view 'login' } # the \"POST /login\" endpoint for user authentication route post '/login' ( auth check form -o @{ 'failureUrl' = '/login' ; 'successUrl' = '/' ; }) {} # the \"POST /logout\" endpoint for ending the session route 'post' '/logout' ( auth check form -o @{ 'logout' = $true ; 'failureUrl' = '/login' ; }) {} }","title":"Full Server"},{"location":"Tutorials/Routes/LoginPage/#pages","text":"The following are the web pages used above, as well as the CSS style. The web pages have been created using .pode files, which allows you to embed PowerShell into the files. index.pode < html > < head > < title > Auth Home </ title > < link rel = \"stylesheet\" type = \"text/css\" href = \"/styles/main.css\" > </ head > < body > Hello, $($data.Username)! You have view this page $($data.Views) times! < form action = \"/logout\" method = \"post\" > < div > < input type = \"submit\" value = \"Logout\" /> </ div > </ form > </ body > </ html > login.pode < html > < head > < title > Auth Login </ title > < link rel = \"stylesheet\" type = \"text/css\" href = \"/styles/main.css\" > </ head > < body > Please Login: < form action = \"/login\" method = \"post\" > < div > < label > Username: </ label > < input type = \"text\" name = \"username\" /> </ div > < div > < label > Password: </ label > < input type = \"password\" name = \"password\" /> </ div > < div > < input type = \"submit\" value = \"Login\" /> </ div > </ form > </ body > </ html > styles/main.css body { background-color : rebeccapurple ; }","title":"Pages"},{"location":"Tutorials/Routes/Overview/","text":"Route Overview Routes in Pode allow you to bind logic that should be invoked when a user calls a certain path on a URL, for a specific HTTP method, against your server. Routes allow you to host REST APIs and Web Pages, as well as using custom middleware for things like authentication. You can also specify static routes, that redirect requests to static content to internal directories. Routes can also be bound against a specific protocol or endpoint. This allows you to bind multiple root ( / ) routes against different endpoints - if you're listening to multiple endpoints. Info The following HTTP methods are supported by routes in Pode: DELETE, GET, HEAD, MERGE, OPTIONS, PATCH, POST, PUT, TRACE, and STATIC (for static file routing). Usage To setup and use routes in Pode you should use the route function. The general make-up of the route function is as follows - the former is for HTTP requests, where as the latter is for static content: route < method > < route > [< middleware >] < scriptblock > [ -protocol < string >] [ -endpoint < string >] [ -listenName < string >] [ -remove ] route static < route > < path > [< defaults >] [ -protocol < string >] [ -endpoint < string >] [ -listenName < string >] [ -remove ] # or shorthand: route < method > < route > [< middleware >] < scriptblock > [ -p < string >] [ -e < string >] [ -ln < string >] [ -rm ] route static < route > < path > [< defaults >] [ -p < string >] [ -e < string >] [ -ln < string >] [ -rm ] For example, let's say you want a basic GET /ping endpoint to just return pong as a JSON response: Server { listen * : 8080 http route get '/ping' { json @{ 'value' = 'pong' ; } } } Here, anyone who calls http://localhost:8080/ping will receive the following response: { \"value\" : \"pong\" } The scriptblock for the route will be supplied with a single argument that contains information about the current web event. This argument will contain the Request and Response objects, Data (from POST), and the Query (from the query string of the URL), as well as any Parameters from the route itself (eg: /:accountId ). Payloads The following is an example of using data from a request's payload - ie, the data in the body of POST request. To retrieve values from the payload you can use the .Data hashtable on the supplied web-session to a route's logic. This example will get the userId and \"find\" user, returning the users data: Server { listen * : 8080 http route post '/users' { param ( $s ) # get the user $user = Get-DummyUser -UserId $s . Data [ 'userId' ] # return the user json @{ 'Username' = $user . username ; 'Age' = $user . age ; } } } The following request will invoke the above route: Invoke-WebRequest -Uri 'http://localhost:8080/users' -Method Post -Body '{ \"userId\": 12345 }' -ContentType 'application/json' Important The ContentType is required as it informs Pode on how to parse the requests payload. For example, if the content type were application/json , then Pode will attempt to parse the body of the request as JSON - converting it to a hashtable. Query Strings The following is an example of using data from a request's query string. To retrieve values from the query string you can use the .Query hashtable on the supplied web-session to a route's logic. This example will return a user based on the userId supplied: Server { listen * : 8080 http route get '/users' { param ( $s ) # get the user $user = Get-DummyUser -UserId $s . Query [ 'userId' ] # return the user json @{ 'Username' = $user . username ; 'Age' = $user . age ; } } } The following request will invoke the above route: Invoke-WebRequest -Uri 'http://localhost:8080/users?userId=12345' -Method Get Parameters The following is an example of using values supplied on a request's URL using parameters. To retrieve values that match a request's URL parameters you can use the .Parameters hashtable on the supplied web-session to a route's logic. This example will get the :userId and \"find\" user, returning the users data: Server { listen * : 8080 http route get '/users/:userId' { param ( $s ) # get the user $user = Get-DummyUser -UserId $s . Parameters [ 'userId' ] # return the user json @{ 'Username' = $user . username ; 'Age' = $user . age ; } } } The following request will invoke the above route: Invoke-WebRequest -Uri 'http://localhost:8080/users/12345' -Method Get","title":"Overview"},{"location":"Tutorials/Routes/Overview/#route-overview","text":"Routes in Pode allow you to bind logic that should be invoked when a user calls a certain path on a URL, for a specific HTTP method, against your server. Routes allow you to host REST APIs and Web Pages, as well as using custom middleware for things like authentication. You can also specify static routes, that redirect requests to static content to internal directories. Routes can also be bound against a specific protocol or endpoint. This allows you to bind multiple root ( / ) routes against different endpoints - if you're listening to multiple endpoints. Info The following HTTP methods are supported by routes in Pode: DELETE, GET, HEAD, MERGE, OPTIONS, PATCH, POST, PUT, TRACE, and STATIC (for static file routing).","title":"Route Overview"},{"location":"Tutorials/Routes/Overview/#usage","text":"To setup and use routes in Pode you should use the route function. The general make-up of the route function is as follows - the former is for HTTP requests, where as the latter is for static content: route < method > < route > [< middleware >] < scriptblock > [ -protocol < string >] [ -endpoint < string >] [ -listenName < string >] [ -remove ] route static < route > < path > [< defaults >] [ -protocol < string >] [ -endpoint < string >] [ -listenName < string >] [ -remove ] # or shorthand: route < method > < route > [< middleware >] < scriptblock > [ -p < string >] [ -e < string >] [ -ln < string >] [ -rm ] route static < route > < path > [< defaults >] [ -p < string >] [ -e < string >] [ -ln < string >] [ -rm ] For example, let's say you want a basic GET /ping endpoint to just return pong as a JSON response: Server { listen * : 8080 http route get '/ping' { json @{ 'value' = 'pong' ; } } } Here, anyone who calls http://localhost:8080/ping will receive the following response: { \"value\" : \"pong\" } The scriptblock for the route will be supplied with a single argument that contains information about the current web event. This argument will contain the Request and Response objects, Data (from POST), and the Query (from the query string of the URL), as well as any Parameters from the route itself (eg: /:accountId ).","title":"Usage"},{"location":"Tutorials/Routes/Overview/#payloads","text":"The following is an example of using data from a request's payload - ie, the data in the body of POST request. To retrieve values from the payload you can use the .Data hashtable on the supplied web-session to a route's logic. This example will get the userId and \"find\" user, returning the users data: Server { listen * : 8080 http route post '/users' { param ( $s ) # get the user $user = Get-DummyUser -UserId $s . Data [ 'userId' ] # return the user json @{ 'Username' = $user . username ; 'Age' = $user . age ; } } } The following request will invoke the above route: Invoke-WebRequest -Uri 'http://localhost:8080/users' -Method Post -Body '{ \"userId\": 12345 }' -ContentType 'application/json' Important The ContentType is required as it informs Pode on how to parse the requests payload. For example, if the content type were application/json , then Pode will attempt to parse the body of the request as JSON - converting it to a hashtable.","title":"Payloads"},{"location":"Tutorials/Routes/Overview/#query-strings","text":"The following is an example of using data from a request's query string. To retrieve values from the query string you can use the .Query hashtable on the supplied web-session to a route's logic. This example will return a user based on the userId supplied: Server { listen * : 8080 http route get '/users' { param ( $s ) # get the user $user = Get-DummyUser -UserId $s . Query [ 'userId' ] # return the user json @{ 'Username' = $user . username ; 'Age' = $user . age ; } } } The following request will invoke the above route: Invoke-WebRequest -Uri 'http://localhost:8080/users?userId=12345' -Method Get","title":"Query Strings"},{"location":"Tutorials/Routes/Overview/#parameters","text":"The following is an example of using values supplied on a request's URL using parameters. To retrieve values that match a request's URL parameters you can use the .Parameters hashtable on the supplied web-session to a route's logic. This example will get the :userId and \"find\" user, returning the users data: Server { listen * : 8080 http route get '/users/:userId' { param ( $s ) # get the user $user = Get-DummyUser -UserId $s . Parameters [ 'userId' ] # return the user json @{ 'Username' = $user . username ; 'Age' = $user . age ; } } } The following request will invoke the above route: Invoke-WebRequest -Uri 'http://localhost:8080/users/12345' -Method Get","title":"Parameters"},{"location":"Tutorials/Routes/Redirecting/","text":"Redirecting Sometimes you just want a route to redirect the user else where, be it to another URL or to the same route just a different port/protocol. Usage When in a route , to inform the client to redirect to a different endpoint you can use the redirect function. The make-up of the redirect function is as follows: redirect [ -port < int >] [ -protocol < http | https >] [ -endpoint < string >] [ -moved ] redirect [ -url < string >] [ -moved ] # or shorthand: redirect [ -p < int >] [ -pr < http | https >] [ -e < string >] [ -m ] redirect [ -u < string >] [ -m ] Supplying -url will redirect the user to that URL, or you can supply a relative path o the server for the user to be redirected to. -port and -protocol can be used separately or together, but not with -url . Using -port / -protocol will use the URI of the current web request to generate the redirect URL. By default the redirect function will return a 302 response, but supplying -moved will return a 301 response instead. The following example will redirect the user to Google: Server { listen * : 8080 http route get '/redirect' { redirect -url 'https://google.com' } } The below example will redirect the user to the same host/server, but with a different protocol and port: Server { listen * : 8080 http listen * : 8086 https route get '/redirect' { redirect -port 8086 -protocol https } } This final example will redirect every HTTP request, on every action and route, to https: Server { listen * : 8080 http listen * : 8443 http route * * -p http { redirect -port 8443 -protocol https } }","title":"Redirecting"},{"location":"Tutorials/Routes/Redirecting/#redirecting","text":"Sometimes you just want a route to redirect the user else where, be it to another URL or to the same route just a different port/protocol.","title":"Redirecting"},{"location":"Tutorials/Routes/Redirecting/#usage","text":"When in a route , to inform the client to redirect to a different endpoint you can use the redirect function. The make-up of the redirect function is as follows: redirect [ -port < int >] [ -protocol < http | https >] [ -endpoint < string >] [ -moved ] redirect [ -url < string >] [ -moved ] # or shorthand: redirect [ -p < int >] [ -pr < http | https >] [ -e < string >] [ -m ] redirect [ -u < string >] [ -m ] Supplying -url will redirect the user to that URL, or you can supply a relative path o the server for the user to be redirected to. -port and -protocol can be used separately or together, but not with -url . Using -port / -protocol will use the URI of the current web request to generate the redirect URL. By default the redirect function will return a 302 response, but supplying -moved will return a 301 response instead. The following example will redirect the user to Google: Server { listen * : 8080 http route get '/redirect' { redirect -url 'https://google.com' } } The below example will redirect the user to the same host/server, but with a different protocol and port: Server { listen * : 8080 http listen * : 8086 https route get '/redirect' { redirect -port 8086 -protocol https } } This final example will redirect every HTTP request, on every action and route, to https: Server { listen * : 8080 http listen * : 8443 http route * * -p http { redirect -port 8443 -protocol https } }","title":"Usage"},{"location":"Tutorials/Routes/StaticContent/","text":"Static Content Static content in Pode can be used by either places your static files with the /public directory, or by defining static routes. You can also specify default pages, such as index.html , for when users navigate to root folders. Caching is also supported on static content. Static Routes The following is an example of using the route function to define routes to static content directories; this tells Pode where to get static files from for certain routes. This example will define a static route for /assets , and will point to the route at the internal directory ./content/assets : Server { listen * : 8080 http route static '/assets' './content/assets' } The following request will retrieve an image from the ./content/assets/images directory: Invoke-WebRequest -Uri 'http://localhost:8080/assets/images/icon.png' -Method Get Default Pages For static content, Pode also supports returning default pages when a root static content directory is requested. The inbuilt default pages are: index.html index.htm default.html default.htm These pages are checked in order, and if one is found then its content is returned. Using the above static route from the Static Route section, if the ./content/assets/home directory contained an index.html page, then the following request would return the content for the index.html page: Invoke-WebRequest -Uri 'http://localhost:8080/assets/images/home' -Method Get The default pages can be configured in two ways; either by using the -Defaults parameter on the route function, or by setting them in the pode.json configuration file . To set the defaults to be only a home.html page, both ways would work as follows: Defaults Parameter route static '/assets' './content/assets' -d @( 'home.html' ) Configuration File { \"web\" : { \"static\" : { \"defaults\" : [ \"home.html\" ] } } } Caching Having web pages send requests to your Pode server for all static content every time can be quite a strain on the server. To help the server, you can enable static content caching, which will inform users' browsers to cache files (ie *.css and *.js ) for so many seconds - stopping the browser from re-requesting it from your server each time. By default, caching is disabled and can be enabled and controlled using the pode.json configuration file. To enable caching, with a default cache time of 1hr, you do: { \"web\" : { \"static\" : { \"cache\" : { \"enable\" : true } } } } If you wish to set a max cache time of 30mins, then you would use the maxAge property - setting it to 1800secs : { \"web\" : { \"static\" : { \"cache\" : { \"enable\" : true , \"maxAge\" : 1800 } } } } Include/Exclude Sometimes you don't want all static content to be cached, maybe you want *.exe files to always be re-requested? This is possible using the include and exclude properties in the pode.json . Let's say you do want to exclude all *.exe files from being cached: { \"web\" : { \"static\" : { \"cache\" : { \"enable\" : true , \"exclude\" : [ \"*.exe\" ] } } } } Or, you could setup some static routes called /assets and /images , and you want everything on /images to be cached, but only *.js files to be cached on /assets : { \"web\" : { \"static\" : { \"cache\" : { \"enable\" : true , \"include\" : [ \"/images/*\" , \"/assets/*.js\" ] } } } }","title":"Static Content"},{"location":"Tutorials/Routes/StaticContent/#static-content","text":"Static content in Pode can be used by either places your static files with the /public directory, or by defining static routes. You can also specify default pages, such as index.html , for when users navigate to root folders. Caching is also supported on static content.","title":"Static Content"},{"location":"Tutorials/Routes/StaticContent/#static-routes","text":"The following is an example of using the route function to define routes to static content directories; this tells Pode where to get static files from for certain routes. This example will define a static route for /assets , and will point to the route at the internal directory ./content/assets : Server { listen * : 8080 http route static '/assets' './content/assets' } The following request will retrieve an image from the ./content/assets/images directory: Invoke-WebRequest -Uri 'http://localhost:8080/assets/images/icon.png' -Method Get","title":"Static Routes"},{"location":"Tutorials/Routes/StaticContent/#default-pages","text":"For static content, Pode also supports returning default pages when a root static content directory is requested. The inbuilt default pages are: index.html index.htm default.html default.htm These pages are checked in order, and if one is found then its content is returned. Using the above static route from the Static Route section, if the ./content/assets/home directory contained an index.html page, then the following request would return the content for the index.html page: Invoke-WebRequest -Uri 'http://localhost:8080/assets/images/home' -Method Get The default pages can be configured in two ways; either by using the -Defaults parameter on the route function, or by setting them in the pode.json configuration file . To set the defaults to be only a home.html page, both ways would work as follows: Defaults Parameter route static '/assets' './content/assets' -d @( 'home.html' ) Configuration File { \"web\" : { \"static\" : { \"defaults\" : [ \"home.html\" ] } } }","title":"Default Pages"},{"location":"Tutorials/Routes/StaticContent/#caching","text":"Having web pages send requests to your Pode server for all static content every time can be quite a strain on the server. To help the server, you can enable static content caching, which will inform users' browsers to cache files (ie *.css and *.js ) for so many seconds - stopping the browser from re-requesting it from your server each time. By default, caching is disabled and can be enabled and controlled using the pode.json configuration file. To enable caching, with a default cache time of 1hr, you do: { \"web\" : { \"static\" : { \"cache\" : { \"enable\" : true } } } } If you wish to set a max cache time of 30mins, then you would use the maxAge property - setting it to 1800secs : { \"web\" : { \"static\" : { \"cache\" : { \"enable\" : true , \"maxAge\" : 1800 } } } }","title":"Caching"},{"location":"Tutorials/Routes/StaticContent/#includeexclude","text":"Sometimes you don't want all static content to be cached, maybe you want *.exe files to always be re-requested? This is possible using the include and exclude properties in the pode.json . Let's say you do want to exclude all *.exe files from being cached: { \"web\" : { \"static\" : { \"cache\" : { \"enable\" : true , \"exclude\" : [ \"*.exe\" ] } } } } Or, you could setup some static routes called /assets and /images , and you want everything on /images to be cached, but only *.js files to be cached on /assets : { \"web\" : { \"static\" : { \"cache\" : { \"enable\" : true , \"include\" : [ \"/images/*\" , \"/assets/*.js\" ] } } } }","title":"Include/Exclude"},{"location":"Tutorials/Routes/WebPages/","text":"Creating a Web Page Serving up web pages via Pode is simple, you can either write your pages in HTML, Pode, another template engine; then place those files within the /views directory. You can also use CSS, JavaScript, Images, etc. and place those files within the /public directory. Basics To serve up a web page you use the view function, and if you're using a dynamic template (like .pode files) to render you views you use the engine function. When you use the view function to serve a web page, the path to the view must be relative to the /views directory. For example, the following will display the /views/index.html page: Server { listen * : 8080 http route get '/' { view 'index' } } Info If your web page references any CSS, JavaScript, etc. files, then Pode will automatically find them within the /public directory - or any relative static routes you may have defined. For example, if you reference <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/simple.css\"> in your HTML file, then Pode will look for /public/styles/simple.css . Full Example Here we'll have two simple HTML pages, with a CSS file and a simple server script. The directory structure is as follows: server.ps1 /views index.html about.html /public /stylyes main.css server.ps1 Server { listen * : 8080 http route get '/' { view 'index' } route get '/about' { view 'about' } } index.html < html > < head > < title > Home Page </ title > < link rel = \"stylesheet\" type = \"text/css\" href = \"/styles/main.css\" > </ head > < body > < h1 > Hello, world! </ h1 > < p > Welcome to my very simple home page! </ p > < p > To know more about me, < a href = \"/about\" > click here </ a > ! </ p > </ body > </ html > about.html < html > < head > < title > About Me </ title > < link rel = \"stylesheet\" type = \"text/css\" href = \"/styles/main.css\" > </ head > < body > < h1 > About Me </ h1 > < p > My name is Rick Sanchez </ p > < p > Wubba lubba dub dub!! </ p > < p > To go back home, < a href = \"/\" > click here </ a > . </ p > </ body > </ html > styles/main.css body { background-color : rebeccapurple ; }","title":"Web Pages"},{"location":"Tutorials/Routes/WebPages/#creating-a-web-page","text":"Serving up web pages via Pode is simple, you can either write your pages in HTML, Pode, another template engine; then place those files within the /views directory. You can also use CSS, JavaScript, Images, etc. and place those files within the /public directory.","title":"Creating a Web Page"},{"location":"Tutorials/Routes/WebPages/#basics","text":"To serve up a web page you use the view function, and if you're using a dynamic template (like .pode files) to render you views you use the engine function. When you use the view function to serve a web page, the path to the view must be relative to the /views directory. For example, the following will display the /views/index.html page: Server { listen * : 8080 http route get '/' { view 'index' } } Info If your web page references any CSS, JavaScript, etc. files, then Pode will automatically find them within the /public directory - or any relative static routes you may have defined. For example, if you reference <link rel=\"stylesheet\" type=\"text/css\" href=\"/styles/simple.css\"> in your HTML file, then Pode will look for /public/styles/simple.css .","title":"Basics"},{"location":"Tutorials/Routes/WebPages/#full-example","text":"Here we'll have two simple HTML pages, with a CSS file and a simple server script. The directory structure is as follows: server.ps1 /views index.html about.html /public /stylyes main.css server.ps1 Server { listen * : 8080 http route get '/' { view 'index' } route get '/about' { view 'about' } } index.html < html > < head > < title > Home Page </ title > < link rel = \"stylesheet\" type = \"text/css\" href = \"/styles/main.css\" > </ head > < body > < h1 > Hello, world! </ h1 > < p > Welcome to my very simple home page! </ p > < p > To know more about me, < a href = \"/about\" > click here </ a > ! </ p > </ body > </ html > about.html < html > < head > < title > About Me </ title > < link rel = \"stylesheet\" type = \"text/css\" href = \"/styles/main.css\" > </ head > < body > < h1 > About Me </ h1 > < p > My name is Rick Sanchez </ p > < p > Wubba lubba dub dub!! </ p > < p > To go back home, < a href = \"/\" > click here </ a > . </ p > </ body > </ html > styles/main.css body { background-color : rebeccapurple ; }","title":"Full Example"},{"location":"Tutorials/ServerRestarting/AutoRestarting/","text":"Auto-Restarting You can schedule automatic server restarts by using the server.restart section within your pode.json configuration file. You can schedule server restarts in 3 ways: Periodic : A single value that defines after how many minutes the server should restart. Times : An array of times that define at which times each day the server should restart. Cron Expressions : An array of cron expression that define when the server should restart. The section in your pode.json file could look as follows (you can define 1 or all): { \"server\" : { \"restart\" : { \"period\" : 180 , \"times\" : [ \"09:00\" , \"21:00\" ], \"crons\" : [ \"@hourly\" , \"30 14 * * TUE\" ] } } } Periodic Periodic server restarts are defined using a single value, which is the number of minutes to wait before triggering a server restart. For example, if you wanted to restart your server every 6hrs, then you could add the following to your pode.json file: { \"server\" : { \"restart\" : { \"period\" : 360 } } } Note The period starts from the moment the server is started. Times Server restarts can be fined by the time of day, this is an array of times each day to restart your server. For example, if you wanted to restart your server at 09:45 and 21:15 every day, then you could add the following to your pode.json file: { \"server\" : { \"restart\" : { \"times\" : [ \"09:45\" , \"21:15\" ] } } } Cron Expressions To further advance timed and periodic server restarts, you can also define when a restart should occur by using an array of cron expressions . For example, should you want to restart your server on every Tuesday and Friday at 12:00, then you could add the following to your pode.json file: { \"server\" : { \"restart\" : { \"crons\" : [ \"0 12 * * TUE,FRI\" ] } } }","title":"Auto-Restarting"},{"location":"Tutorials/ServerRestarting/AutoRestarting/#auto-restarting","text":"You can schedule automatic server restarts by using the server.restart section within your pode.json configuration file. You can schedule server restarts in 3 ways: Periodic : A single value that defines after how many minutes the server should restart. Times : An array of times that define at which times each day the server should restart. Cron Expressions : An array of cron expression that define when the server should restart. The section in your pode.json file could look as follows (you can define 1 or all): { \"server\" : { \"restart\" : { \"period\" : 180 , \"times\" : [ \"09:00\" , \"21:00\" ], \"crons\" : [ \"@hourly\" , \"30 14 * * TUE\" ] } } }","title":"Auto-Restarting"},{"location":"Tutorials/ServerRestarting/AutoRestarting/#periodic","text":"Periodic server restarts are defined using a single value, which is the number of minutes to wait before triggering a server restart. For example, if you wanted to restart your server every 6hrs, then you could add the following to your pode.json file: { \"server\" : { \"restart\" : { \"period\" : 360 } } } Note The period starts from the moment the server is started.","title":"Periodic"},{"location":"Tutorials/ServerRestarting/AutoRestarting/#times","text":"Server restarts can be fined by the time of day, this is an array of times each day to restart your server. For example, if you wanted to restart your server at 09:45 and 21:15 every day, then you could add the following to your pode.json file: { \"server\" : { \"restart\" : { \"times\" : [ \"09:45\" , \"21:15\" ] } } }","title":"Times"},{"location":"Tutorials/ServerRestarting/AutoRestarting/#cron-expressions","text":"To further advance timed and periodic server restarts, you can also define when a restart should occur by using an array of cron expressions . For example, should you want to restart your server on every Tuesday and Friday at 12:00, then you could add the following to your pode.json file: { \"server\" : { \"restart\" : { \"crons\" : [ \"0 12 * * TUE,FRI\" ] } } }","title":"Cron Expressions"},{"location":"Tutorials/ServerRestarting/FileMonitoring/","text":"File Monitoring Pode has support for file monitoring which can trigger the server restart, this occurs if Pode detects any file changes within the root directory of your server's script. To enable file monitoring you can either use the -FileMonitor switch on your server script, or enable it through the pode.json configuration file as follows: Server { # logic } -FileMonitor or: { \"server\" : { \"fileMonitor\" : { \"enable\" : true } } } Once enabled, Pode will actively monitor all file changes made within the root directory of your script. For example, if your script was at C:/Apps/Pode/server.ps1 , then Pode will monitor the C:/Apps/Pode directory and all sub-directories/files for changes (exclusions can be configured, see below). When a change is detected, Pode will wait 2 seconds before initiating the restart - this is so multiple rapid file changes don't trigger multiple restarts. The file changes which are being monitored by Pode are: Updates Creation Deletion Important If you change the main server script itself, the changes will not be picked up. It's best to import/dot-source other modules/scripts into your server script, as the internal restart re-invokes this scriptblock . If you do make changes to the main server script, you'll need to terminate the server first and then restart it. Include/Exclude You can include/exclude paths/files/extensions from triggering a server restart. To include specific paths/files you can use the -FileMonitorInclude parameter on your server , and to exclude you can use the -FileMonitorExclude parameter. You can also configure them within the pode.json configuration file. Both of the parameters are arrays, and the values should be patterns for paths/files/extensions - for paths, they should always be from the root directory of your server. For example, to state that all txt and ps1 files should only trigger restarts, you would do: Server { # logic } -FileMonitor -FileMonitorInclude @( '*.txt' , '*.ps1' ) or: { \"server\" : { \"fileMonitor\" : { \"enable\" : true , \"include\" : [ \"*.txt\" , \"*.ps1\" ] } } } And to state that changes within the public directory should not trigger a restart, you would do: Server { # logic } -FileMonitor -FileMonitorExclude @( 'public/*' ) or: { \"server\" : { \"fileMonitor\" : { \"enable\" : true , \"exclude\" : [ \"public/*\" ] } } }","title":"File Monitoring"},{"location":"Tutorials/ServerRestarting/FileMonitoring/#file-monitoring","text":"Pode has support for file monitoring which can trigger the server restart, this occurs if Pode detects any file changes within the root directory of your server's script. To enable file monitoring you can either use the -FileMonitor switch on your server script, or enable it through the pode.json configuration file as follows: Server { # logic } -FileMonitor or: { \"server\" : { \"fileMonitor\" : { \"enable\" : true } } } Once enabled, Pode will actively monitor all file changes made within the root directory of your script. For example, if your script was at C:/Apps/Pode/server.ps1 , then Pode will monitor the C:/Apps/Pode directory and all sub-directories/files for changes (exclusions can be configured, see below). When a change is detected, Pode will wait 2 seconds before initiating the restart - this is so multiple rapid file changes don't trigger multiple restarts. The file changes which are being monitored by Pode are: Updates Creation Deletion Important If you change the main server script itself, the changes will not be picked up. It's best to import/dot-source other modules/scripts into your server script, as the internal restart re-invokes this scriptblock . If you do make changes to the main server script, you'll need to terminate the server first and then restart it.","title":"File Monitoring"},{"location":"Tutorials/ServerRestarting/FileMonitoring/#includeexclude","text":"You can include/exclude paths/files/extensions from triggering a server restart. To include specific paths/files you can use the -FileMonitorInclude parameter on your server , and to exclude you can use the -FileMonitorExclude parameter. You can also configure them within the pode.json configuration file. Both of the parameters are arrays, and the values should be patterns for paths/files/extensions - for paths, they should always be from the root directory of your server. For example, to state that all txt and ps1 files should only trigger restarts, you would do: Server { # logic } -FileMonitor -FileMonitorInclude @( '*.txt' , '*.ps1' ) or: { \"server\" : { \"fileMonitor\" : { \"enable\" : true , \"include\" : [ \"*.txt\" , \"*.ps1\" ] } } } And to state that changes within the public directory should not trigger a restart, you would do: Server { # logic } -FileMonitor -FileMonitorExclude @( 'public/*' ) or: { \"server\" : { \"fileMonitor\" : { \"enable\" : true , \"exclude\" : [ \"public/*\" ] } } }","title":"Include/Exclude"},{"location":"Tutorials/ServerRestarting/Overview/","text":"Restarting Overview There are 3 ways to restart a running Pode server: Ctrl+R : If you press Ctrl+R on a running server, it will trigger a restart to take place. File Monitoring : This will watch for file changes, and if enabled will trigger the server to restart. Auto-Restarting : Defined within the pode.json configuration file, you can set schedules for the server to automatically restart. When the server restarts, it will re-invoke the scripblock supplied to the server function. This means the best approach to reload new modules/scripts it to dot-source your scripts into your server , as any changes to the main scriptblock will not take place.","title":"Overview"},{"location":"Tutorials/ServerRestarting/Overview/#restarting-overview","text":"There are 3 ways to restart a running Pode server: Ctrl+R : If you press Ctrl+R on a running server, it will trigger a restart to take place. File Monitoring : This will watch for file changes, and if enabled will trigger the server to restart. Auto-Restarting : Defined within the pode.json configuration file, you can set schedules for the server to automatically restart. When the server restarts, it will re-invoke the scripblock supplied to the server function. This means the best approach to reload new modules/scripts it to dot-source your scripts into your server , as any changes to the main scriptblock will not take place.","title":"Restarting Overview"},{"location":"Tutorials/ViewEngines/Pode/","text":"Pode Files Pode has an inbuilt dynamic file type of .pode , which allow you to write normal file but use PowerShell within them. For view files the naming convention is just index.pode or about.pode . However for non-view files in the /public directory the convention is style.css.pode - which includes the files base file type. Views Using Pode to render dynamic view files is mostly just using normal HTML, but with the insertion of PowerShell - in fact, you could write pure HTML in a .pode file and it will still work. The difference is that you're able to embed PowerShell logic into the file, which allows you to dynamically generate HTML. To use .pode files for views, you will need to place them within the /views directory; then you'll need to set the View Engine to be Pode. Once set, you can just write view responses as per normal: Server { listen * : 8080 http # set the engine to use and render Pode files engine pode # render the index.pode in the /views directory route get '/' { view 'index' } } Info Any PowerShell in a .pode files will need to be wrapped in $(...) and each line must end with a semi-colon. Below is a basic example of a .pode view file, which just writes the current date to the browser: <!-- /views/index.pode --> < html > < head > < title > Current Date </ title > </ head > < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > Any data supplied to the view function when rendering .pode files will make them far more dynamic. The data supplied to view must be a hashtable , and can be referenced from within the file by using the $data argument. For example, say you need to render a search page which is a list of accounts filtered by some query; then your basic server script could look like the following: Server { listen * : 8080 http # set the engine to use and render .pode files engine pode # render the search.pode view route get '/' { param ( $event ) # some logic to get accounts $query = $event . Query [ 'query' ] $accounts = Find-Account -Query $query # render the file view 'search' -Data @{ 'query' = $query ; 'accounts' = $accounts ; } } } You can see that we're supplying the found accounts to the view function as a hashtable . Next, we see the search.pode view file which generates the HTML: <!-- /views/search.pode --> < html > < head > < title > Search </ title > </ head > < body > < h1 > Search </ h1 > Query: $($data.query;) < div > $(foreach ($account in $data.accounts) { \" < div > Name: $($account.Name) </ div >< hr /> \"; }) </ div > </ body > </ html > Remember, you can access supplied data by using $data This next quick example allows you to include content from another view: <!-- /views/index.pode --> < html > $(include shared/head) < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > <!-- /views/shared/head.pode --> < head > < title > Include Example </ title > </ head > Non-Views The rules for using .pode files for other non-view file types, like css/js files, work exactly like the above view files but they're placed within the /public directory instead of the /views directory. You also need to specify the actual file type in the extension, for example: /public/styles/main.css.pode /public/scripts/main.js.pode Here you'll see the main extension is .pode , but you need to specify a sub-extension of the main file type such as .css - this helps Pode work out the main content type when writing to the response. Below is a .css.pode file that will render the page in purple on even seconds, or red on odd seconds: /* /public/styles/main.css.pode */ body { $( $date = [DateTime]::UtcNow ; if ($date.Second % 2 -eq 0) { \" background-color : rebeccapurple ; \" ; } else { \" background-color : red ; \" ; } ) } To load the above .css.pode file in a view file: <!-- /views/index.pode --> < html > < head > < link rel = \"stylesheet\" href = \"/styles/main.css.pode\" > </ head > < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html >","title":"Pode"},{"location":"Tutorials/ViewEngines/Pode/#pode-files","text":"Pode has an inbuilt dynamic file type of .pode , which allow you to write normal file but use PowerShell within them. For view files the naming convention is just index.pode or about.pode . However for non-view files in the /public directory the convention is style.css.pode - which includes the files base file type.","title":"Pode Files"},{"location":"Tutorials/ViewEngines/Pode/#views","text":"Using Pode to render dynamic view files is mostly just using normal HTML, but with the insertion of PowerShell - in fact, you could write pure HTML in a .pode file and it will still work. The difference is that you're able to embed PowerShell logic into the file, which allows you to dynamically generate HTML. To use .pode files for views, you will need to place them within the /views directory; then you'll need to set the View Engine to be Pode. Once set, you can just write view responses as per normal: Server { listen * : 8080 http # set the engine to use and render Pode files engine pode # render the index.pode in the /views directory route get '/' { view 'index' } } Info Any PowerShell in a .pode files will need to be wrapped in $(...) and each line must end with a semi-colon. Below is a basic example of a .pode view file, which just writes the current date to the browser: <!-- /views/index.pode --> < html > < head > < title > Current Date </ title > </ head > < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > Any data supplied to the view function when rendering .pode files will make them far more dynamic. The data supplied to view must be a hashtable , and can be referenced from within the file by using the $data argument. For example, say you need to render a search page which is a list of accounts filtered by some query; then your basic server script could look like the following: Server { listen * : 8080 http # set the engine to use and render .pode files engine pode # render the search.pode view route get '/' { param ( $event ) # some logic to get accounts $query = $event . Query [ 'query' ] $accounts = Find-Account -Query $query # render the file view 'search' -Data @{ 'query' = $query ; 'accounts' = $accounts ; } } } You can see that we're supplying the found accounts to the view function as a hashtable . Next, we see the search.pode view file which generates the HTML: <!-- /views/search.pode --> < html > < head > < title > Search </ title > </ head > < body > < h1 > Search </ h1 > Query: $($data.query;) < div > $(foreach ($account in $data.accounts) { \" < div > Name: $($account.Name) </ div >< hr /> \"; }) </ div > </ body > </ html > Remember, you can access supplied data by using $data This next quick example allows you to include content from another view: <!-- /views/index.pode --> < html > $(include shared/head) < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > <!-- /views/shared/head.pode --> < head > < title > Include Example </ title > </ head >","title":"Views"},{"location":"Tutorials/ViewEngines/Pode/#non-views","text":"The rules for using .pode files for other non-view file types, like css/js files, work exactly like the above view files but they're placed within the /public directory instead of the /views directory. You also need to specify the actual file type in the extension, for example: /public/styles/main.css.pode /public/scripts/main.js.pode Here you'll see the main extension is .pode , but you need to specify a sub-extension of the main file type such as .css - this helps Pode work out the main content type when writing to the response. Below is a .css.pode file that will render the page in purple on even seconds, or red on odd seconds: /* /public/styles/main.css.pode */ body { $( $date = [DateTime]::UtcNow ; if ($date.Second % 2 -eq 0) { \" background-color : rebeccapurple ; \" ; } else { \" background-color : red ; \" ; } ) } To load the above .css.pode file in a view file: <!-- /views/index.pode --> < html > < head > < link rel = \"stylesheet\" href = \"/styles/main.css.pode\" > </ head > < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html >","title":"Non-Views"},{"location":"Tutorials/ViewEngines/ThirdParty/","text":"Third Party Engines Pode supports the use of third-party view engines, for example you could use the EPS or PSHTML template engines. To do this, you'll need to supply a custom scriptblock to the engine function which tells Pode how use the third-party engine. This custom scriptblock will be supplied with two arguments: $path : The path to the file that needs generating using your chosen template engine $data : Any data that was supplied to the view function EPS If you were to use EPS engine, and already have the module installed, then the following server example would work for views and static content: Server { listen * : 8080 http # import the EPS module into the runspaces import eps # set the engine to use and render EPS files # (could be index.eps, or for content scripts.css.eps) engine eps { param ( $path , $data ) if ( $null -eq $data ) { return ( Invoke-EpsTemplate -Path $path ) } else { return ( Invoke-EpsTemplate -Path $path -Binding $data ) } } # render the index.eps view route get '/' { view 'index' } } The following example structure could be used for the views and static content: /views index.eps /public styles/main.css.eps scripts/main.js.eps PSHTML If you were to use PSHTML engine, and already have the module installed, then the following server example would work for views and static content: Server { listen * : 8080 http # import the PSHTML module into the runspaces import pshtml # set the engine to use and render PSHTML (which are just ps1) files # (could be index.ps1, or for content scripts.css.ps1) engine ps1 { param ( $path , $data ) return [string] (. $path $data ) } # render the index.eps view route get '/' { view 'index' } } The following example structure could be used for the views and static content: /views index.ps1 /public styles/main.css.ps1 scripts/main.js.ps1","title":"Third Party"},{"location":"Tutorials/ViewEngines/ThirdParty/#third-party-engines","text":"Pode supports the use of third-party view engines, for example you could use the EPS or PSHTML template engines. To do this, you'll need to supply a custom scriptblock to the engine function which tells Pode how use the third-party engine. This custom scriptblock will be supplied with two arguments: $path : The path to the file that needs generating using your chosen template engine $data : Any data that was supplied to the view function","title":"Third Party Engines"},{"location":"Tutorials/ViewEngines/ThirdParty/#eps","text":"If you were to use EPS engine, and already have the module installed, then the following server example would work for views and static content: Server { listen * : 8080 http # import the EPS module into the runspaces import eps # set the engine to use and render EPS files # (could be index.eps, or for content scripts.css.eps) engine eps { param ( $path , $data ) if ( $null -eq $data ) { return ( Invoke-EpsTemplate -Path $path ) } else { return ( Invoke-EpsTemplate -Path $path -Binding $data ) } } # render the index.eps view route get '/' { view 'index' } } The following example structure could be used for the views and static content: /views index.eps /public styles/main.css.eps scripts/main.js.eps","title":"EPS"},{"location":"Tutorials/ViewEngines/ThirdParty/#pshtml","text":"If you were to use PSHTML engine, and already have the module installed, then the following server example would work for views and static content: Server { listen * : 8080 http # import the PSHTML module into the runspaces import pshtml # set the engine to use and render PSHTML (which are just ps1) files # (could be index.ps1, or for content scripts.css.ps1) engine ps1 { param ( $path , $data ) return [string] (. $path $data ) } # render the index.eps view route get '/' { view 'index' } } The following example structure could be used for the views and static content: /views index.ps1 /public styles/main.css.ps1 scripts/main.js.ps1","title":"PSHTML"}]}