{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Pode is a Cross-Platform PowerShell framework that allows you to host REST APIs, Web Pages and SMTP/TCP servers. It also allows you to render dynamic files using .pode files, which is effectively embedded PowerShell, or other Third-Party template engines. Pode also has support for middleware, sessions, and authentication; as well as access and rate limiting features. Features Can run on Unix environments using PowerShell Core Host REST APIs and Web Pages Host TCP and SMTP server - great for tests and mocking Multiple threads can be used to response to incoming requests Use the full power of PowerShell, want a REST API for NUnit? Go for it! Ability to write dynamic files in PowerShell using Pode, or other third-party template engines Can use yarn package manager to install bootstrap, or other frontend libraries Setup async timers to be used as one off tasks, or for housekeeping services Ability to schedule async tasks using cron expressions Supports logging to CLI, Files, and custom loggers to other services like LogStash, etc. Cross-state runspace variable access for timers, routes and loggers Optional file monitoring to trigger internal server restart on file changes Ability to allow/deny requests from certain IP addresses and subnets Basic rate limiting for IP addresses and subnets Support for generating/binding self-signed certificates, and binding signed certificates Support for middleware on web servers Session middleware support on web requests Can use authentication on requests, which can either be sessionless or session persistant","title":"Home"},{"location":"#welcome","text":"Pode is a Cross-Platform PowerShell framework that allows you to host REST APIs, Web Pages and SMTP/TCP servers. It also allows you to render dynamic files using .pode files, which is effectively embedded PowerShell, or other Third-Party template engines. Pode also has support for middleware, sessions, and authentication; as well as access and rate limiting features.","title":"Welcome"},{"location":"#features","text":"Can run on Unix environments using PowerShell Core Host REST APIs and Web Pages Host TCP and SMTP server - great for tests and mocking Multiple threads can be used to response to incoming requests Use the full power of PowerShell, want a REST API for NUnit? Go for it! Ability to write dynamic files in PowerShell using Pode, or other third-party template engines Can use yarn package manager to install bootstrap, or other frontend libraries Setup async timers to be used as one off tasks, or for housekeeping services Ability to schedule async tasks using cron expressions Supports logging to CLI, Files, and custom loggers to other services like LogStash, etc. Cross-state runspace variable access for timers, routes and loggers Optional file monitoring to trigger internal server restart on file changes Ability to allow/deny requests from certain IP addresses and subnets Basic rate limiting for IP addresses and subnets Support for generating/binding self-signed certificates, and binding signed certificates Support for middleware on web servers Session middleware support on web requests Can use authentication on requests, which can either be sessionless or session persistant","title":"Features"},{"location":"navigation/","text":"Table of Contents Getting Started Installation CLI Docker Frontend Tutorials Routes Functions Attach Engine Listen Server Status View","title":"Table of Contents"},{"location":"navigation/#table-of-contents","text":"","title":"Table of Contents"},{"location":"navigation/#getting-started","text":"Installation CLI Docker Frontend","title":"Getting Started"},{"location":"navigation/#tutorials","text":"Routes","title":"Tutorials"},{"location":"navigation/#functions","text":"Attach Engine Listen Server Status View","title":"Functions"},{"location":"Functions/Attach/","text":"Attach Description The attach function allows you to attach files in the /public directory onto the web response. This allows the files to be downloaded by the end-user. Examples Example 1 The following example attaches the installer found at /public/downloads/installer.exe onto the response, when the http://localhost:8080/app/install endpoint is hit: Server { listen * : 8080 http route get '/app/install' { attach 'downloads/installer.exe' } } Parameters Name Type Required Description Default Path string true The path to the file to attach, relative to your /public directory null","title":"Attach"},{"location":"Functions/Attach/#attach","text":"","title":"Attach"},{"location":"Functions/Attach/#description","text":"The attach function allows you to attach files in the /public directory onto the web response. This allows the files to be downloaded by the end-user.","title":"Description"},{"location":"Functions/Attach/#examples","text":"","title":"Examples"},{"location":"Functions/Attach/#example-1","text":"The following example attaches the installer found at /public/downloads/installer.exe onto the response, when the http://localhost:8080/app/install endpoint is hit: Server { listen * : 8080 http route get '/app/install' { attach 'downloads/installer.exe' } }","title":"Example 1"},{"location":"Functions/Attach/#parameters","text":"Name Type Required Description Default Path string true The path to the file to attach, relative to your /public directory null","title":"Parameters"},{"location":"Functions/Csv/","text":"Csv Description The csv function converts an array of hashtable values, or reads in a file, and converts it to a CSV; the value is then written to the web response. You can also supply raw CSV data as the value to write. Examples Example 1 The following example will convert an array of hashtable values to a CSV and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { csv @( @{ 'Name' = 'Bob' ; 'Age' = 29 }, @{ 'Name' = 'James' ; 'Age' = 23 }) } } Example 2 The following example will write raw CSV data to a web response within a route : Server { listen * : 8080 http route get '/info' { csv \"Name, Age `n Bob, 29 `n James, 23\" } } Example 3 The following example will read in a file, and write the contents as CSV to a web response within a route : Server { listen * : 8080 http route get '/data' { csv -file './files/data.csv' } } Parameters Name Type Required Description Default Value hashtable[]/string true The value should either be an array of hashtable values or string - the string can be either a path or raw CSV. It will be converted to CSV, if not raw, and attached to the web response null File switch false If passed, the value should be a string that's a path to a CSV file false","title":"Csv"},{"location":"Functions/Csv/#csv","text":"","title":"Csv"},{"location":"Functions/Csv/#description","text":"The csv function converts an array of hashtable values, or reads in a file, and converts it to a CSV; the value is then written to the web response. You can also supply raw CSV data as the value to write.","title":"Description"},{"location":"Functions/Csv/#examples","text":"","title":"Examples"},{"location":"Functions/Csv/#example-1","text":"The following example will convert an array of hashtable values to a CSV and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { csv @( @{ 'Name' = 'Bob' ; 'Age' = 29 }, @{ 'Name' = 'James' ; 'Age' = 23 }) } }","title":"Example 1"},{"location":"Functions/Csv/#example-2","text":"The following example will write raw CSV data to a web response within a route : Server { listen * : 8080 http route get '/info' { csv \"Name, Age `n Bob, 29 `n James, 23\" } }","title":"Example 2"},{"location":"Functions/Csv/#example-3","text":"The following example will read in a file, and write the contents as CSV to a web response within a route : Server { listen * : 8080 http route get '/data' { csv -file './files/data.csv' } }","title":"Example 3"},{"location":"Functions/Csv/#parameters","text":"Name Type Required Description Default Value hashtable[]/string true The value should either be an array of hashtable values or string - the string can be either a path or raw CSV. It will be converted to CSV, if not raw, and attached to the web response null File switch false If passed, the value should be a string that's a path to a CSV file false","title":"Parameters"},{"location":"Functions/Dispose/","text":"Dispose Description The dispose function takes a disposable object and will optionally close the object, and then dispose of the object. Examples Example 1 The following example takes a StreamReader , and then closes and disposes of the object: Server { $reader = [System.IO.StreamReader] :: new ( $stream ) # logic that uses the reader dispose $reader -close } Parameters Name Type Required Description Default InputObject IDisposable true A disposable object that will be optionally closed, and then disposed null Close switch false If passed, the object will first be closed before being disposed false CheckNetwork switch false If passed, any exceptions thrown will be checked; if they are one of the validated network errors the exception will be ignored false Info The network errors ignored by the -CheckNetwork flag are: network name is no longer available nonexistent network connection broken pipe","title":"Dispose"},{"location":"Functions/Dispose/#dispose","text":"","title":"Dispose"},{"location":"Functions/Dispose/#description","text":"The dispose function takes a disposable object and will optionally close the object, and then dispose of the object.","title":"Description"},{"location":"Functions/Dispose/#examples","text":"","title":"Examples"},{"location":"Functions/Dispose/#example-1","text":"The following example takes a StreamReader , and then closes and disposes of the object: Server { $reader = [System.IO.StreamReader] :: new ( $stream ) # logic that uses the reader dispose $reader -close }","title":"Example 1"},{"location":"Functions/Dispose/#parameters","text":"Name Type Required Description Default InputObject IDisposable true A disposable object that will be optionally closed, and then disposed null Close switch false If passed, the object will first be closed before being disposed false CheckNetwork switch false If passed, any exceptions thrown will be checked; if they are one of the validated network errors the exception will be ignored false Info The network errors ignored by the -CheckNetwork flag are: network name is no longer available nonexistent network connection broken pipe","title":"Parameters"},{"location":"Functions/Endware/","text":"Endware Description The endware function allows you to add endware scripts, that run after all middleware and route logic - even if a middleware has ended the pipeline early. They allow you to do things like logging, further data storage, etc. Endware in Pode allows you to observe the request/response objects at the very end of the middleware/route pipeline for a current web request. This way you will have the most up-to-date information on the objects for any logging you may wish to perform. Info Unlike middleware which has a return value to halt execution, each endware will run in turn without the need for returning anything. So if there are 4 endware configured and 1 fails in the middle, the other later ones will still run. Examples Example 1 The following example is endware that observes the content length of the response, as well as the status code, and records them in some custom data storage for later analysis: Server { endware { param ( $session ) $status = $session . Response . StatusCode $length = $session . Response . ContentLength64 Save-ContentStatus -ContentLength $length -Status $status } } Parameters Name Type Required Description Default ScriptBlock scriptblock true The main logic for the endware; this scriptblock will be supplied a single parameter which contains the Request and Response objects null","title":"Endware"},{"location":"Functions/Endware/#endware","text":"","title":"Endware"},{"location":"Functions/Endware/#description","text":"The endware function allows you to add endware scripts, that run after all middleware and route logic - even if a middleware has ended the pipeline early. They allow you to do things like logging, further data storage, etc. Endware in Pode allows you to observe the request/response objects at the very end of the middleware/route pipeline for a current web request. This way you will have the most up-to-date information on the objects for any logging you may wish to perform. Info Unlike middleware which has a return value to halt execution, each endware will run in turn without the need for returning anything. So if there are 4 endware configured and 1 fails in the middle, the other later ones will still run.","title":"Description"},{"location":"Functions/Endware/#examples","text":"","title":"Examples"},{"location":"Functions/Endware/#example-1","text":"The following example is endware that observes the content length of the response, as well as the status code, and records them in some custom data storage for later analysis: Server { endware { param ( $session ) $status = $session . Response . StatusCode $length = $session . Response . ContentLength64 Save-ContentStatus -ContentLength $length -Status $status } }","title":"Example 1"},{"location":"Functions/Endware/#parameters","text":"Name Type Required Description Default ScriptBlock scriptblock true The main logic for the endware; this scriptblock will be supplied a single parameter which contains the Request and Response objects null","title":"Parameters"},{"location":"Functions/Engine/","text":"Engine Description The engine function allows you to specify the engine used to render view and content templates. You can also specify a third-party engine to use, such as EPS . Info If you don't use the engine function, then the defaut of HTML will be used Examples Example 1 The following example will render views and content using the Pode template engine (such as the index.pode view or the style.css.pode public content file): Server { engine pode } Example 2 The following example will use the third-party engine EPS to render views (such as the index.eps view or the style.css.eps public content file): Server { engine eps { param ( $path , $data ) return Invoke-EpsTemplate -Path $path -Binding $data } } Parameters Name Type Required Description Default Engine string true The type of engine to use, can be either HTML, Pode, or a custom third-party type - the value passed should be the extension used by the engine HTML ScriptBlock scriptblock false When using a third-party template engine, the ScriptBlock is required as it tells Pode how to render views/static content using the engine null","title":"Engine"},{"location":"Functions/Engine/#engine","text":"","title":"Engine"},{"location":"Functions/Engine/#description","text":"The engine function allows you to specify the engine used to render view and content templates. You can also specify a third-party engine to use, such as EPS . Info If you don't use the engine function, then the defaut of HTML will be used","title":"Description"},{"location":"Functions/Engine/#examples","text":"","title":"Examples"},{"location":"Functions/Engine/#example-1","text":"The following example will render views and content using the Pode template engine (such as the index.pode view or the style.css.pode public content file): Server { engine pode }","title":"Example 1"},{"location":"Functions/Engine/#example-2","text":"The following example will use the third-party engine EPS to render views (such as the index.eps view or the style.css.eps public content file): Server { engine eps { param ( $path , $data ) return Invoke-EpsTemplate -Path $path -Binding $data } }","title":"Example 2"},{"location":"Functions/Engine/#parameters","text":"Name Type Required Description Default Engine string true The type of engine to use, can be either HTML, Pode, or a custom third-party type - the value passed should be the extension used by the engine HTML ScriptBlock scriptblock false When using a third-party template engine, the ScriptBlock is required as it tells Pode how to render views/static content using the engine null","title":"Parameters"},{"location":"Functions/Html/","text":"Html Description The html function reads in an HTML file and then writes to content the web response. You can also supply raw HTML data as the value to write. Examples Example 1 The following example will write raw HTML data to a web response within a route : Server { listen * : 8080 http route get '/info' { html '<html><head><title>Example</title></head><body>Hello, world!</body></html>' } } Example 2 The following example will read in a file, and write the contents as HTML to a web response within a route : Server { listen * : 8080 http route get '/data' { html -file './files/data.html' } } Parameters Name Type Required Description Default Value string true The value should be a string, of either a path or raw HTML. It will be attached to the web response null File switch false If passed, the above value should be a string that's a path to an HTML file false","title":"Html"},{"location":"Functions/Html/#html","text":"","title":"Html"},{"location":"Functions/Html/#description","text":"The html function reads in an HTML file and then writes to content the web response. You can also supply raw HTML data as the value to write.","title":"Description"},{"location":"Functions/Html/#examples","text":"","title":"Examples"},{"location":"Functions/Html/#example-1","text":"The following example will write raw HTML data to a web response within a route : Server { listen * : 8080 http route get '/info' { html '<html><head><title>Example</title></head><body>Hello, world!</body></html>' } }","title":"Example 1"},{"location":"Functions/Html/#example-2","text":"The following example will read in a file, and write the contents as HTML to a web response within a route : Server { listen * : 8080 http route get '/data' { html -file './files/data.html' } }","title":"Example 2"},{"location":"Functions/Html/#parameters","text":"Name Type Required Description Default Value string true The value should be a string, of either a path or raw HTML. It will be attached to the web response null File switch false If passed, the above value should be a string that's a path to an HTML file false","title":"Parameters"},{"location":"Functions/Include/","text":"Include Description The include function can only be used within a .pode view file; it allows you to include other views (html/pode/other) into a main view. This way you can have shared partial views (like headers, footers or navigation), and include them into your main views. Examples Example 1 The following example will include a header partial view file into below example index.pode file: <!-- /views/index.pode --> < html > $(include shared/head) < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > <!-- /views/shared/head.pode --> < head > < title > Include Example </ title > </ head > Example 2 The following example will include the header partial view file, but this time will supply some dynamic data: <!-- /views/index.pode --> < html > $(include shared/head -d @{ 'PageName' = 'Index' }) < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > <!-- /views/shared/head.pode --> < head > < title > Page: $($data.PageName) </ title > </ head > Parameters Name Type Required Description Default Path string true The path to the view that should be included, relative to the /views directory empty Data hashtable false A hashtable of dynamic data that will be supplied to .pode , and other third-party template engine, view files @{}","title":"Include"},{"location":"Functions/Include/#include","text":"","title":"Include"},{"location":"Functions/Include/#description","text":"The include function can only be used within a .pode view file; it allows you to include other views (html/pode/other) into a main view. This way you can have shared partial views (like headers, footers or navigation), and include them into your main views.","title":"Description"},{"location":"Functions/Include/#examples","text":"","title":"Examples"},{"location":"Functions/Include/#example-1","text":"The following example will include a header partial view file into below example index.pode file: <!-- /views/index.pode --> < html > $(include shared/head) < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > <!-- /views/shared/head.pode --> < head > < title > Include Example </ title > </ head >","title":"Example 1"},{"location":"Functions/Include/#example-2","text":"The following example will include the header partial view file, but this time will supply some dynamic data: <!-- /views/index.pode --> < html > $(include shared/head -d @{ 'PageName' = 'Index' }) < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > <!-- /views/shared/head.pode --> < head > < title > Page: $($data.PageName) </ title > </ head >","title":"Example 2"},{"location":"Functions/Include/#parameters","text":"Name Type Required Description Default Path string true The path to the view that should be included, relative to the /views directory empty Data hashtable false A hashtable of dynamic data that will be supplied to .pode , and other third-party template engine, view files @{}","title":"Parameters"},{"location":"Functions/Json/","text":"Json Description The json function converts a hashtable , or reads in a file, and converts it to JSON; the JSON value is then written to the web response. You can also supply raw JSON data as the value to write. Examples Example 1 The following example will convert a hashtable to JSON and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { json @{ 'cpu' = 80 ; 'memory' = 15 ; } } } Example 2 The following example will write raw JSON data to a web response within a route : Server { listen * : 8080 http route get '/info' { json '{ \"cpu\": 80, \"memory\": 15 }' } } Example 3 The following example will read in a file, and write the contents as JSON to a web response within a route : Server { listen * : 8080 http route get '/data' { json -file './files/data.json' } } Parameters Name Type Required Description Default Value hashtable/string false The value should either be a hashtable or string - the string can be either a path or raw JSON. It will be converted to JSON, if not raw, and attached to the web response null File switch false If passed, the value should be a string that's a path to a JSON file false","title":"Json"},{"location":"Functions/Json/#json","text":"","title":"Json"},{"location":"Functions/Json/#description","text":"The json function converts a hashtable , or reads in a file, and converts it to JSON; the JSON value is then written to the web response. You can also supply raw JSON data as the value to write.","title":"Description"},{"location":"Functions/Json/#examples","text":"","title":"Examples"},{"location":"Functions/Json/#example-1","text":"The following example will convert a hashtable to JSON and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { json @{ 'cpu' = 80 ; 'memory' = 15 ; } } }","title":"Example 1"},{"location":"Functions/Json/#example-2","text":"The following example will write raw JSON data to a web response within a route : Server { listen * : 8080 http route get '/info' { json '{ \"cpu\": 80, \"memory\": 15 }' } }","title":"Example 2"},{"location":"Functions/Json/#example-3","text":"The following example will read in a file, and write the contents as JSON to a web response within a route : Server { listen * : 8080 http route get '/data' { json -file './files/data.json' } }","title":"Example 3"},{"location":"Functions/Json/#parameters","text":"Name Type Required Description Default Value hashtable/string false The value should either be a hashtable or string - the string can be either a path or raw JSON. It will be converted to JSON, if not raw, and attached to the web response null File switch false If passed, the value should be a string that's a path to a JSON file false","title":"Parameters"},{"location":"Functions/Listen/","text":"Listen Description The listen function allows you to specify the IP, Port and Protocol that your Server will listen on. If the protocol is https then you can also specify a certificate to bind, even having Pode create a self-signed certificate for you. Examples Example 1 The following example will listen on every IP over port 8080 for HTTP requests: Server { listen * : 8080 http } Info This will setup a web server and will require a route to be configured Example 2 The following example will listen on localhost over port 25 for SMTP requests: Server { listen 127 . 0 . 0 . 1 : 25 smtp } Info This will setup an SMTP server and will require a handler to be configured Example 3 The following example will listen on a specific IP address over port 8443 for HTTPS requests; it will also inform Pode to create and bind a self-signed certificate to the IP:Port: Server { listen 10 . 10 . 1 . 4 : 8443 https -cert self } Info This will setup a web server and will require a route to be configured Parameters Name Type Required Description Default IPPort string true The IP:Port combination that the server should listen on null Type string true The type of server: HTTP, HTTPS, SMTP, TCP null Cert string false The certificate to bind to the IP:Port. If the certificate is self then Pode will create a self-signed certificate. If the certificate is *.example.com then it must be installed to Cert:/LocalMachine/My null","title":"Listen"},{"location":"Functions/Listen/#listen","text":"","title":"Listen"},{"location":"Functions/Listen/#description","text":"The listen function allows you to specify the IP, Port and Protocol that your Server will listen on. If the protocol is https then you can also specify a certificate to bind, even having Pode create a self-signed certificate for you.","title":"Description"},{"location":"Functions/Listen/#examples","text":"","title":"Examples"},{"location":"Functions/Listen/#example-1","text":"The following example will listen on every IP over port 8080 for HTTP requests: Server { listen * : 8080 http } Info This will setup a web server and will require a route to be configured","title":"Example 1"},{"location":"Functions/Listen/#example-2","text":"The following example will listen on localhost over port 25 for SMTP requests: Server { listen 127 . 0 . 0 . 1 : 25 smtp } Info This will setup an SMTP server and will require a handler to be configured","title":"Example 2"},{"location":"Functions/Listen/#example-3","text":"The following example will listen on a specific IP address over port 8443 for HTTPS requests; it will also inform Pode to create and bind a self-signed certificate to the IP:Port: Server { listen 10 . 10 . 1 . 4 : 8443 https -cert self } Info This will setup a web server and will require a route to be configured","title":"Example 3"},{"location":"Functions/Listen/#parameters","text":"Name Type Required Description Default IPPort string true The IP:Port combination that the server should listen on null Type string true The type of server: HTTP, HTTPS, SMTP, TCP null Cert string false The certificate to bind to the IP:Port. If the certificate is self then Pode will create a self-signed certificate. If the certificate is *.example.com then it must be installed to Cert:/LocalMachine/My null","title":"Parameters"},{"location":"Functions/Lock/","text":"Lock Description The lock function takes an object that will be locked so that it is threadsafe. The supplied ScriptBlock will be invoked within the scope of the locked object. Tip The session object supplied to a route , timer , schedule and logger each contain a .Lockable resource that can be supplied to the lock function. Examples Example 1 The following example will lock an object, and increment a counter on the session and write it to the response in a threadsafe scope: Server { listen * : 8080 http route get '/count' { param ( $s ) lock $s . Lockable { $s . Session . Data . Views ++ json @{ 'Views' = $s . Session . Data . Views } } } } Parameters Name Type Required Description Default InputObject object true The object to lock, so that it is threadsafe within the supplied ScriptBlock null ScriptBlock scriptblock true The logic that will utilise the locked object null","title":"Lock"},{"location":"Functions/Lock/#lock","text":"","title":"Lock"},{"location":"Functions/Lock/#description","text":"The lock function takes an object that will be locked so that it is threadsafe. The supplied ScriptBlock will be invoked within the scope of the locked object. Tip The session object supplied to a route , timer , schedule and logger each contain a .Lockable resource that can be supplied to the lock function.","title":"Description"},{"location":"Functions/Lock/#examples","text":"","title":"Examples"},{"location":"Functions/Lock/#example-1","text":"The following example will lock an object, and increment a counter on the session and write it to the response in a threadsafe scope: Server { listen * : 8080 http route get '/count' { param ( $s ) lock $s . Lockable { $s . Session . Data . Views ++ json @{ 'Views' = $s . Session . Data . Views } } } }","title":"Example 1"},{"location":"Functions/Lock/#parameters","text":"Name Type Required Description Default InputObject object true The object to lock, so that it is threadsafe within the supplied ScriptBlock null ScriptBlock scriptblock true The logic that will utilise the locked object null","title":"Parameters"},{"location":"Functions/Middleware/","text":"Middleware Description The middleware function allows you to add middleware scripts, that run prior to route logic. They allow you to do things like rate-limiting, access restriction, sessions, etc. Middleware in Pode allows you to observe and edit the request/response objects for a current web request - you can alter the response, add custom objects to the request for later use, or terminate the response without processing the route logic. Examples Example 1 The following example is middleware that observes the user agent of the request. If the request comes from a PowerShell session then stop processing and return forbidden, otherwise create a new Agent key on the session for later middleware / route : Server { middleware { param ( $session ) if ( $session . Request . UserAgent -ilike '*powershell*' ) { status 403 return $false } $session . Agent = $session . Request . UserAgent return $true } } Example 2 The following example uses rate limiting, and defines middleware that will override the inbuilt rate limiting middleware logic so that it never limits requests: Server { listen * : 8080 http limit ip @( '127.0.0.1' , '[::1]' ) 8 5 middleware -Name '@limit' { return $true } route get '/' { # logic } } Parameters Name Type Required Description Default ScriptBlock scriptblock true The main logic for the middleware; this scriptblock will be supplied a single parameter which contains the Request and Response objects null Name string false Only use this parameter if you plan to override any of the inbuilt middleware. Names for the inbuilt middleware can be found below empty Notes Middleware in Pode is executed in a specific order due to having inbuilt middleware, this order of running is as follows: Access control - allowing/denying IP addresses (if access logic is defined) Rate limiting - limiting access to IP addresses (if limit logic is defined) Public content - content such as images/css/js in the public directory Body parsing - parsing request payload a JSON or XML Querystring - getting any query string parameters currently on the request URL Custom middleware - runs any defined middleware in the order it was created Route middleware - runs any route middleware for the current route being processed Route - finally, the route itself is processed Pode has some inbuilt middleware, as defined in the order of running above. Sometimes you probably don't want to use the inbuilt rate limiting, and use a custom rate limiting library that utilises REDIS instead. Each of the inbuilt middlewares have a defined name, that you can pass to the middleware function via -Name : Access control - @access Rate limiting - @limit Public content - @public Body parsing - @body Querystring - @query An example of overriding the inbuilt middleware can be found in the examples above","title":"Middleware"},{"location":"Functions/Middleware/#middleware","text":"","title":"Middleware"},{"location":"Functions/Middleware/#description","text":"The middleware function allows you to add middleware scripts, that run prior to route logic. They allow you to do things like rate-limiting, access restriction, sessions, etc. Middleware in Pode allows you to observe and edit the request/response objects for a current web request - you can alter the response, add custom objects to the request for later use, or terminate the response without processing the route logic.","title":"Description"},{"location":"Functions/Middleware/#examples","text":"","title":"Examples"},{"location":"Functions/Middleware/#example-1","text":"The following example is middleware that observes the user agent of the request. If the request comes from a PowerShell session then stop processing and return forbidden, otherwise create a new Agent key on the session for later middleware / route : Server { middleware { param ( $session ) if ( $session . Request . UserAgent -ilike '*powershell*' ) { status 403 return $false } $session . Agent = $session . Request . UserAgent return $true } }","title":"Example 1"},{"location":"Functions/Middleware/#example-2","text":"The following example uses rate limiting, and defines middleware that will override the inbuilt rate limiting middleware logic so that it never limits requests: Server { listen * : 8080 http limit ip @( '127.0.0.1' , '[::1]' ) 8 5 middleware -Name '@limit' { return $true } route get '/' { # logic } }","title":"Example 2"},{"location":"Functions/Middleware/#parameters","text":"Name Type Required Description Default ScriptBlock scriptblock true The main logic for the middleware; this scriptblock will be supplied a single parameter which contains the Request and Response objects null Name string false Only use this parameter if you plan to override any of the inbuilt middleware. Names for the inbuilt middleware can be found below empty","title":"Parameters"},{"location":"Functions/Middleware/#notes","text":"Middleware in Pode is executed in a specific order due to having inbuilt middleware, this order of running is as follows: Access control - allowing/denying IP addresses (if access logic is defined) Rate limiting - limiting access to IP addresses (if limit logic is defined) Public content - content such as images/css/js in the public directory Body parsing - parsing request payload a JSON or XML Querystring - getting any query string parameters currently on the request URL Custom middleware - runs any defined middleware in the order it was created Route middleware - runs any route middleware for the current route being processed Route - finally, the route itself is processed Pode has some inbuilt middleware, as defined in the order of running above. Sometimes you probably don't want to use the inbuilt rate limiting, and use a custom rate limiting library that utilises REDIS instead. Each of the inbuilt middlewares have a defined name, that you can pass to the middleware function via -Name : Access control - @access Rate limiting - @limit Public content - @public Body parsing - @body Querystring - @query An example of overriding the inbuilt middleware can be found in the examples above","title":"Notes"},{"location":"Functions/Redirect/","text":"Redirect Description The redirect function allows you to specify a URL to which to redirect the enduser. You can either specify a raw or relative URL, or alter the current request URI's port/protocol - such as redirecting from HTTP to HTTPS. Examples Example 1 The following example will redirect the enduser to https://google.com : Server { listen * : 8080 http route get '/google' { redirect -url 'https://google.com' } } Example 2 Assuming the current request URI is http://localhost:8080 , then the following example will redirect the enduser to http://localhost:8090 : Server { listen * : 8080 http route get '/' { redirect -port 8090 } } Example 3 Assuming the current request URI is http://localhost:8080 , then the following example will redirect the enduser to https://localhost:8080 : Server { listen * : 8080 http route get '/' { redirect -protocol https } } Example 4 The following example will redirect every method and route to https: Server { listen * : 8080 http route * * { redirect -protocol https } } Parameters Name Type Required Description Default Url string false The raw, or relative, URL to which the enduser should be redirected empty Port int false If no URL is supplied, then the redirect will be based on the current request URI's port. This parameter will override the current port of the request URI 0 Protocol string false If no URL is supplied, then the redirect will be based on the current request URI's protocol. This parameter will override the current protocol of the request URI (Values: Empty, HTTP, HTTPS) empty Moved switch false If flagged, the redirect will be done as a 301 Moved status, rather than a 302 Redirect false","title":"Redirect"},{"location":"Functions/Redirect/#redirect","text":"","title":"Redirect"},{"location":"Functions/Redirect/#description","text":"The redirect function allows you to specify a URL to which to redirect the enduser. You can either specify a raw or relative URL, or alter the current request URI's port/protocol - such as redirecting from HTTP to HTTPS.","title":"Description"},{"location":"Functions/Redirect/#examples","text":"","title":"Examples"},{"location":"Functions/Redirect/#example-1","text":"The following example will redirect the enduser to https://google.com : Server { listen * : 8080 http route get '/google' { redirect -url 'https://google.com' } }","title":"Example 1"},{"location":"Functions/Redirect/#example-2","text":"Assuming the current request URI is http://localhost:8080 , then the following example will redirect the enduser to http://localhost:8090 : Server { listen * : 8080 http route get '/' { redirect -port 8090 } }","title":"Example 2"},{"location":"Functions/Redirect/#example-3","text":"Assuming the current request URI is http://localhost:8080 , then the following example will redirect the enduser to https://localhost:8080 : Server { listen * : 8080 http route get '/' { redirect -protocol https } }","title":"Example 3"},{"location":"Functions/Redirect/#example-4","text":"The following example will redirect every method and route to https: Server { listen * : 8080 http route * * { redirect -protocol https } }","title":"Example 4"},{"location":"Functions/Redirect/#parameters","text":"Name Type Required Description Default Url string false The raw, or relative, URL to which the enduser should be redirected empty Port int false If no URL is supplied, then the redirect will be based on the current request URI's port. This parameter will override the current port of the request URI 0 Protocol string false If no URL is supplied, then the redirect will be based on the current request URI's protocol. This parameter will override the current protocol of the request URI (Values: Empty, HTTP, HTTPS) empty Moved switch false If flagged, the redirect will be done as a 301 Moved status, rather than a 302 Redirect false","title":"Parameters"},{"location":"Functions/Route/","text":"Route Description The route function allows you to bind specific logic to be invoked against a URL path and HTTP method. The function also accepts custom middleware to be executed, before running the main route logic - such as authentication. Info The scriptblock for the main route logic is invoked with a single parameter. This parameter will contain the Request and Response objects; Data (from POST requests), and the Query (from the query string of the URL), as well as any Parameters from the route itself (eg: /:accountId ). Examples Example 1 The following example sets up a GET /ping route, that returns value: pong : Server { listen * : 8080 http route get '/ping' { json @{ 'value' = 'ping' } } } Example 2 The following example sets up a POST /users route, that creates a new user using post data: Server { listen * : 8080 http route post '/users' { param ( $session ) # create the user using POST data $userId = New-DummyUser $session . Data . Email $session . Data . Name $session . Data . Password # return with userId json @{ 'userId' = $userId ; } } } Example 3 The following example sets up a GET /users/:userId route, that returns a user based on the route parameter userId : Server { listen * : 8080 http route get '/users/:userId' { param ( $session ) # get the user, using the parameter userId $user = Get-DummyUser -UserId $session . Parameters [ 'userId' ] # if no user, return 404 if ( $user -eq $null ) { status 404 } # return the user object json @{ 'user' = $user ; } } } Example 4 The following example sets up a GET / route, that has custom middleware to check the user agent first. If the user agent is from PowerShell deny the call, and don't invoke the route's logic: Server { listen * : 8080 http $agent_mid = { param ( $session ) if ( $session . Request . UserAgent -ilike '*powershell*' ) { status 403 # stop running return $false } $session . Agent = $session . Request . UserAgent # run the route logic return $true } route get '/' $agent_mid { view 'index' } } Parameters Name Type Required Description Default HttpMethod string true The HTTP method to bind the route onto (Values: DELETE, GET, HEAD, MERGE, OPTIONS, PATCH, POST, PUT, TRACE) null Route string true The route path to listen on, the root path is / . The path can also contain parmeters such as /:userId empty Middleware scriptblock[] false Custom middleware for the route that will be invoked before the main logic is invoked - such as authentication null ScriptBlock scriptblock true The main route logic that will be invoked when the route endpoint is hit null Tip There is a special * method you can use, which means a route that applies to every HTTP method","title":"Route"},{"location":"Functions/Route/#route","text":"","title":"Route"},{"location":"Functions/Route/#description","text":"The route function allows you to bind specific logic to be invoked against a URL path and HTTP method. The function also accepts custom middleware to be executed, before running the main route logic - such as authentication. Info The scriptblock for the main route logic is invoked with a single parameter. This parameter will contain the Request and Response objects; Data (from POST requests), and the Query (from the query string of the URL), as well as any Parameters from the route itself (eg: /:accountId ).","title":"Description"},{"location":"Functions/Route/#examples","text":"","title":"Examples"},{"location":"Functions/Route/#example-1","text":"The following example sets up a GET /ping route, that returns value: pong : Server { listen * : 8080 http route get '/ping' { json @{ 'value' = 'ping' } } }","title":"Example 1"},{"location":"Functions/Route/#example-2","text":"The following example sets up a POST /users route, that creates a new user using post data: Server { listen * : 8080 http route post '/users' { param ( $session ) # create the user using POST data $userId = New-DummyUser $session . Data . Email $session . Data . Name $session . Data . Password # return with userId json @{ 'userId' = $userId ; } } }","title":"Example 2"},{"location":"Functions/Route/#example-3","text":"The following example sets up a GET /users/:userId route, that returns a user based on the route parameter userId : Server { listen * : 8080 http route get '/users/:userId' { param ( $session ) # get the user, using the parameter userId $user = Get-DummyUser -UserId $session . Parameters [ 'userId' ] # if no user, return 404 if ( $user -eq $null ) { status 404 } # return the user object json @{ 'user' = $user ; } } }","title":"Example 3"},{"location":"Functions/Route/#example-4","text":"The following example sets up a GET / route, that has custom middleware to check the user agent first. If the user agent is from PowerShell deny the call, and don't invoke the route's logic: Server { listen * : 8080 http $agent_mid = { param ( $session ) if ( $session . Request . UserAgent -ilike '*powershell*' ) { status 403 # stop running return $false } $session . Agent = $session . Request . UserAgent # run the route logic return $true } route get '/' $agent_mid { view 'index' } }","title":"Example 4"},{"location":"Functions/Route/#parameters","text":"Name Type Required Description Default HttpMethod string true The HTTP method to bind the route onto (Values: DELETE, GET, HEAD, MERGE, OPTIONS, PATCH, POST, PUT, TRACE) null Route string true The route path to listen on, the root path is / . The path can also contain parmeters such as /:userId empty Middleware scriptblock[] false Custom middleware for the route that will be invoked before the main logic is invoked - such as authentication null ScriptBlock scriptblock true The main route logic that will be invoked when the route endpoint is hit null Tip There is a special * method you can use, which means a route that applies to every HTTP method","title":"Parameters"},{"location":"Functions/Schedule/","text":"Schedule Description The schedule function lets you create long-running async tasks. Unlike a timer however, when a schedule is triggered it's logic is run in its own runspace - so they don't affect each other if they take a while to process. Schedule triggers are defined using cron expressions , basic syntax is supported as well as some predefined expressions. They can start immediately, have a delayed start time, and also have a a defined end time. Examples Example 1 The following example will create a schedule that triggers every Tuesday at midnight: Server { schedule 'tuesdays' '0 0 * * TUE' { # logic } } Example 2 The following example will create a schedule that triggers every 5 past the hour, starting in 2hrs: Server { schedule 'hourly-start' '5 * * * *' -start ( [DateTime] :: Now . AddHours ( 2 )) { # logic } } Example 3 The following example will create a schedule using a predefined cron to trigger every minute: Server { schedule 'minutely' '@minutely' { # logic } } Parameters Name Type Required Description Default Name string true A unique name for the schedule empty Cron string true A cron expression to define when the schedule should trigger empty ScriptBlock scriptblock true The main logic that will be invoked on each trigger null StartTime datetime false Defines when the schedule should start now EndTime datetime false Defines when the schedule should end never","title":"Schedule"},{"location":"Functions/Schedule/#schedule","text":"","title":"Schedule"},{"location":"Functions/Schedule/#description","text":"The schedule function lets you create long-running async tasks. Unlike a timer however, when a schedule is triggered it's logic is run in its own runspace - so they don't affect each other if they take a while to process. Schedule triggers are defined using cron expressions , basic syntax is supported as well as some predefined expressions. They can start immediately, have a delayed start time, and also have a a defined end time.","title":"Description"},{"location":"Functions/Schedule/#examples","text":"","title":"Examples"},{"location":"Functions/Schedule/#example-1","text":"The following example will create a schedule that triggers every Tuesday at midnight: Server { schedule 'tuesdays' '0 0 * * TUE' { # logic } }","title":"Example 1"},{"location":"Functions/Schedule/#example-2","text":"The following example will create a schedule that triggers every 5 past the hour, starting in 2hrs: Server { schedule 'hourly-start' '5 * * * *' -start ( [DateTime] :: Now . AddHours ( 2 )) { # logic } }","title":"Example 2"},{"location":"Functions/Schedule/#example-3","text":"The following example will create a schedule using a predefined cron to trigger every minute: Server { schedule 'minutely' '@minutely' { # logic } }","title":"Example 3"},{"location":"Functions/Schedule/#parameters","text":"Name Type Required Description Default Name string true A unique name for the schedule empty Cron string true A cron expression to define when the schedule should trigger empty ScriptBlock scriptblock true The main logic that will be invoked on each trigger null StartTime datetime false Defines when the schedule should start now EndTime datetime false Defines when the schedule should end never","title":"Parameters"},{"location":"Functions/Server/","text":"Server Description The Server function is the most important function throughout all of Pode, as it's the only function that is mandatory in your scripts. Within the scriptblock supplied to the Server is where you place all of your main server logic - routes, timers, middleware, etc. Warning You can only have one Server declared within your script Examples Example 1 The following example will run the scriptblock once, printing out Hello, world! , and then exit: Server { Write-Host 'Hello, world!' } Example 2 The following will start a server that repeats the scriptblock every 5 seconds: Server -Interval 5 { Write-Host 'Hey!' } Example 3 The following server will accept web requests, and handle them across 2 threads rather than 1: Server -Thread 2 { # route logic } Example 4 The following server will restart when it detects a file has been changed. Ie, if you start the server and then alter a web page, or change a dot-sourced script, then the server will restart: Server -FileMonitor { # route logic } Parameters Name Type Required Description Default ScriptBlock scriptblock true The main closure that contains the core server logic null Interval int false Specifies, in seconds, the time to sleep before looping the ScriptBlock logic 0 Threads int false Specifies the number of runspaces used to handle incoming requests 1 DisableTermination switch false Toggles the ability to allow using Ctrl+C to terminate the server false DisableLogging switch false Toggles any logging that has been setup. When true all logging is disabled false FileMonitor switch false When passed, any file changes will cause the server to restart false","title":"Server"},{"location":"Functions/Server/#server","text":"","title":"Server"},{"location":"Functions/Server/#description","text":"The Server function is the most important function throughout all of Pode, as it's the only function that is mandatory in your scripts. Within the scriptblock supplied to the Server is where you place all of your main server logic - routes, timers, middleware, etc. Warning You can only have one Server declared within your script","title":"Description"},{"location":"Functions/Server/#examples","text":"","title":"Examples"},{"location":"Functions/Server/#example-1","text":"The following example will run the scriptblock once, printing out Hello, world! , and then exit: Server { Write-Host 'Hello, world!' }","title":"Example 1"},{"location":"Functions/Server/#example-2","text":"The following will start a server that repeats the scriptblock every 5 seconds: Server -Interval 5 { Write-Host 'Hey!' }","title":"Example 2"},{"location":"Functions/Server/#example-3","text":"The following server will accept web requests, and handle them across 2 threads rather than 1: Server -Thread 2 { # route logic }","title":"Example 3"},{"location":"Functions/Server/#example-4","text":"The following server will restart when it detects a file has been changed. Ie, if you start the server and then alter a web page, or change a dot-sourced script, then the server will restart: Server -FileMonitor { # route logic }","title":"Example 4"},{"location":"Functions/Server/#parameters","text":"Name Type Required Description Default ScriptBlock scriptblock true The main closure that contains the core server logic null Interval int false Specifies, in seconds, the time to sleep before looping the ScriptBlock logic 0 Threads int false Specifies the number of runspaces used to handle incoming requests 1 DisableTermination switch false Toggles the ability to allow using Ctrl+C to terminate the server false DisableLogging switch false Toggles any logging that has been setup. When true all logging is disabled false FileMonitor switch false When passed, any file changes will cause the server to restart false","title":"Parameters"},{"location":"Functions/Session/","text":"Session Description The session function creates and returns a middleware that enables session cookies. Session middleware attaches onto web requests/responses, and uses signed-cookies and server-side data storage. When configured, the middleware will check for a session-cookie on the request; if a cookie is not found on the request, or the session is not in the store, then a new session is created and attached to the response. If there is a session, then the appropriate data is loaded from the store. The age of the session-cookie can be specified (and whether to extend the duration each time), as well as a secret-key to sign cookies, and the ability to specify custom data stores - the default is in-memory, so custom stores could be anything like redis/mongo. Examples Example 1 The following example sets up basic session middleware, using a secret key and a 5min fixed duration: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; }) } Example 2 The following example sets up session middleware with a non-default cookie name, and a sliding 5min duration: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; 'Extend' = $true ; 'Name' = 'session.id' ; }) } Example 3 The following example sets up session middleware with a custom SessionId script generator; to use a random filename instead of a guid: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; 'GenerateId' = { return [System.IO.Path] :: GetRandomFileName () } }) } Example 4 The following example sets up basic session middleware, and defines a route that adds data to the session. Each subsequent call to the route will increment the views counter: Server { listen * : 8080 http middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; }) route get '/' { $param ( $s ) $s . Session . Data . Views ++ json @{ 'Views' = $s . Session . Data . Views } } } Parameters Note The session function takes a single hashtable as its parameter. The below parameters are the expected keys that should be present within the supplied parameter Name Type Required Description Default Secret string true The secret key used to sign the cookies empty Name string false The name of the session cookie pode.sid Duration int false The duration of which the cookie lasts, in seconds (>=0) 0 Extend bool false If true, the duration of the cookie will be extended each time a request is made using the session false Discard bool false If true, informs the enduser's browser to discard the cookie on expiry false Secure bool false If true, informs the enduser's browser to only send the cookie on secure connections false GenerateId scriptblock false A script that should return a valid string. The string itself should be a random unique value, that can be used as a session identifier guid Store psobject false An object that defines specific functions to communicate with a custom data store null Notes Stores A store should be a psobject that requires the following functions: [hashtable] Get ( [string] $sessionId ) [void] Set ( [string] $sessionId , [hashtable] $data , [datetime] $expiry ) [void] Delete ( [string] $sessionId )","title":"Session"},{"location":"Functions/Session/#session","text":"","title":"Session"},{"location":"Functions/Session/#description","text":"The session function creates and returns a middleware that enables session cookies. Session middleware attaches onto web requests/responses, and uses signed-cookies and server-side data storage. When configured, the middleware will check for a session-cookie on the request; if a cookie is not found on the request, or the session is not in the store, then a new session is created and attached to the response. If there is a session, then the appropriate data is loaded from the store. The age of the session-cookie can be specified (and whether to extend the duration each time), as well as a secret-key to sign cookies, and the ability to specify custom data stores - the default is in-memory, so custom stores could be anything like redis/mongo.","title":"Description"},{"location":"Functions/Session/#examples","text":"","title":"Examples"},{"location":"Functions/Session/#example-1","text":"The following example sets up basic session middleware, using a secret key and a 5min fixed duration: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; }) }","title":"Example 1"},{"location":"Functions/Session/#example-2","text":"The following example sets up session middleware with a non-default cookie name, and a sliding 5min duration: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; 'Extend' = $true ; 'Name' = 'session.id' ; }) }","title":"Example 2"},{"location":"Functions/Session/#example-3","text":"The following example sets up session middleware with a custom SessionId script generator; to use a random filename instead of a guid: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; 'GenerateId' = { return [System.IO.Path] :: GetRandomFileName () } }) }","title":"Example 3"},{"location":"Functions/Session/#example-4","text":"The following example sets up basic session middleware, and defines a route that adds data to the session. Each subsequent call to the route will increment the views counter: Server { listen * : 8080 http middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; }) route get '/' { $param ( $s ) $s . Session . Data . Views ++ json @{ 'Views' = $s . Session . Data . Views } } }","title":"Example 4"},{"location":"Functions/Session/#parameters","text":"Note The session function takes a single hashtable as its parameter. The below parameters are the expected keys that should be present within the supplied parameter Name Type Required Description Default Secret string true The secret key used to sign the cookies empty Name string false The name of the session cookie pode.sid Duration int false The duration of which the cookie lasts, in seconds (>=0) 0 Extend bool false If true, the duration of the cookie will be extended each time a request is made using the session false Discard bool false If true, informs the enduser's browser to discard the cookie on expiry false Secure bool false If true, informs the enduser's browser to only send the cookie on secure connections false GenerateId scriptblock false A script that should return a valid string. The string itself should be a random unique value, that can be used as a session identifier guid Store psobject false An object that defines specific functions to communicate with a custom data store null","title":"Parameters"},{"location":"Functions/Session/#notes","text":"","title":"Notes"},{"location":"Functions/Session/#stores","text":"A store should be a psobject that requires the following functions: [hashtable] Get ( [string] $sessionId ) [void] Set ( [string] $sessionId , [hashtable] $data , [datetime] $expiry ) [void] Delete ( [string] $sessionId )","title":"Stores"},{"location":"Functions/Status/","text":"Status Description The status function allows you to specify a specific status code, and optional a status description. Examples Example 1 The following example sets the status code of the response to be 404: Server { listen * : 8080 http route get '/missing' { status 404 } } Example 2 The following example sets the status code and description of the response to be 500: Server { listen * : 8080 http route get '/error' { status 500 'Oh no! Something went wrong!' } } Parameters Name Type Required Description Default Code int true The status code to set on the web response 0 Description string false The status description to set on the response empty","title":"Status"},{"location":"Functions/Status/#status","text":"","title":"Status"},{"location":"Functions/Status/#description","text":"The status function allows you to specify a specific status code, and optional a status description.","title":"Description"},{"location":"Functions/Status/#examples","text":"","title":"Examples"},{"location":"Functions/Status/#example-1","text":"The following example sets the status code of the response to be 404: Server { listen * : 8080 http route get '/missing' { status 404 } }","title":"Example 1"},{"location":"Functions/Status/#example-2","text":"The following example sets the status code and description of the response to be 500: Server { listen * : 8080 http route get '/error' { status 500 'Oh no! Something went wrong!' } }","title":"Example 2"},{"location":"Functions/Status/#parameters","text":"Name Type Required Description Default Code int true The status code to set on the web response 0 Description string false The status description to set on the response empty","title":"Parameters"},{"location":"Functions/Stopwatch/","text":"Stopwatch Description The stopwatch function lets you wrap logic in a scriptblock, and have the amount of time the logic took to execute outputted to the CLI. Examples Example 1 The following example will wrap a stopwatch around reading in files and converting them to JSON: Server { stopwatch 'files' { Get-ChildItem 'c:/temp/*.json' | Foreach -Object { $content = Get-Content -Raw $_ $json = $content | ConvertFrom-Json } } } The above will run, and output something similar to the below, on the CLI: [Stopwatch]: 00:00:08.136788 [files] Parameters Name Type Required Description Default Name string true The name of the logic the stopwatch is wrapped around empty ScriptBlock scriptblock true The logic the stopwatch should time null","title":"Stopwatch"},{"location":"Functions/Stopwatch/#stopwatch","text":"","title":"Stopwatch"},{"location":"Functions/Stopwatch/#description","text":"The stopwatch function lets you wrap logic in a scriptblock, and have the amount of time the logic took to execute outputted to the CLI.","title":"Description"},{"location":"Functions/Stopwatch/#examples","text":"","title":"Examples"},{"location":"Functions/Stopwatch/#example-1","text":"The following example will wrap a stopwatch around reading in files and converting them to JSON: Server { stopwatch 'files' { Get-ChildItem 'c:/temp/*.json' | Foreach -Object { $content = Get-Content -Raw $_ $json = $content | ConvertFrom-Json } } } The above will run, and output something similar to the below, on the CLI: [Stopwatch]: 00:00:08.136788 [files]","title":"Example 1"},{"location":"Functions/Stopwatch/#parameters","text":"Name Type Required Description Default Name string true The name of the logic the stopwatch is wrapped around empty ScriptBlock scriptblock true The logic the stopwatch should time null","title":"Parameters"},{"location":"Functions/Stream/","text":"Stream Description The stream function allows you to use streams, utilise them, and then automatically dispose of the stream object for you. Examples Example 1 The following example opens a StreamReader , reads in the content of the stream, and then automatically disposes of the stream for you. The content is then placed into the $data variable: Server { $data = stream ( [System.IO.StreamReader] :: new ( $stream )) { return $args [ 0 ]. ReadToEnd () } } Parameters Name Type Required Description Default InputObject IDisposable true A disposable object that will be used, and then disposed. This works much the same as using in C# .NET null ScriptBlock scriptblock true The logic that will utilise the disposable stream object, of which the stream itself is passed as an argument to the scriptblock null","title":"Stream"},{"location":"Functions/Stream/#stream","text":"","title":"Stream"},{"location":"Functions/Stream/#description","text":"The stream function allows you to use streams, utilise them, and then automatically dispose of the stream object for you.","title":"Description"},{"location":"Functions/Stream/#examples","text":"","title":"Examples"},{"location":"Functions/Stream/#example-1","text":"The following example opens a StreamReader , reads in the content of the stream, and then automatically disposes of the stream for you. The content is then placed into the $data variable: Server { $data = stream ( [System.IO.StreamReader] :: new ( $stream )) { return $args [ 0 ]. ReadToEnd () } }","title":"Example 1"},{"location":"Functions/Stream/#parameters","text":"Name Type Required Description Default InputObject IDisposable true A disposable object that will be used, and then disposed. This works much the same as using in C# .NET null ScriptBlock scriptblock true The logic that will utilise the disposable stream object, of which the stream itself is passed as an argument to the scriptblock null","title":"Parameters"},{"location":"Functions/Timer/","text":"Timer Description The timer function allows you to setup short-running async tasks, that run periodically along side your main server logic; they have unique names, and iterate on a defined number of seconds. Info All timers are created and run within the same runspace, one after another when their trigger time occurs. You should ensure that a timer's defined logic is not long-running (things like heavy database tasks or reporting), as this will delay other timers from being run. For timers that might take a much longer time to run, try using schedule instead Examples Example 1 The following example is a timer that runs for ever, every 5secs: Server { timer 'forever' 5 { # logic } } Example 2 The following example is a timer that will skip the first 3 iterations, and after 15secs (3x5) will loop every 5secs: Server { timer 'skip-first-3' 5 -skip 3 { # logic } } Example 3 The following example is a timer that runs once after waiting for 2mins: Server { timer 'run-once' 120 -skip 1 -limit 1 { # logic } } Example 4 The following example will create a new timer every time the route is called - the route expects two query string parameters of Name an Seconds : Server { route 'get' '/api/timer' { param ( $session ) $query = $session . Query timer $query [ 'Name' ] $query [ 'Seconds' ] { # logic } } } Parameters Name Type Required Description Default Name string true The unique name of the timer empty Interval int true The number of seconds between each iteration 0 ScriptBlock scriptblock true The main logic that will be invoked on each timer iteration null Limit int false The number of iterations that should be invoked before the timer is removed 0 Skip int false The number of iterations to skip before invoking timer logic 0","title":"Timer"},{"location":"Functions/Timer/#timer","text":"","title":"Timer"},{"location":"Functions/Timer/#description","text":"The timer function allows you to setup short-running async tasks, that run periodically along side your main server logic; they have unique names, and iterate on a defined number of seconds. Info All timers are created and run within the same runspace, one after another when their trigger time occurs. You should ensure that a timer's defined logic is not long-running (things like heavy database tasks or reporting), as this will delay other timers from being run. For timers that might take a much longer time to run, try using schedule instead","title":"Description"},{"location":"Functions/Timer/#examples","text":"","title":"Examples"},{"location":"Functions/Timer/#example-1","text":"The following example is a timer that runs for ever, every 5secs: Server { timer 'forever' 5 { # logic } }","title":"Example 1"},{"location":"Functions/Timer/#example-2","text":"The following example is a timer that will skip the first 3 iterations, and after 15secs (3x5) will loop every 5secs: Server { timer 'skip-first-3' 5 -skip 3 { # logic } }","title":"Example 2"},{"location":"Functions/Timer/#example-3","text":"The following example is a timer that runs once after waiting for 2mins: Server { timer 'run-once' 120 -skip 1 -limit 1 { # logic } }","title":"Example 3"},{"location":"Functions/Timer/#example-4","text":"The following example will create a new timer every time the route is called - the route expects two query string parameters of Name an Seconds : Server { route 'get' '/api/timer' { param ( $session ) $query = $session . Query timer $query [ 'Name' ] $query [ 'Seconds' ] { # logic } } }","title":"Example 4"},{"location":"Functions/Timer/#parameters","text":"Name Type Required Description Default Name string true The unique name of the timer empty Interval int true The number of seconds between each iteration 0 ScriptBlock scriptblock true The main logic that will be invoked on each timer iteration null Limit int false The number of iterations that should be invoked before the timer is removed 0 Skip int false The number of iterations to skip before invoking timer logic 0","title":"Parameters"},{"location":"Functions/View/","text":"View Description The view function allows you to render any of the view files that you place within the /views directory. When you call view , Pode will automatically look within this directory. Pode uses a View Engine to either render HTML, Pode, or other types. Default is HTML, and you can change it to Pode by using the engine function. Examples Example 1 The following example will render the index.html view when you navigate to http://localhost:8080 : Server { listen * : 8080 http route get '/' { view 'index' } } Example 2 The following example will render the index.pode view when you navigate to http://localhost:8080 : Server { listen * : 8080 http engine pode route get '/' { view 'index' } } Example 3 The following example will render the index.pode view when you navigate to http://localhost:8080 , it will also supply dynamic data - in this case, the current date: The dynamic data can be used in your pode view via $($data.date) Server { listen * : 8080 http engine pode route get '/' { view 'index' -d @{ 'date' = [DateTime] :: Now } } } Parameters Name Type Required Description Default Path string true The path to the view to render, relative to your /views directory null data hashtable false A hashtable of dynamic data that will be supplied to .pode , and other third-party template engine, view files @{}","title":"View"},{"location":"Functions/View/#view","text":"","title":"View"},{"location":"Functions/View/#description","text":"The view function allows you to render any of the view files that you place within the /views directory. When you call view , Pode will automatically look within this directory. Pode uses a View Engine to either render HTML, Pode, or other types. Default is HTML, and you can change it to Pode by using the engine function.","title":"Description"},{"location":"Functions/View/#examples","text":"","title":"Examples"},{"location":"Functions/View/#example-1","text":"The following example will render the index.html view when you navigate to http://localhost:8080 : Server { listen * : 8080 http route get '/' { view 'index' } }","title":"Example 1"},{"location":"Functions/View/#example-2","text":"The following example will render the index.pode view when you navigate to http://localhost:8080 : Server { listen * : 8080 http engine pode route get '/' { view 'index' } }","title":"Example 2"},{"location":"Functions/View/#example-3","text":"The following example will render the index.pode view when you navigate to http://localhost:8080 , it will also supply dynamic data - in this case, the current date: The dynamic data can be used in your pode view via $($data.date) Server { listen * : 8080 http engine pode route get '/' { view 'index' -d @{ 'date' = [DateTime] :: Now } } }","title":"Example 3"},{"location":"Functions/View/#parameters","text":"Name Type Required Description Default Path string true The path to the view to render, relative to your /views directory null data hashtable false A hashtable of dynamic data that will be supplied to .pode , and other third-party template engine, view files @{}","title":"Parameters"},{"location":"Functions/Xml/","text":"Xml Description The xml function converts a hashtable , or reads in a file, and converts it to XML; the XML value is then written to the web response. You can also supply raw XML data as the value to write. Examples Example 1 The following example will convert a hashtable to XML and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { xml @{ 'cpu' = 80 ; 'memory' = 15 ; } } } Example 2 The following example will write raw XML data to a web response within a route : Server { listen * : 8080 http route get '/info' { xml '<root><users><user>Rick</user><user>Morty</user></users></root>' } } Example 3 The following example will read in a file, and write the contents as XML to a web response within a route : Server { listen * : 8080 http route get '/data' { xml -file './files/data.xml' } } Parameters Name Type Required Description Default Value hashtable/string true The value should either be a hashtable or string - the string can be either a path or raw XML. It will be converted to XML, if not raw, and attached to the web response null File switch false If passed, the above value should be a string that's a path to an XML file false","title":"Xml"},{"location":"Functions/Xml/#xml","text":"","title":"Xml"},{"location":"Functions/Xml/#description","text":"The xml function converts a hashtable , or reads in a file, and converts it to XML; the XML value is then written to the web response. You can also supply raw XML data as the value to write.","title":"Description"},{"location":"Functions/Xml/#examples","text":"","title":"Examples"},{"location":"Functions/Xml/#example-1","text":"The following example will convert a hashtable to XML and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { xml @{ 'cpu' = 80 ; 'memory' = 15 ; } } }","title":"Example 1"},{"location":"Functions/Xml/#example-2","text":"The following example will write raw XML data to a web response within a route : Server { listen * : 8080 http route get '/info' { xml '<root><users><user>Rick</user><user>Morty</user></users></root>' } }","title":"Example 2"},{"location":"Functions/Xml/#example-3","text":"The following example will read in a file, and write the contents as XML to a web response within a route : Server { listen * : 8080 http route get '/data' { xml -file './files/data.xml' } }","title":"Example 3"},{"location":"Functions/Xml/#parameters","text":"Name Type Required Description Default Value hashtable/string true The value should either be a hashtable or string - the string can be either a path or raw XML. It will be converted to XML, if not raw, and attached to the web response null File switch false If passed, the above value should be a string that's a path to an XML file false","title":"Parameters"},{"location":"Getting-Started/CLI/","text":"CLI Pode has some commands that you can utilise from the CLI - when your in a PowerShell terminal, or pwsh session. These commands help you to initialise, start, test, build, or install any packages for your repo/server. All of these commands are centered around the package.json format - similar to that of Node.js and Yarn. Info At the moment, Pode only uses the start , test , build and install properties of the scripts section in your package.json . You can still have others, like dependencies for Yarn Commands Build The build command will run the script found in the package.json file, at the scripts/build value: pode builid Init The init command will help you create a new package.json file from scratch. It will ask a few questions, such as author/name/etc, and then create the file for you: pode init Tip By default, Pode will pre-populate the test , build and install values using yarn , psake and pester respectively Install The install command will run the script found in the package.json file, at the scripts/install value: pode install Start The start command will run the script found in the package.json file, at the scripts/start value. If this value is not set, then this command will instead run the value under main : pode start Test The test command will run the script found in the package.json file, at the scripts/test value: pode test Package File The following is an example of a package.json file: { \"name\" : \"example\" , \"description\" : \"\" , \"version\" : \"1.0.0\" , \"main\" : \"./server.ps1\" , \"scripts\" : { \"start\" : \"./server.ps1\" , \"test\" : \"invoke-pester ./tests/*.ps1\" , \"install\" : \"yarn install --force --ignore-scripts --modules-folder pode_modules\" , \"build\" : \"psake\" }, \"author\" : \"Rick Sanchez\" , \"license\" : \"MIT\" }","title":"CLI"},{"location":"Getting-Started/CLI/#cli","text":"Pode has some commands that you can utilise from the CLI - when your in a PowerShell terminal, or pwsh session. These commands help you to initialise, start, test, build, or install any packages for your repo/server. All of these commands are centered around the package.json format - similar to that of Node.js and Yarn. Info At the moment, Pode only uses the start , test , build and install properties of the scripts section in your package.json . You can still have others, like dependencies for Yarn","title":"CLI"},{"location":"Getting-Started/CLI/#commands","text":"","title":"Commands"},{"location":"Getting-Started/CLI/#build","text":"The build command will run the script found in the package.json file, at the scripts/build value: pode builid","title":"Build"},{"location":"Getting-Started/CLI/#init","text":"The init command will help you create a new package.json file from scratch. It will ask a few questions, such as author/name/etc, and then create the file for you: pode init Tip By default, Pode will pre-populate the test , build and install values using yarn , psake and pester respectively","title":"Init"},{"location":"Getting-Started/CLI/#install","text":"The install command will run the script found in the package.json file, at the scripts/install value: pode install","title":"Install"},{"location":"Getting-Started/CLI/#start","text":"The start command will run the script found in the package.json file, at the scripts/start value. If this value is not set, then this command will instead run the value under main : pode start","title":"Start"},{"location":"Getting-Started/CLI/#test","text":"The test command will run the script found in the package.json file, at the scripts/test value: pode test","title":"Test"},{"location":"Getting-Started/CLI/#package-file","text":"The following is an example of a package.json file: { \"name\" : \"example\" , \"description\" : \"\" , \"version\" : \"1.0.0\" , \"main\" : \"./server.ps1\" , \"scripts\" : { \"start\" : \"./server.ps1\" , \"test\" : \"invoke-pester ./tests/*.ps1\" , \"install\" : \"yarn install --force --ignore-scripts --modules-folder pode_modules\" , \"build\" : \"psake\" }, \"author\" : \"Rick Sanchez\" , \"license\" : \"MIT\" }","title":"Package File"},{"location":"Getting-Started/CronExpressions/","text":"Cron Expressions Schedules in Pode use cron expressions to define when they trigger. This page is a brief overview of the expressions supported by Pode. Basic Pode supports all basic features of cron expressions in the following format: <min> <hour> <day-of-month> <month> <day-of-week> For example, if you wanted to run a schedule that triggers every midnight on a Tuesday, the following would work: 0 0 * * TUE Whereas if you wanted a schedule to trigger on the 15th of each month, at 1am: 0 1 15 * * * Predefined The following table outlines some of the predefined cron expressions supported by Pode; you can use these in place of normal cron expressions: Predefined Expression @minutely * * * * * @hourly 0 * * * * @daily 0 0 * * * @weekly 0 0 * * 0 @monthly 0 0 1 * * @quaterly 0 0 1 1,4,8,7,10 @yearly 0 0 1 1 * @annually 0 0 1 1 * @twice-hourly 0,30 * * * * @twice-daily 0,12 0 * * * @twice-weekly 0 0 * * 0,4 @twice-monthly 0 0 1,15 * * @twice-yearly 0 0 1 1,6 * @twice-annually 0 0 1 1,6 * Advanced Pode does have some support for advanced cron features, including its own placeholder: R . R : using this on an atom will use a random value between that atom's constraints, and when the expression is triggered the atom is re-randomised - you can force an initial trigger value using /R . For example: 30/R * * * * will trigger on 30mins, then a random minute afterwards; whereas using R * * * * will always trigger on a random minute between 0-59.","title":"Cron Expressions"},{"location":"Getting-Started/CronExpressions/#cron-expressions","text":"Schedules in Pode use cron expressions to define when they trigger. This page is a brief overview of the expressions supported by Pode.","title":"Cron Expressions"},{"location":"Getting-Started/CronExpressions/#basic","text":"Pode supports all basic features of cron expressions in the following format: <min> <hour> <day-of-month> <month> <day-of-week> For example, if you wanted to run a schedule that triggers every midnight on a Tuesday, the following would work: 0 0 * * TUE Whereas if you wanted a schedule to trigger on the 15th of each month, at 1am: 0 1 15 * * *","title":"Basic"},{"location":"Getting-Started/CronExpressions/#predefined","text":"The following table outlines some of the predefined cron expressions supported by Pode; you can use these in place of normal cron expressions: Predefined Expression @minutely * * * * * @hourly 0 * * * * @daily 0 0 * * * @weekly 0 0 * * 0 @monthly 0 0 1 * * @quaterly 0 0 1 1,4,8,7,10 @yearly 0 0 1 1 * @annually 0 0 1 1 * @twice-hourly 0,30 * * * * @twice-daily 0,12 0 * * * @twice-weekly 0 0 * * 0,4 @twice-monthly 0 0 1,15 * * @twice-yearly 0 0 1 1,6 * @twice-annually 0 0 1 1,6 *","title":"Predefined"},{"location":"Getting-Started/CronExpressions/#advanced","text":"Pode does have some support for advanced cron features, including its own placeholder: R . R : using this on an atom will use a random value between that atom's constraints, and when the expression is triggered the atom is re-randomised - you can force an initial trigger value using /R . For example: 30/R * * * * will trigger on 30mins, then a random minute afterwards; whereas using R * * * * will always trigger on a random minute between 0-59.","title":"Advanced"},{"location":"Getting-Started/Docker/","text":"Docker Pode has a Docker container that you can use, by calling docker pull badgerati/pode you can pull down the latest image. The image itself uses PowerShell Core on the Ubuntu Xenial OS. Dockerfile An example of using the Pode container in your Dockerfile could be as follows: Info The server script used below can be found in the examples/web-pages-docker.ps1 # pull down the pode image FROM badgerati/pode # copy over the local files to the container COPY . /usr/src/app/ # expose the port EXPOSE 8085 # run the server CMD [ \"pwsh\", \"-c\", \"cd /usr/src/app; ./web-pages-docker.ps1\" ] Build and Run To build and run the above Dockerfile, you can use the following commands: docker build -t pode/example docker run -p 8085 :8085 -d pode/example Info The Dockerfile above is the same Dockerfile in the examples/ directory Now try navigating to localhost:8085 (or calling curl localhost:8085 ) and you should be greeted with a \"Hello, world!\" page.","title":"Docker"},{"location":"Getting-Started/Docker/#docker","text":"Pode has a Docker container that you can use, by calling docker pull badgerati/pode you can pull down the latest image. The image itself uses PowerShell Core on the Ubuntu Xenial OS.","title":"Docker"},{"location":"Getting-Started/Docker/#dockerfile","text":"An example of using the Pode container in your Dockerfile could be as follows: Info The server script used below can be found in the examples/web-pages-docker.ps1 # pull down the pode image FROM badgerati/pode # copy over the local files to the container COPY . /usr/src/app/ # expose the port EXPOSE 8085 # run the server CMD [ \"pwsh\", \"-c\", \"cd /usr/src/app; ./web-pages-docker.ps1\" ]","title":"Dockerfile"},{"location":"Getting-Started/Docker/#build-and-run","text":"To build and run the above Dockerfile, you can use the following commands: docker build -t pode/example docker run -p 8085 :8085 -d pode/example Info The Dockerfile above is the same Dockerfile in the examples/ directory Now try navigating to localhost:8085 (or calling curl localhost:8085 ) and you should be greeted with a \"Hello, world!\" page.","title":"Build and Run"},{"location":"Getting-Started/Frontend/","text":"Frontend You can host web-pages using Pode, and to help you can also use package managers like yarn to install frontend libraries - like bootstrap. Using Yarn The following will install Yarn onto your machine: choco install yarn -y yarn init Once installed, you can use Yarn to download frontend libraries. The libraries will be added to a package.json file - which if you're using the Pode CLI, you'll already have in place. To install frontend libraries, you could use the following: yarn add bootstrap yarn add lodash Build via Pode Once you've added some libraries you can use pode install to trigger yarn . This will tell yarn to install the packages to a pode_modules directory. Info Other useful packages could include gulp , jquery , moment , etc.","title":"Frontend"},{"location":"Getting-Started/Frontend/#frontend","text":"You can host web-pages using Pode, and to help you can also use package managers like yarn to install frontend libraries - like bootstrap.","title":"Frontend"},{"location":"Getting-Started/Frontend/#using-yarn","text":"The following will install Yarn onto your machine: choco install yarn -y yarn init Once installed, you can use Yarn to download frontend libraries. The libraries will be added to a package.json file - which if you're using the Pode CLI, you'll already have in place. To install frontend libraries, you could use the following: yarn add bootstrap yarn add lodash","title":"Using Yarn"},{"location":"Getting-Started/Frontend/#build-via-pode","text":"Once you've added some libraries you can use pode install to trigger yarn . This will tell yarn to install the packages to a pode_modules directory. Info Other useful packages could include gulp , jquery , moment , etc.","title":"Build via Pode"},{"location":"Getting-Started/Installation/","text":"Installation Pode is a PowerShell module that can be installed from either Chocolatey, PowerShell Gallery, or Docker. Once installed, you can import the module into your PowerShell scripts. Chocolatey To install Pode via Chocolatey, the following command can be used: choco install pode PowerShell Gallery To install Pode from the PowerShell Gallery, you can use the following: Install-Module -Name Pode Docker Pode can run on Unix environments, therefore it only makes sense for there to be a Docker container for you to use! The container uses PowerShell Core on an Ubuntu Xenial container. To pull down the Pode container you can do: docker pull badgerati / pode Using the Module After you have installed the module, you can then import it into your server scripts: Import-Module Pode","title":"Installation"},{"location":"Getting-Started/Installation/#installation","text":"Pode is a PowerShell module that can be installed from either Chocolatey, PowerShell Gallery, or Docker. Once installed, you can import the module into your PowerShell scripts.","title":"Installation"},{"location":"Getting-Started/Installation/#chocolatey","text":"To install Pode via Chocolatey, the following command can be used: choco install pode","title":"Chocolatey"},{"location":"Getting-Started/Installation/#powershell-gallery","text":"To install Pode from the PowerShell Gallery, you can use the following: Install-Module -Name Pode","title":"PowerShell Gallery"},{"location":"Getting-Started/Installation/#docker","text":"Pode can run on Unix environments, therefore it only makes sense for there to be a Docker container for you to use! The container uses PowerShell Core on an Ubuntu Xenial container. To pull down the Pode container you can do: docker pull badgerati / pode","title":"Docker"},{"location":"Getting-Started/Installation/#using-the-module","text":"After you have installed the module, you can then import it into your server scripts: Import-Module Pode","title":"Using the Module"}]}