{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Pode is a Cross-Platform PowerShell framework that allows you to host REST APIs, Web Pages and SMTP/TCP servers. It also allows you to render dynamic files using .pode files, which is effectively embedded PowerShell, or other Third-Party template engines. Pode also has support for middleware, sessions, and authentication; as well as access and rate limiting features. Features Can run on *nix environments using PowerShell Core Host REST APIs and Web Pages Host TCP and SMTP server - great for tests and mocking Multiple threads can be used to response to incoming requests Use the full power of PowerShell, want a REST API for NUnit? Go for it! Ability to write dynamic files in PowerShell using Pode, or other third-party template engines Can use yarn package manager to install bootstrap, or other frontend libraries Setup async timers to be used as one off tasks, or for housekeeping services Ability to schedule async tasks using cron expressions Supports logging to CLI, Files, and custom loggers to other services like LogStash, etc. Cross-state runspace variable access for timers, routes and loggers Optional file monitoring to trigger internal server restart on file changes Ability to allow/deny requests from certain IP addresses and subnets Basic rate limiting for IP addresses and subnets Support for generating/binding self-signed certificates, and binding signed certificates Support for middleware on web servers Session middleware support on web requests Can use authentication on requests, which can either be sessionless or session persistant","title":"Home"},{"location":"#welcome","text":"Pode is a Cross-Platform PowerShell framework that allows you to host REST APIs, Web Pages and SMTP/TCP servers. It also allows you to render dynamic files using .pode files, which is effectively embedded PowerShell, or other Third-Party template engines. Pode also has support for middleware, sessions, and authentication; as well as access and rate limiting features.","title":"Welcome"},{"location":"#features","text":"Can run on *nix environments using PowerShell Core Host REST APIs and Web Pages Host TCP and SMTP server - great for tests and mocking Multiple threads can be used to response to incoming requests Use the full power of PowerShell, want a REST API for NUnit? Go for it! Ability to write dynamic files in PowerShell using Pode, or other third-party template engines Can use yarn package manager to install bootstrap, or other frontend libraries Setup async timers to be used as one off tasks, or for housekeeping services Ability to schedule async tasks using cron expressions Supports logging to CLI, Files, and custom loggers to other services like LogStash, etc. Cross-state runspace variable access for timers, routes and loggers Optional file monitoring to trigger internal server restart on file changes Ability to allow/deny requests from certain IP addresses and subnets Basic rate limiting for IP addresses and subnets Support for generating/binding self-signed certificates, and binding signed certificates Support for middleware on web servers Session middleware support on web requests Can use authentication on requests, which can either be sessionless or session persistant","title":"Features"},{"location":"Functions/Core/Access/","text":"Access Description The access function allows you to specify rules to allow/deny IP addresses or subnets access to your routes. If an IP address hits your server that you've denied access, then a 403 response is returned and the connection immediately closed. For SMTP/TCP servers the connection is just closed with no response. Examples Example 1 The following example will allow access from the localhost: Server { access allow ip '127.0.0.1' } Tip It's best to use @('127.0.0.1', '[::1]') for localhost instead of just 127.0.0.1 , as this will allow the IPv6 localhost address as well. Example 2 The following example will allow access from multiple IP addresses: Server { access allow ip @( '192.168.1.1' , '192.168.1.2' ) } Example 3 The following example will deny access from a subnet mask: Server { access deny ip '10.10.0.0/24' } Example 4 The following example will deny access from all IP addresses: Server { access deny ip all } Parameters Name Type Required Description Default Permission string true The type of access for the IP address/subnet (Values: Allow, Deny) empty Type string true The type of what you wish to restrict access (Values: IP) empty Value object true The IP address or subnet mask to apply the access rule null Info There are plans to expand access to restrict content types as well.","title":"Access"},{"location":"Functions/Core/Access/#access","text":"","title":"Access"},{"location":"Functions/Core/Access/#description","text":"The access function allows you to specify rules to allow/deny IP addresses or subnets access to your routes. If an IP address hits your server that you've denied access, then a 403 response is returned and the connection immediately closed. For SMTP/TCP servers the connection is just closed with no response.","title":"Description"},{"location":"Functions/Core/Access/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Access/#example-1","text":"The following example will allow access from the localhost: Server { access allow ip '127.0.0.1' } Tip It's best to use @('127.0.0.1', '[::1]') for localhost instead of just 127.0.0.1 , as this will allow the IPv6 localhost address as well.","title":"Example 1"},{"location":"Functions/Core/Access/#example-2","text":"The following example will allow access from multiple IP addresses: Server { access allow ip @( '192.168.1.1' , '192.168.1.2' ) }","title":"Example 2"},{"location":"Functions/Core/Access/#example-3","text":"The following example will deny access from a subnet mask: Server { access deny ip '10.10.0.0/24' }","title":"Example 3"},{"location":"Functions/Core/Access/#example-4","text":"The following example will deny access from all IP addresses: Server { access deny ip all }","title":"Example 4"},{"location":"Functions/Core/Access/#parameters","text":"Name Type Required Description Default Permission string true The type of access for the IP address/subnet (Values: Allow, Deny) empty Type string true The type of what you wish to restrict access (Values: IP) empty Value object true The IP address or subnet mask to apply the access rule null Info There are plans to expand access to restrict content types as well.","title":"Parameters"},{"location":"Functions/Core/Endware/","text":"Endware Description The endware function allows you to add endware scripts, that run after all middleware and route logic - even if a middleware has ended the pipeline early. They allow you to do things like logging, further data storage, etc. Endware in Pode allows you to observe the request/response objects at the very end of the middleware/route pipeline for a current web request. This way you will have the most up-to-date information on the objects for any logging you may wish to perform. Info Unlike middleware which has a return value to halt execution, each endware will run in turn without the need for returning anything. So if there are 4 endware configured and 1 fails in the middle, the other later ones will still run. Examples Example 1 The following example is endware that observes the content length of the response, as well as the status code, and records them in some custom data storage for later analysis: Server { endware { param ( $session ) $status = $session . Response . StatusCode $length = $session . Response . ContentLength64 Save-ContentStatus -ContentLength $length -Status $status } } Parameters Name Type Required Description Default ScriptBlock scriptblock true The main logic for the endware; this scriptblock will be supplied a single parameter which contains the Request and Response objects null","title":"Endware"},{"location":"Functions/Core/Endware/#endware","text":"","title":"Endware"},{"location":"Functions/Core/Endware/#description","text":"The endware function allows you to add endware scripts, that run after all middleware and route logic - even if a middleware has ended the pipeline early. They allow you to do things like logging, further data storage, etc. Endware in Pode allows you to observe the request/response objects at the very end of the middleware/route pipeline for a current web request. This way you will have the most up-to-date information on the objects for any logging you may wish to perform. Info Unlike middleware which has a return value to halt execution, each endware will run in turn without the need for returning anything. So if there are 4 endware configured and 1 fails in the middle, the other later ones will still run.","title":"Description"},{"location":"Functions/Core/Endware/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Endware/#example-1","text":"The following example is endware that observes the content length of the response, as well as the status code, and records them in some custom data storage for later analysis: Server { endware { param ( $session ) $status = $session . Response . StatusCode $length = $session . Response . ContentLength64 Save-ContentStatus -ContentLength $length -Status $status } }","title":"Example 1"},{"location":"Functions/Core/Endware/#parameters","text":"Name Type Required Description Default ScriptBlock scriptblock true The main logic for the endware; this scriptblock will be supplied a single parameter which contains the Request and Response objects null","title":"Parameters"},{"location":"Functions/Core/Engine/","text":"Engine Description The engine function allows you to specify the engine used to render view and content templates. You can also specify a third-party engine to use, such as EPS . Info If you don't use the engine function, then the defaut of HTML will be used Examples Example 1 The following example will render views and content using the Pode template engine (such as the index.pode view or the style.css.pode public content file): Server { engine pode } Example 2 The following example will use the third-party engine EPS to render views (such as the index.eps view or the style.css.eps public content file): Server { engine eps { param ( $path , $data ) return Invoke-EpsTemplate -Path $path -Binding $data } } Parameters Name Type Required Description Default Engine string true The type of engine to use, can be either HTML, Pode, or a custom third-party type - the value passed should be the extension used by the engine HTML ScriptBlock scriptblock false When using a third-party template engine, the ScriptBlock is required as it tells Pode how to render views/static content using the engine null","title":"Engine"},{"location":"Functions/Core/Engine/#engine","text":"","title":"Engine"},{"location":"Functions/Core/Engine/#description","text":"The engine function allows you to specify the engine used to render view and content templates. You can also specify a third-party engine to use, such as EPS . Info If you don't use the engine function, then the defaut of HTML will be used","title":"Description"},{"location":"Functions/Core/Engine/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Engine/#example-1","text":"The following example will render views and content using the Pode template engine (such as the index.pode view or the style.css.pode public content file): Server { engine pode }","title":"Example 1"},{"location":"Functions/Core/Engine/#example-2","text":"The following example will use the third-party engine EPS to render views (such as the index.eps view or the style.css.eps public content file): Server { engine eps { param ( $path , $data ) return Invoke-EpsTemplate -Path $path -Binding $data } }","title":"Example 2"},{"location":"Functions/Core/Engine/#parameters","text":"Name Type Required Description Default Engine string true The type of engine to use, can be either HTML, Pode, or a custom third-party type - the value passed should be the extension used by the engine HTML ScriptBlock scriptblock false When using a third-party template engine, the ScriptBlock is required as it tells Pode how to render views/static content using the engine null","title":"Parameters"},{"location":"Functions/Core/Handler/","text":"Handler Description The handler function allows you to bind logic onto incoming TCP streams, or onto SMTP requests. The SMTP handler type will use Pode's inbuilt simple SMTP server, which will automatically create a TCP listener on port 25 (unless you specific a different port to listen on). The handler logic in this case will be passed an argument containing information about the Email. The TCP handler will have the TCP client itself passed to the handler's logic, this way you can build your own custom TCP handler. Warning You can only have 1 handler per type. Ie, TCP can only have one handler defined, as well as SMTP. Examples Example 1 The following example will setup the inbuilt simple SMTP server, writing to the terminal the content of the email: Server { listen * : 25 smtp handler smtp { param ( $email ) Write-Host $email . Data } } Tip The $email argument supplied to the SMTP handler contains the From and To address, as well as the Data of the email. Example 2 The following example will setup a TCP server, having the TCP client passed to the handler's logic. It will read in a message from the stream, then write one back: Server { listen * : 30 tcp handler tcp { $msg = ( tcp read ) if ( $msg -ieq 'HELO' ) { tcp write 'HEY' } } } Parameters Name Type Required Description Default Type string true The type of 'TCP' to bind onto the handler (Values: TCP, SMTP) empty ScriptBlock scriptblock true The main handler logic that will be invoked when the an incoming TCP stream is detected null","title":"Handler"},{"location":"Functions/Core/Handler/#handler","text":"","title":"Handler"},{"location":"Functions/Core/Handler/#description","text":"The handler function allows you to bind logic onto incoming TCP streams, or onto SMTP requests. The SMTP handler type will use Pode's inbuilt simple SMTP server, which will automatically create a TCP listener on port 25 (unless you specific a different port to listen on). The handler logic in this case will be passed an argument containing information about the Email. The TCP handler will have the TCP client itself passed to the handler's logic, this way you can build your own custom TCP handler. Warning You can only have 1 handler per type. Ie, TCP can only have one handler defined, as well as SMTP.","title":"Description"},{"location":"Functions/Core/Handler/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Handler/#example-1","text":"The following example will setup the inbuilt simple SMTP server, writing to the terminal the content of the email: Server { listen * : 25 smtp handler smtp { param ( $email ) Write-Host $email . Data } } Tip The $email argument supplied to the SMTP handler contains the From and To address, as well as the Data of the email.","title":"Example 1"},{"location":"Functions/Core/Handler/#example-2","text":"The following example will setup a TCP server, having the TCP client passed to the handler's logic. It will read in a message from the stream, then write one back: Server { listen * : 30 tcp handler tcp { $msg = ( tcp read ) if ( $msg -ieq 'HELO' ) { tcp write 'HEY' } } }","title":"Example 2"},{"location":"Functions/Core/Handler/#parameters","text":"Name Type Required Description Default Type string true The type of 'TCP' to bind onto the handler (Values: TCP, SMTP) empty ScriptBlock scriptblock true The main handler logic that will be invoked when the an incoming TCP stream is detected null","title":"Parameters"},{"location":"Functions/Core/Import/","text":"Import Description The import function allows you to declare paths to PowerShell Modules ( .psm1 ) that need to be imported into each runspace. Because Pode runs most things in isolated runspaces, importing and using external modules in Pode can be quite bothersome, with import Pode will handle importing your modules into all async runspaces for you. Examples Example 1 The following example will import the specified module into each of the runspaces that Pode creates. This way you'll be able to use each of the functions declared wihtin the module in routes , timers , schedules , loggers , handlers , etc. (basically, everything): Server { import './path/to/module.psm1' } Parameters Name Type Required Description Default Path string true The path to a PowerShell Module ( .psm1 ) that should be imported into the runspaces empty","title":"Import"},{"location":"Functions/Core/Import/#import","text":"","title":"Import"},{"location":"Functions/Core/Import/#description","text":"The import function allows you to declare paths to PowerShell Modules ( .psm1 ) that need to be imported into each runspace. Because Pode runs most things in isolated runspaces, importing and using external modules in Pode can be quite bothersome, with import Pode will handle importing your modules into all async runspaces for you.","title":"Description"},{"location":"Functions/Core/Import/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Import/#example-1","text":"The following example will import the specified module into each of the runspaces that Pode creates. This way you'll be able to use each of the functions declared wihtin the module in routes , timers , schedules , loggers , handlers , etc. (basically, everything): Server { import './path/to/module.psm1' }","title":"Example 1"},{"location":"Functions/Core/Import/#parameters","text":"Name Type Required Description Default Path string true The path to a PowerShell Module ( .psm1 ) that should be imported into the runspaces empty","title":"Parameters"},{"location":"Functions/Core/Limit/","text":"Limit Description The limit function allows you to specify rate limiting rules on IP addresses or subnets to limit access to your routes. If an IP address hits your server and has exceeded the rate limit counter within the defined period, then a 429 response is returned and the connection immediately closed. For SMTP/TCP servers the connection is just closed with no response. Examples Example 1 The following example will limit the localhost to 5 requests per second: Server { limit ip 127 . 0 . 0 . 1 -limit 5 -seconds 1 } Tip It's best to use @('127.0.0.1', '[::1]') for localhost instead of just 127.0.0.1 , as this will limit the IPv6 localhost address as well. Example 2 The following example will limit multiple IP addresses to 5 requests per 10 seconds: Server { limit ip @( '192.168.1.1' , '192.168.1.2' ) -l 5 -s 10 } Example 3 The following example will limit a subnet mask to 5 requests per second, per each individual IP address governed by that subnet mask: Server { limit ip '10.10.0.0/24' -l 5 -s 1 } Info So here, the IP addresses 10.10.0.1 and 10.10.0.2 are under the subnet mask 10.10.0.0/24 ; each IP address will each get 5 requests per second before hitting the limit. Therefore if the first IP made 3req/s and the second made 3req/s, then the each call will be allowed through. Example 4 The following example will limit a subnet mask to 5 requests per second, where all IP addresses governed by the subnet are treated as one: Server { limit ip -group '10.10.0.0/24' -l 5 -s 1 } Info So here, the IP addresses 10.10.0.1 and 10.10.0.2 are under the subnet mask 10.10.0.0/24 ; each IP address will get a single grouped 5 requests per second before hitting the limit. Therefore if the first IP made 3req/s and the second made 3req/s, then the final call from the second will get a 429 response. Example 5 The following example will limit requests from all IP addresses to 10 requests per minute: Server { limit ip all -l 10 -s 60 } Parameters Name Type Required Description Default Type string true The type of what you wish to limit access (Values: IP) empty Value object true The IP address or subnet mask to apply rate limiting null Limit int true The amount of requests to allow within the given number of seconds, before a 429 status is returned 0 Seconds int true The number of seconds to wait before resetting the rate limit counter 0 Group switch false Only applies to subnet masks; if passed, all IP addresses governed by the mask will restricted by the same rate limit counter, rather than individually false Info There are plans to expand limit to limit content types as well.","title":"Limit"},{"location":"Functions/Core/Limit/#limit","text":"","title":"Limit"},{"location":"Functions/Core/Limit/#description","text":"The limit function allows you to specify rate limiting rules on IP addresses or subnets to limit access to your routes. If an IP address hits your server and has exceeded the rate limit counter within the defined period, then a 429 response is returned and the connection immediately closed. For SMTP/TCP servers the connection is just closed with no response.","title":"Description"},{"location":"Functions/Core/Limit/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Limit/#example-1","text":"The following example will limit the localhost to 5 requests per second: Server { limit ip 127 . 0 . 0 . 1 -limit 5 -seconds 1 } Tip It's best to use @('127.0.0.1', '[::1]') for localhost instead of just 127.0.0.1 , as this will limit the IPv6 localhost address as well.","title":"Example 1"},{"location":"Functions/Core/Limit/#example-2","text":"The following example will limit multiple IP addresses to 5 requests per 10 seconds: Server { limit ip @( '192.168.1.1' , '192.168.1.2' ) -l 5 -s 10 }","title":"Example 2"},{"location":"Functions/Core/Limit/#example-3","text":"The following example will limit a subnet mask to 5 requests per second, per each individual IP address governed by that subnet mask: Server { limit ip '10.10.0.0/24' -l 5 -s 1 } Info So here, the IP addresses 10.10.0.1 and 10.10.0.2 are under the subnet mask 10.10.0.0/24 ; each IP address will each get 5 requests per second before hitting the limit. Therefore if the first IP made 3req/s and the second made 3req/s, then the each call will be allowed through.","title":"Example 3"},{"location":"Functions/Core/Limit/#example-4","text":"The following example will limit a subnet mask to 5 requests per second, where all IP addresses governed by the subnet are treated as one: Server { limit ip -group '10.10.0.0/24' -l 5 -s 1 } Info So here, the IP addresses 10.10.0.1 and 10.10.0.2 are under the subnet mask 10.10.0.0/24 ; each IP address will get a single grouped 5 requests per second before hitting the limit. Therefore if the first IP made 3req/s and the second made 3req/s, then the final call from the second will get a 429 response.","title":"Example 4"},{"location":"Functions/Core/Limit/#example-5","text":"The following example will limit requests from all IP addresses to 10 requests per minute: Server { limit ip all -l 10 -s 60 }","title":"Example 5"},{"location":"Functions/Core/Limit/#parameters","text":"Name Type Required Description Default Type string true The type of what you wish to limit access (Values: IP) empty Value object true The IP address or subnet mask to apply rate limiting null Limit int true The amount of requests to allow within the given number of seconds, before a 429 status is returned 0 Seconds int true The number of seconds to wait before resetting the rate limit counter 0 Group switch false Only applies to subnet masks; if passed, all IP addresses governed by the mask will restricted by the same rate limit counter, rather than individually false Info There are plans to expand limit to limit content types as well.","title":"Parameters"},{"location":"Functions/Core/Listen/","text":"Listen Description The listen function allows you to specify the IP, Port and Protocol that your Server will listen on. If the protocol is https then you can also specify a certificate to bind, even having Pode create a self-signed certificate for you. Examples Example 1 The following example will listen on every IP over port 8080 for HTTP requests: Server { listen * : 8080 http } Info This will setup a web server and will require a route to be configured Example 2 The following example will listen on localhost over port 25 for SMTP requests: Server { listen 127 . 0 . 0 . 1 : 25 smtp } Info This will setup an SMTP server and will require a handler to be configured Example 3 The following example will listen on a specific IP address over port 8443 for HTTPS requests; it will also inform Pode to create and bind a self-signed certificate to the IP:Port: Server { listen 10 . 10 . 1 . 4 : 8443 https -cert self } Info This will setup a web server and will require a route to be configured Parameters Name Type Required Description Default IPPort string true The IP:Port combination that the server should listen on null Type string true The type of server: HTTP, HTTPS, SMTP, TCP null Cert string false The certificate to bind to the IP:Port. If the certificate is self then Pode will create a self-signed certificate. If the certificate is *.example.com then it must be installed to Cert:/LocalMachine/My null","title":"Listen"},{"location":"Functions/Core/Listen/#listen","text":"","title":"Listen"},{"location":"Functions/Core/Listen/#description","text":"The listen function allows you to specify the IP, Port and Protocol that your Server will listen on. If the protocol is https then you can also specify a certificate to bind, even having Pode create a self-signed certificate for you.","title":"Description"},{"location":"Functions/Core/Listen/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Listen/#example-1","text":"The following example will listen on every IP over port 8080 for HTTP requests: Server { listen * : 8080 http } Info This will setup a web server and will require a route to be configured","title":"Example 1"},{"location":"Functions/Core/Listen/#example-2","text":"The following example will listen on localhost over port 25 for SMTP requests: Server { listen 127 . 0 . 0 . 1 : 25 smtp } Info This will setup an SMTP server and will require a handler to be configured","title":"Example 2"},{"location":"Functions/Core/Listen/#example-3","text":"The following example will listen on a specific IP address over port 8443 for HTTPS requests; it will also inform Pode to create and bind a self-signed certificate to the IP:Port: Server { listen 10 . 10 . 1 . 4 : 8443 https -cert self } Info This will setup a web server and will require a route to be configured","title":"Example 3"},{"location":"Functions/Core/Listen/#parameters","text":"Name Type Required Description Default IPPort string true The IP:Port combination that the server should listen on null Type string true The type of server: HTTP, HTTPS, SMTP, TCP null Cert string false The certificate to bind to the IP:Port. If the certificate is self then Pode will create a self-signed certificate. If the certificate is *.example.com then it must be installed to Cert:/LocalMachine/My null","title":"Parameters"},{"location":"Functions/Core/Logger/","text":"Logger Description The logger function allows you to define inbuilt/custom log tools within your server that will send Combined Log Format rows to either the terminal, a file, or a custom script that will allow you to log to a variety of services - e.g. Splunk/FluentD/LogStash. When logging to a file, you can specify a custom path to create the log files, as well as a defined number of days to keep the log files. Examples Example 1 The following example will log web requests to the terminal: Server { logger terminal } Example 2 The following example will log web requests to a file. The log files will be placed at c:\\logs (default is /logs at the root), and will be split down by day; they will also only be kept for 7 days (default is forever) - any log file older than 7 days will automatically be deleted: Server { logger file @{ 'Path' = 'c:/logs/' ; 'MaxDays' = 7 ; } } Info The hashtable supplied to logger file is optional. If no Path is supplied then a /logs directory will be created at the server script root path, and if MaxDays is <= 0 then the log files will be kept forever. Example 3 The following example will create a custom log tool that outputs the request method/resource to the terminal. The name of the custom logger must be like custom_* , and a scriptblock should be supplied - the script will be supplied a single argument, which is a log object contains details of the request/response: Server { logger custom_terminal { param ( $obj ) $method = $obj . Log . Request . Method $resource = $obj . Log . Request . Resource \"[ $( $method ) ] $( $resource ) \" | Out-Default } } The .Log object will have the following structure: @{ 'Host' = '10.10.0.3' ; 'RfcUserIdentity' = '-' ; 'User' = '-' ; 'Date' = '14/Jun/2018:20:23:52 +01:00' ; 'Request' = @{ 'Method' = 'GET' ; 'Resource' = '/api/users' ; 'Protocol' = \"HTTP/1.1\" ; 'Referrer' = '-' ; 'Agent' = '<user-agent>' ; }; 'Response' = @{ 'StatusCode' = '200' ; 'StautsDescription' = 'OK' 'Size' = '9001' ; }; } Parameters Name Type Required Description Default Name string true The name of the logger; inbuilt loggers are terminal and file . Custom loggers must have a name like custom_* empty Details object false For inbuilt loggers this should be a hashtable . For custom loggers this should be the custom scriptblock to define how the logger works null","title":"Logger"},{"location":"Functions/Core/Logger/#logger","text":"","title":"Logger"},{"location":"Functions/Core/Logger/#description","text":"The logger function allows you to define inbuilt/custom log tools within your server that will send Combined Log Format rows to either the terminal, a file, or a custom script that will allow you to log to a variety of services - e.g. Splunk/FluentD/LogStash. When logging to a file, you can specify a custom path to create the log files, as well as a defined number of days to keep the log files.","title":"Description"},{"location":"Functions/Core/Logger/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Logger/#example-1","text":"The following example will log web requests to the terminal: Server { logger terminal }","title":"Example 1"},{"location":"Functions/Core/Logger/#example-2","text":"The following example will log web requests to a file. The log files will be placed at c:\\logs (default is /logs at the root), and will be split down by day; they will also only be kept for 7 days (default is forever) - any log file older than 7 days will automatically be deleted: Server { logger file @{ 'Path' = 'c:/logs/' ; 'MaxDays' = 7 ; } } Info The hashtable supplied to logger file is optional. If no Path is supplied then a /logs directory will be created at the server script root path, and if MaxDays is <= 0 then the log files will be kept forever.","title":"Example 2"},{"location":"Functions/Core/Logger/#example-3","text":"The following example will create a custom log tool that outputs the request method/resource to the terminal. The name of the custom logger must be like custom_* , and a scriptblock should be supplied - the script will be supplied a single argument, which is a log object contains details of the request/response: Server { logger custom_terminal { param ( $obj ) $method = $obj . Log . Request . Method $resource = $obj . Log . Request . Resource \"[ $( $method ) ] $( $resource ) \" | Out-Default } } The .Log object will have the following structure: @{ 'Host' = '10.10.0.3' ; 'RfcUserIdentity' = '-' ; 'User' = '-' ; 'Date' = '14/Jun/2018:20:23:52 +01:00' ; 'Request' = @{ 'Method' = 'GET' ; 'Resource' = '/api/users' ; 'Protocol' = \"HTTP/1.1\" ; 'Referrer' = '-' ; 'Agent' = '<user-agent>' ; }; 'Response' = @{ 'StatusCode' = '200' ; 'StautsDescription' = 'OK' 'Size' = '9001' ; }; }","title":"Example 3"},{"location":"Functions/Core/Logger/#parameters","text":"Name Type Required Description Default Name string true The name of the logger; inbuilt loggers are terminal and file . Custom loggers must have a name like custom_* empty Details object false For inbuilt loggers this should be a hashtable . For custom loggers this should be the custom scriptblock to define how the logger works null","title":"Parameters"},{"location":"Functions/Core/Middleware/","text":"Middleware Description The middleware function allows you to add middleware scripts, that run prior to route logic. They allow you to do things like rate-limiting, access restriction, sessions, etc. Middleware in Pode allows you to observe and edit the request/response objects for a current web request - you can alter the response, add custom objects to the request for later use, or terminate the response without processing the route logic. Examples Example 1 The following example is middleware that observes the user agent of the request. If the request comes from a PowerShell session then stop processing and return forbidden, otherwise create a new Agent key on the session for later middleware / route : Server { middleware { param ( $session ) if ( $session . Request . UserAgent -ilike '*powershell*' ) { status 403 return $false } $session . Agent = $session . Request . UserAgent return $true } } Example 2 The following example uses rate limiting, and defines middleware that will override the inbuilt rate limiting middleware logic so that it never limits requests: Server { listen * : 8080 http limit ip @( '127.0.0.1' , '[::1]' ) 8 5 middleware -Name '@limit' { return $true } route get '/' { # logic } } Parameters Name Type Required Description Default ScriptBlock scriptblock true The main logic for the middleware; this scriptblock will be supplied a single parameter which contains the Request and Response objects null Name string false Only use this parameter if you plan to override any of the inbuilt middleware. Names for the inbuilt middleware can be found below empty Notes Middleware in Pode is executed in a specific order due to having inbuilt middleware, this order of running is as follows: Access control - allowing/denying IP addresses (if access logic is defined) Rate limiting - limiting access to IP addresses (if limit logic is defined) Public content - content such as images/css/js in the public directory Body parsing - parsing request payload a JSON or XML Querystring - getting any query string parameters currently on the request URL Custom middleware - runs any defined middleware in the order it was created Route middleware - runs any route middleware for the current route being processed Route - finally, the route itself is processed Pode has some inbuilt middleware, as defined in the order of running above. Sometimes you probably don't want to use the inbuilt rate limiting, and use a custom rate limiting library that utilises REDIS instead. Each of the inbuilt middlewares have a defined name, that you can pass to the middleware function via -Name : Access control - @access Rate limiting - @limit Public content - @public Body parsing - @body Querystring - @query An example of overriding the inbuilt middleware can be found in the examples above","title":"Middleware"},{"location":"Functions/Core/Middleware/#middleware","text":"","title":"Middleware"},{"location":"Functions/Core/Middleware/#description","text":"The middleware function allows you to add middleware scripts, that run prior to route logic. They allow you to do things like rate-limiting, access restriction, sessions, etc. Middleware in Pode allows you to observe and edit the request/response objects for a current web request - you can alter the response, add custom objects to the request for later use, or terminate the response without processing the route logic.","title":"Description"},{"location":"Functions/Core/Middleware/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Middleware/#example-1","text":"The following example is middleware that observes the user agent of the request. If the request comes from a PowerShell session then stop processing and return forbidden, otherwise create a new Agent key on the session for later middleware / route : Server { middleware { param ( $session ) if ( $session . Request . UserAgent -ilike '*powershell*' ) { status 403 return $false } $session . Agent = $session . Request . UserAgent return $true } }","title":"Example 1"},{"location":"Functions/Core/Middleware/#example-2","text":"The following example uses rate limiting, and defines middleware that will override the inbuilt rate limiting middleware logic so that it never limits requests: Server { listen * : 8080 http limit ip @( '127.0.0.1' , '[::1]' ) 8 5 middleware -Name '@limit' { return $true } route get '/' { # logic } }","title":"Example 2"},{"location":"Functions/Core/Middleware/#parameters","text":"Name Type Required Description Default ScriptBlock scriptblock true The main logic for the middleware; this scriptblock will be supplied a single parameter which contains the Request and Response objects null Name string false Only use this parameter if you plan to override any of the inbuilt middleware. Names for the inbuilt middleware can be found below empty","title":"Parameters"},{"location":"Functions/Core/Middleware/#notes","text":"Middleware in Pode is executed in a specific order due to having inbuilt middleware, this order of running is as follows: Access control - allowing/denying IP addresses (if access logic is defined) Rate limiting - limiting access to IP addresses (if limit logic is defined) Public content - content such as images/css/js in the public directory Body parsing - parsing request payload a JSON or XML Querystring - getting any query string parameters currently on the request URL Custom middleware - runs any defined middleware in the order it was created Route middleware - runs any route middleware for the current route being processed Route - finally, the route itself is processed Pode has some inbuilt middleware, as defined in the order of running above. Sometimes you probably don't want to use the inbuilt rate limiting, and use a custom rate limiting library that utilises REDIS instead. Each of the inbuilt middlewares have a defined name, that you can pass to the middleware function via -Name : Access control - @access Rate limiting - @limit Public content - @public Body parsing - @body Querystring - @query An example of overriding the inbuilt middleware can be found in the examples above","title":"Notes"},{"location":"Functions/Core/Route/","text":"Route Description The route function allows you to bind specific logic to be invoked against a URL path and HTTP method. The function also accepts custom middleware to be executed, before running the main route logic - such as authentication. Info The scriptblock for the main route logic is invoked with a single parameter. This parameter will contain the Request and Response objects; Data (from POST requests), and the Query (from the query string of the URL), as well as any Parameters from the route itself (eg: /:accountId ). Examples Example 1 The following example sets up a GET /ping route, that returns value: pong : Server { listen * : 8080 http route get '/ping' { json @{ 'value' = 'ping' } } } Example 2 The following example sets up a POST /users route, that creates a new user using post data: Server { listen * : 8080 http route post '/users' { param ( $session ) # create the user using POST data $userId = New-DummyUser $session . Data . Email $session . Data . Name $session . Data . Password # return with userId json @{ 'userId' = $userId ; } } } Example 3 The following example sets up a GET /users/:userId route, that returns a user based on the route parameter userId : Server { listen * : 8080 http route get '/users/:userId' { param ( $session ) # get the user, using the parameter userId $user = Get-DummyUser -UserId $session . Parameters [ 'userId' ] # if no user, return 404 if ( $user -eq $null ) { status 404 } # return the user object json @{ 'user' = $user ; } } } Example 4 The following example sets up a GET / route, that has custom middleware to check the user agent first. If the user agent is from PowerShell deny the call, and don't invoke the route's logic: Server { listen * : 8080 http $agent_mid = { param ( $session ) if ( $session . Request . UserAgent -ilike '*powershell*' ) { status 403 # stop running return $false } $session . Agent = $session . Request . UserAgent # run the route logic return $true } route get '/' $agent_mid { view 'index' } } Parameters Name Type Required Description Default HttpMethod string true The HTTP method to bind the route onto (Values: DELETE, GET, HEAD, MERGE, OPTIONS, PATCH, POST, PUT, TRACE) null Route string true The route path to listen on, the root path is / . The path can also contain parmeters such as /:userId empty Middleware scriptblock[] false Custom middleware for the route that will be invoked before the main logic is invoked - such as authentication null ScriptBlock scriptblock true The main route logic that will be invoked when the route endpoint is hit null Tip There is a special * method you can use, which means a route that applies to every HTTP method","title":"Route"},{"location":"Functions/Core/Route/#route","text":"","title":"Route"},{"location":"Functions/Core/Route/#description","text":"The route function allows you to bind specific logic to be invoked against a URL path and HTTP method. The function also accepts custom middleware to be executed, before running the main route logic - such as authentication. Info The scriptblock for the main route logic is invoked with a single parameter. This parameter will contain the Request and Response objects; Data (from POST requests), and the Query (from the query string of the URL), as well as any Parameters from the route itself (eg: /:accountId ).","title":"Description"},{"location":"Functions/Core/Route/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Route/#example-1","text":"The following example sets up a GET /ping route, that returns value: pong : Server { listen * : 8080 http route get '/ping' { json @{ 'value' = 'ping' } } }","title":"Example 1"},{"location":"Functions/Core/Route/#example-2","text":"The following example sets up a POST /users route, that creates a new user using post data: Server { listen * : 8080 http route post '/users' { param ( $session ) # create the user using POST data $userId = New-DummyUser $session . Data . Email $session . Data . Name $session . Data . Password # return with userId json @{ 'userId' = $userId ; } } }","title":"Example 2"},{"location":"Functions/Core/Route/#example-3","text":"The following example sets up a GET /users/:userId route, that returns a user based on the route parameter userId : Server { listen * : 8080 http route get '/users/:userId' { param ( $session ) # get the user, using the parameter userId $user = Get-DummyUser -UserId $session . Parameters [ 'userId' ] # if no user, return 404 if ( $user -eq $null ) { status 404 } # return the user object json @{ 'user' = $user ; } } }","title":"Example 3"},{"location":"Functions/Core/Route/#example-4","text":"The following example sets up a GET / route, that has custom middleware to check the user agent first. If the user agent is from PowerShell deny the call, and don't invoke the route's logic: Server { listen * : 8080 http $agent_mid = { param ( $session ) if ( $session . Request . UserAgent -ilike '*powershell*' ) { status 403 # stop running return $false } $session . Agent = $session . Request . UserAgent # run the route logic return $true } route get '/' $agent_mid { view 'index' } }","title":"Example 4"},{"location":"Functions/Core/Route/#parameters","text":"Name Type Required Description Default HttpMethod string true The HTTP method to bind the route onto (Values: DELETE, GET, HEAD, MERGE, OPTIONS, PATCH, POST, PUT, TRACE) null Route string true The route path to listen on, the root path is / . The path can also contain parmeters such as /:userId empty Middleware scriptblock[] false Custom middleware for the route that will be invoked before the main logic is invoked - such as authentication null ScriptBlock scriptblock true The main route logic that will be invoked when the route endpoint is hit null Tip There is a special * method you can use, which means a route that applies to every HTTP method","title":"Parameters"},{"location":"Functions/Core/Schedule/","text":"Schedule Description The schedule function lets you create long-running async tasks. Unlike a timer however, when a schedule is triggered it's logic is run in its own runspace - so they don't affect each other if they take a while to process. Schedule triggers are defined using cron expressions , basic syntax is supported as well as some predefined expressions. They can start immediately, have a delayed start time, and also have a a defined end time. Examples Example 1 The following example will create a schedule that triggers every Tuesday at midnight: Server { schedule 'tuesdays' '0 0 * * TUE' { # logic } } Example 2 The following example will create a schedule that triggers every 5 past the hour, starting in 2hrs: Server { schedule 'hourly-start' '5 * * * *' -start ( [DateTime] :: Now . AddHours ( 2 )) { # logic } } Example 3 The following example will create a schedule using a predefined cron to trigger every minute: Server { schedule 'minutely' '@minutely' { # logic } } Parameters Name Type Required Description Default Name string true A unique name for the schedule empty Cron string true A cron expression to define when the schedule should trigger empty ScriptBlock scriptblock true The main logic that will be invoked on each trigger null StartTime datetime false Defines when the schedule should start now EndTime datetime false Defines when the schedule should end never","title":"Schedule"},{"location":"Functions/Core/Schedule/#schedule","text":"","title":"Schedule"},{"location":"Functions/Core/Schedule/#description","text":"The schedule function lets you create long-running async tasks. Unlike a timer however, when a schedule is triggered it's logic is run in its own runspace - so they don't affect each other if they take a while to process. Schedule triggers are defined using cron expressions , basic syntax is supported as well as some predefined expressions. They can start immediately, have a delayed start time, and also have a a defined end time.","title":"Description"},{"location":"Functions/Core/Schedule/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Schedule/#example-1","text":"The following example will create a schedule that triggers every Tuesday at midnight: Server { schedule 'tuesdays' '0 0 * * TUE' { # logic } }","title":"Example 1"},{"location":"Functions/Core/Schedule/#example-2","text":"The following example will create a schedule that triggers every 5 past the hour, starting in 2hrs: Server { schedule 'hourly-start' '5 * * * *' -start ( [DateTime] :: Now . AddHours ( 2 )) { # logic } }","title":"Example 2"},{"location":"Functions/Core/Schedule/#example-3","text":"The following example will create a schedule using a predefined cron to trigger every minute: Server { schedule 'minutely' '@minutely' { # logic } }","title":"Example 3"},{"location":"Functions/Core/Schedule/#parameters","text":"Name Type Required Description Default Name string true A unique name for the schedule empty Cron string true A cron expression to define when the schedule should trigger empty ScriptBlock scriptblock true The main logic that will be invoked on each trigger null StartTime datetime false Defines when the schedule should start now EndTime datetime false Defines when the schedule should end never","title":"Parameters"},{"location":"Functions/Core/Server/","text":"Server Description The Server function is the most important function throughout all of Pode, as it's the only function that is mandatory in your scripts. Within the scriptblock supplied to the Server is where you place all of your main server logic - routes, timers, middleware, etc. Warning You can only have one Server declared within your script Examples Example 1 The following example will run the scriptblock once, printing out Hello, world! , and then exit: Server { Write-Host 'Hello, world!' } Example 2 The following will start a server that repeats the scriptblock every 5 seconds: Server -Interval 5 { Write-Host 'Hey!' } Example 3 The following server will accept web requests, and handle them across 2 threads rather than 1: Server -Thread 2 { # route logic } Example 4 The following server will restart when it detects a file has been changed. Ie, if you start the server and then alter a web page, or change a dot-sourced script, then the server will restart: Server -FileMonitor { # route logic } Parameters Name Type Required Description Default ScriptBlock scriptblock true The main closure that contains the core server logic null Interval int false Specifies, in seconds, the time to sleep before looping the ScriptBlock logic 0 Threads int false Specifies the number of runspaces used to handle incoming requests 1 DisableTermination switch false Toggles the ability to allow using Ctrl+C to terminate the server false DisableLogging switch false Toggles any logging that has been setup. When true all logging is disabled false FileMonitor switch false When passed, any file changes will cause the server to restart false","title":"Server"},{"location":"Functions/Core/Server/#server","text":"","title":"Server"},{"location":"Functions/Core/Server/#description","text":"The Server function is the most important function throughout all of Pode, as it's the only function that is mandatory in your scripts. Within the scriptblock supplied to the Server is where you place all of your main server logic - routes, timers, middleware, etc. Warning You can only have one Server declared within your script","title":"Description"},{"location":"Functions/Core/Server/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Server/#example-1","text":"The following example will run the scriptblock once, printing out Hello, world! , and then exit: Server { Write-Host 'Hello, world!' }","title":"Example 1"},{"location":"Functions/Core/Server/#example-2","text":"The following will start a server that repeats the scriptblock every 5 seconds: Server -Interval 5 { Write-Host 'Hey!' }","title":"Example 2"},{"location":"Functions/Core/Server/#example-3","text":"The following server will accept web requests, and handle them across 2 threads rather than 1: Server -Thread 2 { # route logic }","title":"Example 3"},{"location":"Functions/Core/Server/#example-4","text":"The following server will restart when it detects a file has been changed. Ie, if you start the server and then alter a web page, or change a dot-sourced script, then the server will restart: Server -FileMonitor { # route logic }","title":"Example 4"},{"location":"Functions/Core/Server/#parameters","text":"Name Type Required Description Default ScriptBlock scriptblock true The main closure that contains the core server logic null Interval int false Specifies, in seconds, the time to sleep before looping the ScriptBlock logic 0 Threads int false Specifies the number of runspaces used to handle incoming requests 1 DisableTermination switch false Toggles the ability to allow using Ctrl+C to terminate the server false DisableLogging switch false Toggles any logging that has been setup. When true all logging is disabled false FileMonitor switch false When passed, any file changes will cause the server to restart false","title":"Parameters"},{"location":"Functions/Core/Timer/","text":"Timer Description The timer function allows you to setup short-running async tasks, that run periodically along side your main server logic; they have unique names, and iterate on a defined number of seconds. Info All timers are created and run within the same runspace, one after another when their trigger time occurs. You should ensure that a timer's defined logic is not long-running (things like heavy database tasks or reporting), as this will delay other timers from being run. For timers that might take a much longer time to run, try using schedule instead Examples Example 1 The following example is a timer that runs for ever, every 5secs: Server { timer 'forever' 5 { # logic } } Example 2 The following example is a timer that will skip the first 3 iterations, and after 15secs (3x5) will loop every 5secs: Server { timer 'skip-first-3' 5 -skip 3 { # logic } } Example 3 The following example is a timer that runs once after waiting for 2mins: Server { timer 'run-once' 120 -skip 1 -limit 1 { # logic } } Example 4 The following example will create a new timer every time the route is called - the route expects two query string parameters of Name an Seconds : Server { route 'get' '/api/timer' { param ( $session ) $query = $session . Query timer $query [ 'Name' ] $query [ 'Seconds' ] { # logic } } } Parameters Name Type Required Description Default Name string true The unique name of the timer empty Interval int true The number of seconds between each iteration 0 ScriptBlock scriptblock true The main logic that will be invoked on each timer iteration null Limit int false The number of iterations that should be invoked before the timer is removed 0 Skip int false The number of iterations to skip before invoking timer logic 0","title":"Timer"},{"location":"Functions/Core/Timer/#timer","text":"","title":"Timer"},{"location":"Functions/Core/Timer/#description","text":"The timer function allows you to setup short-running async tasks, that run periodically along side your main server logic; they have unique names, and iterate on a defined number of seconds. Info All timers are created and run within the same runspace, one after another when their trigger time occurs. You should ensure that a timer's defined logic is not long-running (things like heavy database tasks or reporting), as this will delay other timers from being run. For timers that might take a much longer time to run, try using schedule instead","title":"Description"},{"location":"Functions/Core/Timer/#examples","text":"","title":"Examples"},{"location":"Functions/Core/Timer/#example-1","text":"The following example is a timer that runs for ever, every 5secs: Server { timer 'forever' 5 { # logic } }","title":"Example 1"},{"location":"Functions/Core/Timer/#example-2","text":"The following example is a timer that will skip the first 3 iterations, and after 15secs (3x5) will loop every 5secs: Server { timer 'skip-first-3' 5 -skip 3 { # logic } }","title":"Example 2"},{"location":"Functions/Core/Timer/#example-3","text":"The following example is a timer that runs once after waiting for 2mins: Server { timer 'run-once' 120 -skip 1 -limit 1 { # logic } }","title":"Example 3"},{"location":"Functions/Core/Timer/#example-4","text":"The following example will create a new timer every time the route is called - the route expects two query string parameters of Name an Seconds : Server { route 'get' '/api/timer' { param ( $session ) $query = $session . Query timer $query [ 'Name' ] $query [ 'Seconds' ] { # logic } } }","title":"Example 4"},{"location":"Functions/Core/Timer/#parameters","text":"Name Type Required Description Default Name string true The unique name of the timer empty Interval int true The number of seconds between each iteration 0 ScriptBlock scriptblock true The main logic that will be invoked on each timer iteration null Limit int false The number of iterations that should be invoked before the timer is removed 0 Skip int false The number of iterations to skip before invoking timer logic 0","title":"Parameters"},{"location":"Functions/Helpers/Coalesce/","text":"Coalesce Description The coalesce function will return the first argument if it's not $null or empty , otherwise the second argument is returned. Examples Example 1 The following example will use the second value and output Hello! , because the first is $null : Server { $msg = ( coalesce $null 'Hello!' ) Write-Host $msg } Parameters Name Type Required Description Default Value1 object false The first value to check if it's $null null Value2 object false The second value to use if the first is $null null","title":"Coalesce"},{"location":"Functions/Helpers/Coalesce/#coalesce","text":"","title":"Coalesce"},{"location":"Functions/Helpers/Coalesce/#description","text":"The coalesce function will return the first argument if it's not $null or empty , otherwise the second argument is returned.","title":"Description"},{"location":"Functions/Helpers/Coalesce/#examples","text":"","title":"Examples"},{"location":"Functions/Helpers/Coalesce/#example-1","text":"The following example will use the second value and output Hello! , because the first is $null : Server { $msg = ( coalesce $null 'Hello!' ) Write-Host $msg }","title":"Example 1"},{"location":"Functions/Helpers/Coalesce/#parameters","text":"Name Type Required Description Default Value1 object false The first value to check if it's $null null Value2 object false The second value to use if the first is $null null","title":"Parameters"},{"location":"Functions/Helpers/Invoke-ScriptBlock/","text":"Invoke-ScriptBlock Description The Invoke-ScriptBlock function takes a scriptblock and invokes it. You can specify arguments, and whether a value should be returned. By default the scriptblock will have the GetNewClosure() method called, and will be invoked in the current scope; these can be toggled via -NoNewClosure and -Scoped respectively. If any arguments are supplied, they will be supplied as a single argument to the scriptblock. By using the -Splat switch, then if the arguments are an array/hashtable they will be passed as multiple arguments instead. Examples Example 1 The following example will invoke a scriptblock outside of the current scope: Server { Invoke-ScriptBlock -Scoped { Write-Host 'Hello, world!' } } Example 2 The following example will invoke a scriptblock, passing it arguments and returning a value: Server { $ht = @{ 'Name' = 'Bob' ; 'Age' = 32 ; } $value = ( Invoke-ScriptBlock -Arguments $ht { param ( $opts ) return \"Hello, $( $opts . Name ) ! You're $( $opts . Age ) years old.\" }) } Example 3 The following example will invoke a scriptblock, passing it arguments and splatting them to the scriptblock: Server { $ht = @{ 'Name' = 'Bob' ; 'Age' = 32 ; } Invoke-ScriptBlock -Arguments $ht -Splat { param ( $name , $age ) Write-Host \"Hello, $( $name ) ! You're $( $age ) years old.\" }) } Parameters Name Type Required Description Default ScriptBlock scriptblock true ... null Arguments hashtable/array false ... null Scoped switch false ... false Return switch false ... false Splat switch false ... false NoNewClosure switch false ... false","title":"Invoke-ScriptBlock"},{"location":"Functions/Helpers/Invoke-ScriptBlock/#invoke-scriptblock","text":"","title":"Invoke-ScriptBlock"},{"location":"Functions/Helpers/Invoke-ScriptBlock/#description","text":"The Invoke-ScriptBlock function takes a scriptblock and invokes it. You can specify arguments, and whether a value should be returned. By default the scriptblock will have the GetNewClosure() method called, and will be invoked in the current scope; these can be toggled via -NoNewClosure and -Scoped respectively. If any arguments are supplied, they will be supplied as a single argument to the scriptblock. By using the -Splat switch, then if the arguments are an array/hashtable they will be passed as multiple arguments instead.","title":"Description"},{"location":"Functions/Helpers/Invoke-ScriptBlock/#examples","text":"","title":"Examples"},{"location":"Functions/Helpers/Invoke-ScriptBlock/#example-1","text":"The following example will invoke a scriptblock outside of the current scope: Server { Invoke-ScriptBlock -Scoped { Write-Host 'Hello, world!' } }","title":"Example 1"},{"location":"Functions/Helpers/Invoke-ScriptBlock/#example-2","text":"The following example will invoke a scriptblock, passing it arguments and returning a value: Server { $ht = @{ 'Name' = 'Bob' ; 'Age' = 32 ; } $value = ( Invoke-ScriptBlock -Arguments $ht { param ( $opts ) return \"Hello, $( $opts . Name ) ! You're $( $opts . Age ) years old.\" }) }","title":"Example 2"},{"location":"Functions/Helpers/Invoke-ScriptBlock/#example-3","text":"The following example will invoke a scriptblock, passing it arguments and splatting them to the scriptblock: Server { $ht = @{ 'Name' = 'Bob' ; 'Age' = 32 ; } Invoke-ScriptBlock -Arguments $ht -Splat { param ( $name , $age ) Write-Host \"Hello, $( $name ) ! You're $( $age ) years old.\" }) }","title":"Example 3"},{"location":"Functions/Helpers/Invoke-ScriptBlock/#parameters","text":"Name Type Required Description Default ScriptBlock scriptblock true ... null Arguments hashtable/array false ... null Scoped switch false ... false Return switch false ... false Splat switch false ... false NoNewClosure switch false ... false","title":"Parameters"},{"location":"Functions/Helpers/Test-Empty/","text":"Test-Empty Description The Test-Empty function will return whether the value supplied is either empty , $null or its length is zero. Tip The function supports virtually every type from array to string , even scriptblock . Note The function will automatically return $false if the value is a ValueType , such as float , int , bool etc. Examples Example 1 The following example will return $true and run the logic because the array is empty: Server { if ( Test-Empty @()) { # logic } } Example 2 The following example will return $false and not run the logic because the string is not empty: Server { if ( Test-Empty 'contains a value' ) { # logic } } Example 3 The following example will return $true and run the logic because the hashtable is empty: Server { if ( Test-Empty @{}) { # logic } } Parameters Name Type Required Description Default Value object false The value to check if it is empty, null or zero-length null","title":"Test-Empty"},{"location":"Functions/Helpers/Test-Empty/#test-empty","text":"","title":"Test-Empty"},{"location":"Functions/Helpers/Test-Empty/#description","text":"The Test-Empty function will return whether the value supplied is either empty , $null or its length is zero. Tip The function supports virtually every type from array to string , even scriptblock . Note The function will automatically return $false if the value is a ValueType , such as float , int , bool etc.","title":"Description"},{"location":"Functions/Helpers/Test-Empty/#examples","text":"","title":"Examples"},{"location":"Functions/Helpers/Test-Empty/#example-1","text":"The following example will return $true and run the logic because the array is empty: Server { if ( Test-Empty @()) { # logic } }","title":"Example 1"},{"location":"Functions/Helpers/Test-Empty/#example-2","text":"The following example will return $false and not run the logic because the string is not empty: Server { if ( Test-Empty 'contains a value' ) { # logic } }","title":"Example 2"},{"location":"Functions/Helpers/Test-Empty/#example-3","text":"The following example will return $true and run the logic because the hashtable is empty: Server { if ( Test-Empty @{}) { # logic } }","title":"Example 3"},{"location":"Functions/Helpers/Test-Empty/#parameters","text":"Name Type Required Description Default Value object false The value to check if it is empty, null or zero-length null","title":"Parameters"},{"location":"Functions/Helpers/Test-IsPSCore/","text":"Test-IsPSCore Description The Test-IsPSCore function will return $true if Pode is running using PowerShell Core (v6.0+), $false otherwise. Examples Example 1 The following example will return whether Pode is running on PowerShell Core: Server { listen * : 8080 http route get '/env' { json @{ 'PSCore' = ( Test-IsPSCore ) } } } Parameters None.","title":"Test-IsPSCore"},{"location":"Functions/Helpers/Test-IsPSCore/#test-ispscore","text":"","title":"Test-IsPSCore"},{"location":"Functions/Helpers/Test-IsPSCore/#description","text":"The Test-IsPSCore function will return $true if Pode is running using PowerShell Core (v6.0+), $false otherwise.","title":"Description"},{"location":"Functions/Helpers/Test-IsPSCore/#examples","text":"","title":"Examples"},{"location":"Functions/Helpers/Test-IsPSCore/#example-1","text":"The following example will return whether Pode is running on PowerShell Core: Server { listen * : 8080 http route get '/env' { json @{ 'PSCore' = ( Test-IsPSCore ) } } }","title":"Example 1"},{"location":"Functions/Helpers/Test-IsPSCore/#parameters","text":"None.","title":"Parameters"},{"location":"Functions/Helpers/Test-IsUnix/","text":"Test-IsUnix Description The Test-IsUnix function will return $true if Pode is running on a *nix environment, $false otherwise. Examples Example 1 The following example will return whether the current environment is *nix: Server { listen * : 8080 http route get '/env' { json @{ 'Unix' = ( Test-IsUnix ) } } } Parameters None.","title":"Test-IsUnix"},{"location":"Functions/Helpers/Test-IsUnix/#test-isunix","text":"","title":"Test-IsUnix"},{"location":"Functions/Helpers/Test-IsUnix/#description","text":"The Test-IsUnix function will return $true if Pode is running on a *nix environment, $false otherwise.","title":"Description"},{"location":"Functions/Helpers/Test-IsUnix/#examples","text":"","title":"Examples"},{"location":"Functions/Helpers/Test-IsUnix/#example-1","text":"The following example will return whether the current environment is *nix: Server { listen * : 8080 http route get '/env' { json @{ 'Unix' = ( Test-IsUnix ) } } }","title":"Example 1"},{"location":"Functions/Helpers/Test-IsUnix/#parameters","text":"None.","title":"Parameters"},{"location":"Functions/Helpers/Test-IsWindows/","text":"Test-IsWindows Description The Test-IsWindows function will return $true if Pode is running on a Windows environment, $false otherwise. Examples Example 1 The following example will return whether the current environment is Windows: Server { listen * : 8080 http route get '/env' { json @{ 'Windows' = ( Test-IsWindows ) } } } Parameters None.","title":"Test-IsWindows"},{"location":"Functions/Helpers/Test-IsWindows/#test-iswindows","text":"","title":"Test-IsWindows"},{"location":"Functions/Helpers/Test-IsWindows/#description","text":"The Test-IsWindows function will return $true if Pode is running on a Windows environment, $false otherwise.","title":"Description"},{"location":"Functions/Helpers/Test-IsWindows/#examples","text":"","title":"Examples"},{"location":"Functions/Helpers/Test-IsWindows/#example-1","text":"The following example will return whether the current environment is Windows: Server { listen * : 8080 http route get '/env' { json @{ 'Windows' = ( Test-IsWindows ) } } }","title":"Example 1"},{"location":"Functions/Helpers/Test-IsWindows/#parameters","text":"None.","title":"Parameters"},{"location":"Functions/Middleware/Auth/","text":"Auth Description The auth function allows you to setup/use and validate/check against defined authentication methods on web requests; this could be Basic or Form authentication, to custom defined authentication. Authentication can either be sessionless (requiring validation on every request), or session-persistent (only requiring validation once, and then checks against a session signed-cookie). Actions Use The auth use action allows you to specify and configure which authentication methods your server will use; you can have many of them, defining which one to validate against on the auth check action. The name of the method specified should be a valid inbuilt method, unless you have stated that the method is custom. If custom, you must supply a parser script which will parse payloads/headers for credentials and then return this data as an array - which will then be supplied to the validator script. Check The auth check action allows you to define which authentication method to validate a request against. The action returns a valid middleware script, meaning you can either use this action on specific route definitions, or globally for all routes as middleware . If this action fails, then a 401 response is returned. On success, this action will then allow the route logic to be invoked. If session middleware has been configured then an authenticated session is also created for future requests. When the user makes another call using the same authenticated session, then the auth check action will detect the already authenticated session and skip the validator script. If you're using sessions and you don't want the auth check to check the session, or store the user against the session, then pass -o @{ 'Session' = $false } to the auth check . The following table contains options that you can supply to an auth check -o @{} call - these are all optional: Name Description Default FailureUrl The URL to redirect to should authentication fail empty SuccessUrl The URL to redirect to should authenticationh succeed empty Session If true, check if the session already has an authenticated user; storing the user in the session if they are authenticated true Login If true, check the authentication status in the session and redirect to the SuccessUrl if the user is authenticated. Otherwise proceed to the page with no authentication required false Logout If true, purge the session and redirect to the FailureUrl false Info The Login option allows you to have authentication on your login pages, such that if there is no user in a current session then the login page displays - rather then being 401'd. Whereas if there is an authenticated user in the session it will auto-redirect to the SuccessUrl . Examples Example 1 The following example will setup sessionless Basic authentication, and then use it as route middleware. This will require authentication on every request. The basic authentication will check for an { \"Authorization\": \"Basic user:pass\" } header on the request: Server { listen * : 8080 http # setup basic auth, with validator to check the user auth use basic -v { param ( $username , $pass ) # check if the user is valid return @{ 'user' = $user } } # check the request against the above auth route get '/info' ( auth check basic ) { json @{ 'cpu' = 82 } } } Example 2 The following example will setup sessionless Form authentication, and set it as global middleware for every route . This will require authentication on every request. The form authentication will check the POST payload for a username and password , supplied from a <form> : Server { listen * : 8080 http # setup form auth, with validator to check the user auth use form -v { param ( $username , $pass ) # check if the user is valid return @{ 'user' = $user } } # apply the auth check as global middleware middleware ( auth check form ) # the route will use the above auth middleware route get '/info' { json @{ 'cpu' = 82 } } } Example 3 The following example will setup session-persistent Basic authentication, and then use it as route middleware. This will only require authentication once, and the the check will succeed if the authenticated session cookie is passed: Server { listen * : 8080 http # configure session middleware to bind the auth'd user against middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; }) # setup basic auth, with validator to check the user auth use basic -v { param ( $username , $pass ) # check if the user is valid return @{ 'user' = $user } } # check the request against the above auth route get '/info' ( auth check basic ) { json @{ 'cpu' = 82 } } } Parameters Name Type Required Description Default Action string true The action to perform on the auth function (Values: Use, Check) empty Name string true The name of the authentication middleware; if -Custom is not specified, then this will be the name of an inbuilt authentication method empty Validator scriptblock false A script that will be passed user credentials, here you can validate the user is valid and exists in some data store null Parser scriptblock false If -Custom is supplied then this parameter is required. This is the custom script where you can parse payloads/querystring or headers to source user credentials, that will then be supplied to your validator null Options hashtable false A hashtable of options to customise the authentication method. Depending on the method is this be options like FieldName or Encoding null Custom switch false If passed, states that this authentication method is a custom defined method false","title":"Auth"},{"location":"Functions/Middleware/Auth/#auth","text":"","title":"Auth"},{"location":"Functions/Middleware/Auth/#description","text":"The auth function allows you to setup/use and validate/check against defined authentication methods on web requests; this could be Basic or Form authentication, to custom defined authentication. Authentication can either be sessionless (requiring validation on every request), or session-persistent (only requiring validation once, and then checks against a session signed-cookie).","title":"Description"},{"location":"Functions/Middleware/Auth/#actions","text":"","title":"Actions"},{"location":"Functions/Middleware/Auth/#use","text":"The auth use action allows you to specify and configure which authentication methods your server will use; you can have many of them, defining which one to validate against on the auth check action. The name of the method specified should be a valid inbuilt method, unless you have stated that the method is custom. If custom, you must supply a parser script which will parse payloads/headers for credentials and then return this data as an array - which will then be supplied to the validator script.","title":"Use"},{"location":"Functions/Middleware/Auth/#check","text":"The auth check action allows you to define which authentication method to validate a request against. The action returns a valid middleware script, meaning you can either use this action on specific route definitions, or globally for all routes as middleware . If this action fails, then a 401 response is returned. On success, this action will then allow the route logic to be invoked. If session middleware has been configured then an authenticated session is also created for future requests. When the user makes another call using the same authenticated session, then the auth check action will detect the already authenticated session and skip the validator script. If you're using sessions and you don't want the auth check to check the session, or store the user against the session, then pass -o @{ 'Session' = $false } to the auth check . The following table contains options that you can supply to an auth check -o @{} call - these are all optional: Name Description Default FailureUrl The URL to redirect to should authentication fail empty SuccessUrl The URL to redirect to should authenticationh succeed empty Session If true, check if the session already has an authenticated user; storing the user in the session if they are authenticated true Login If true, check the authentication status in the session and redirect to the SuccessUrl if the user is authenticated. Otherwise proceed to the page with no authentication required false Logout If true, purge the session and redirect to the FailureUrl false Info The Login option allows you to have authentication on your login pages, such that if there is no user in a current session then the login page displays - rather then being 401'd. Whereas if there is an authenticated user in the session it will auto-redirect to the SuccessUrl .","title":"Check"},{"location":"Functions/Middleware/Auth/#examples","text":"","title":"Examples"},{"location":"Functions/Middleware/Auth/#example-1","text":"The following example will setup sessionless Basic authentication, and then use it as route middleware. This will require authentication on every request. The basic authentication will check for an { \"Authorization\": \"Basic user:pass\" } header on the request: Server { listen * : 8080 http # setup basic auth, with validator to check the user auth use basic -v { param ( $username , $pass ) # check if the user is valid return @{ 'user' = $user } } # check the request against the above auth route get '/info' ( auth check basic ) { json @{ 'cpu' = 82 } } }","title":"Example 1"},{"location":"Functions/Middleware/Auth/#example-2","text":"The following example will setup sessionless Form authentication, and set it as global middleware for every route . This will require authentication on every request. The form authentication will check the POST payload for a username and password , supplied from a <form> : Server { listen * : 8080 http # setup form auth, with validator to check the user auth use form -v { param ( $username , $pass ) # check if the user is valid return @{ 'user' = $user } } # apply the auth check as global middleware middleware ( auth check form ) # the route will use the above auth middleware route get '/info' { json @{ 'cpu' = 82 } } }","title":"Example 2"},{"location":"Functions/Middleware/Auth/#example-3","text":"The following example will setup session-persistent Basic authentication, and then use it as route middleware. This will only require authentication once, and the the check will succeed if the authenticated session cookie is passed: Server { listen * : 8080 http # configure session middleware to bind the auth'd user against middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; }) # setup basic auth, with validator to check the user auth use basic -v { param ( $username , $pass ) # check if the user is valid return @{ 'user' = $user } } # check the request against the above auth route get '/info' ( auth check basic ) { json @{ 'cpu' = 82 } } }","title":"Example 3"},{"location":"Functions/Middleware/Auth/#parameters","text":"Name Type Required Description Default Action string true The action to perform on the auth function (Values: Use, Check) empty Name string true The name of the authentication middleware; if -Custom is not specified, then this will be the name of an inbuilt authentication method empty Validator scriptblock false A script that will be passed user credentials, here you can validate the user is valid and exists in some data store null Parser scriptblock false If -Custom is supplied then this parameter is required. This is the custom script where you can parse payloads/querystring or headers to source user credentials, that will then be supplied to your validator null Options hashtable false A hashtable of options to customise the authentication method. Depending on the method is this be options like FieldName or Encoding null Custom switch false If passed, states that this authentication method is a custom defined method false","title":"Parameters"},{"location":"Functions/Middleware/Session/","text":"Session Description The session function creates and returns a middleware that enables session cookies. Session middleware attaches onto web requests/responses, and uses signed-cookies and server-side data storage. When configured, the middleware will check for a session-cookie on the request; if a cookie is not found on the request, or the session is not in the store, then a new session is created and attached to the response. If there is a session, then the appropriate data is loaded from the store. The age of the session-cookie can be specified (and whether to extend the duration each time), as well as a secret-key to sign cookies, and the ability to specify custom data stores - the default is in-memory, so custom stores could be anything like redis/mongo. Examples Example 1 The following example sets up basic session middleware, using a secret key and a 5min fixed duration: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; }) } Example 2 The following example sets up session middleware with a non-default cookie name, and a sliding 5min duration: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; 'Extend' = $true ; 'Name' = 'session.id' ; }) } Example 3 The following example sets up session middleware with a custom SessionId script generator; to use a random filename instead of a guid: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; 'GenerateId' = { return [System.IO.Path] :: GetRandomFileName () } }) } Example 4 The following example sets up basic session middleware, and defines a route that adds data to the session. Each subsequent call to the route will increment the views counter: Server { listen * : 8080 http middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; }) route get '/' { $param ( $s ) $s . Session . Data . Views ++ json @{ 'Views' = $s . Session . Data . Views } } } Parameters Note The session function takes a single hashtable as its parameter. The below parameters are the expected keys that should be present within the supplied parameter Name Type Required Description Default Secret string true The secret key used to sign the cookies empty Name string false The name of the session cookie pode.sid Duration int false The duration of which the cookie lasts, in seconds (>=0) 0 Extend bool false If true, the duration of the cookie will be extended each time a request is made using the session false Discard bool false If true, informs the enduser's browser to discard the cookie on expiry false Secure bool false If true, informs the enduser's browser to only send the cookie on secure connections false GenerateId scriptblock false A script that should return a valid string. The string itself should be a random unique value, that can be used as a session identifier guid Store psobject false An object that defines specific functions to communicate with a custom data store null Notes Stores A store should be a psobject that requires the following functions: [hashtable] Get ( [string] $sessionId ) [void] Set ( [string] $sessionId , [hashtable] $data , [datetime] $expiry ) [void] Delete ( [string] $sessionId )","title":"Session"},{"location":"Functions/Middleware/Session/#session","text":"","title":"Session"},{"location":"Functions/Middleware/Session/#description","text":"The session function creates and returns a middleware that enables session cookies. Session middleware attaches onto web requests/responses, and uses signed-cookies and server-side data storage. When configured, the middleware will check for a session-cookie on the request; if a cookie is not found on the request, or the session is not in the store, then a new session is created and attached to the response. If there is a session, then the appropriate data is loaded from the store. The age of the session-cookie can be specified (and whether to extend the duration each time), as well as a secret-key to sign cookies, and the ability to specify custom data stores - the default is in-memory, so custom stores could be anything like redis/mongo.","title":"Description"},{"location":"Functions/Middleware/Session/#examples","text":"","title":"Examples"},{"location":"Functions/Middleware/Session/#example-1","text":"The following example sets up basic session middleware, using a secret key and a 5min fixed duration: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; }) }","title":"Example 1"},{"location":"Functions/Middleware/Session/#example-2","text":"The following example sets up session middleware with a non-default cookie name, and a sliding 5min duration: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; 'Extend' = $true ; 'Name' = 'session.id' ; }) }","title":"Example 2"},{"location":"Functions/Middleware/Session/#example-3","text":"The following example sets up session middleware with a custom SessionId script generator; to use a random filename instead of a guid: Server { middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; 'GenerateId' = { return [System.IO.Path] :: GetRandomFileName () } }) }","title":"Example 3"},{"location":"Functions/Middleware/Session/#example-4","text":"The following example sets up basic session middleware, and defines a route that adds data to the session. Each subsequent call to the route will increment the views counter: Server { listen * : 8080 http middleware ( session @{ 'Secret' = 'schwifty' ; 'Duration' = 300 ; }) route get '/' { $param ( $s ) $s . Session . Data . Views ++ json @{ 'Views' = $s . Session . Data . Views } } }","title":"Example 4"},{"location":"Functions/Middleware/Session/#parameters","text":"Note The session function takes a single hashtable as its parameter. The below parameters are the expected keys that should be present within the supplied parameter Name Type Required Description Default Secret string true The secret key used to sign the cookies empty Name string false The name of the session cookie pode.sid Duration int false The duration of which the cookie lasts, in seconds (>=0) 0 Extend bool false If true, the duration of the cookie will be extended each time a request is made using the session false Discard bool false If true, informs the enduser's browser to discard the cookie on expiry false Secure bool false If true, informs the enduser's browser to only send the cookie on secure connections false GenerateId scriptblock false A script that should return a valid string. The string itself should be a random unique value, that can be used as a session identifier guid Store psobject false An object that defines specific functions to communicate with a custom data store null","title":"Parameters"},{"location":"Functions/Middleware/Session/#notes","text":"","title":"Notes"},{"location":"Functions/Middleware/Session/#stores","text":"A store should be a psobject that requires the following functions: [hashtable] Get ( [string] $sessionId ) [void] Set ( [string] $sessionId , [hashtable] $data , [datetime] $expiry ) [void] Delete ( [string] $sessionId )","title":"Stores"},{"location":"Functions/Response/Attach/","text":"Attach Description The attach function allows you to attach files in the /public directory onto the web response. This allows the files to be downloaded by the end-user. Examples Example 1 The following example attaches the installer found at /public/downloads/installer.exe onto the response, when the http://localhost:8080/app/install endpoint is hit: Server { listen * : 8080 http route get '/app/install' { attach 'downloads/installer.exe' } } Parameters Name Type Required Description Default Path string true The path to the file to attach, relative to your /public directory null","title":"Attach"},{"location":"Functions/Response/Attach/#attach","text":"","title":"Attach"},{"location":"Functions/Response/Attach/#description","text":"The attach function allows you to attach files in the /public directory onto the web response. This allows the files to be downloaded by the end-user.","title":"Description"},{"location":"Functions/Response/Attach/#examples","text":"","title":"Examples"},{"location":"Functions/Response/Attach/#example-1","text":"The following example attaches the installer found at /public/downloads/installer.exe onto the response, when the http://localhost:8080/app/install endpoint is hit: Server { listen * : 8080 http route get '/app/install' { attach 'downloads/installer.exe' } }","title":"Example 1"},{"location":"Functions/Response/Attach/#parameters","text":"Name Type Required Description Default Path string true The path to the file to attach, relative to your /public directory null","title":"Parameters"},{"location":"Functions/Response/Csv/","text":"Csv Description The csv function converts an array of hashtable values, or reads in a file, and converts it to a CSV; the value is then written to the web response. You can also supply raw CSV data as the value to write. Examples Example 1 The following example will convert an array of hashtable values to a CSV and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { csv @( @{ 'Name' = 'Bob' ; 'Age' = 29 }, @{ 'Name' = 'James' ; 'Age' = 23 }) } } Example 2 The following example will write raw CSV data to a web response within a route : Server { listen * : 8080 http route get '/info' { csv \"Name, Age `n Bob, 29 `n James, 23\" } } Example 3 The following example will read in a file, and write the contents as CSV to a web response within a route : Server { listen * : 8080 http route get '/data' { csv -file './files/data.csv' } } Parameters Name Type Required Description Default Value hashtable[]/string true The value should either be an array of hashtable values or string - the string can be either a path or raw CSV. It will be converted to CSV, if not raw, and attached to the web response null File switch false If passed, the value should be a string that's a path to a CSV file false","title":"Csv"},{"location":"Functions/Response/Csv/#csv","text":"","title":"Csv"},{"location":"Functions/Response/Csv/#description","text":"The csv function converts an array of hashtable values, or reads in a file, and converts it to a CSV; the value is then written to the web response. You can also supply raw CSV data as the value to write.","title":"Description"},{"location":"Functions/Response/Csv/#examples","text":"","title":"Examples"},{"location":"Functions/Response/Csv/#example-1","text":"The following example will convert an array of hashtable values to a CSV and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { csv @( @{ 'Name' = 'Bob' ; 'Age' = 29 }, @{ 'Name' = 'James' ; 'Age' = 23 }) } }","title":"Example 1"},{"location":"Functions/Response/Csv/#example-2","text":"The following example will write raw CSV data to a web response within a route : Server { listen * : 8080 http route get '/info' { csv \"Name, Age `n Bob, 29 `n James, 23\" } }","title":"Example 2"},{"location":"Functions/Response/Csv/#example-3","text":"The following example will read in a file, and write the contents as CSV to a web response within a route : Server { listen * : 8080 http route get '/data' { csv -file './files/data.csv' } }","title":"Example 3"},{"location":"Functions/Response/Csv/#parameters","text":"Name Type Required Description Default Value hashtable[]/string true The value should either be an array of hashtable values or string - the string can be either a path or raw CSV. It will be converted to CSV, if not raw, and attached to the web response null File switch false If passed, the value should be a string that's a path to a CSV file false","title":"Parameters"},{"location":"Functions/Response/Html/","text":"Html Description The html function reads in an HTML file and then writes to content the web response. You can also supply raw HTML data as the value to write. Examples Example 1 The following example will write raw HTML data to a web response within a route : Server { listen * : 8080 http route get '/info' { html '<html><head><title>Example</title></head><body>Hello, world!</body></html>' } } Example 2 The following example will read in a file, and write the contents as HTML to a web response within a route : Server { listen * : 8080 http route get '/data' { html -file './files/data.html' } } Parameters Name Type Required Description Default Value string true The value should be a string, of either a path or raw HTML. It will be attached to the web response null File switch false If passed, the above value should be a string that's a path to an HTML file false","title":"Html"},{"location":"Functions/Response/Html/#html","text":"","title":"Html"},{"location":"Functions/Response/Html/#description","text":"The html function reads in an HTML file and then writes to content the web response. You can also supply raw HTML data as the value to write.","title":"Description"},{"location":"Functions/Response/Html/#examples","text":"","title":"Examples"},{"location":"Functions/Response/Html/#example-1","text":"The following example will write raw HTML data to a web response within a route : Server { listen * : 8080 http route get '/info' { html '<html><head><title>Example</title></head><body>Hello, world!</body></html>' } }","title":"Example 1"},{"location":"Functions/Response/Html/#example-2","text":"The following example will read in a file, and write the contents as HTML to a web response within a route : Server { listen * : 8080 http route get '/data' { html -file './files/data.html' } }","title":"Example 2"},{"location":"Functions/Response/Html/#parameters","text":"Name Type Required Description Default Value string true The value should be a string, of either a path or raw HTML. It will be attached to the web response null File switch false If passed, the above value should be a string that's a path to an HTML file false","title":"Parameters"},{"location":"Functions/Response/Json/","text":"Json Description The json function converts a hashtable , or reads in a file, and converts it to JSON; the JSON value is then written to the web response. You can also supply raw JSON data as the value to write. Examples Example 1 The following example will convert a hashtable to JSON and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { json @{ 'cpu' = 80 ; 'memory' = 15 ; } } } Example 2 The following example will write raw JSON data to a web response within a route : Server { listen * : 8080 http route get '/info' { json '{ \"cpu\": 80, \"memory\": 15 }' } } Example 3 The following example will read in a file, and write the contents as JSON to a web response within a route : Server { listen * : 8080 http route get '/data' { json -file './files/data.json' } } Parameters Name Type Required Description Default Value hashtable/string false The value should either be a hashtable or string - the string can be either a path or raw JSON. It will be converted to JSON, if not raw, and attached to the web response null File switch false If passed, the value should be a string that's a path to a JSON file false","title":"Json"},{"location":"Functions/Response/Json/#json","text":"","title":"Json"},{"location":"Functions/Response/Json/#description","text":"The json function converts a hashtable , or reads in a file, and converts it to JSON; the JSON value is then written to the web response. You can also supply raw JSON data as the value to write.","title":"Description"},{"location":"Functions/Response/Json/#examples","text":"","title":"Examples"},{"location":"Functions/Response/Json/#example-1","text":"The following example will convert a hashtable to JSON and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { json @{ 'cpu' = 80 ; 'memory' = 15 ; } } }","title":"Example 1"},{"location":"Functions/Response/Json/#example-2","text":"The following example will write raw JSON data to a web response within a route : Server { listen * : 8080 http route get '/info' { json '{ \"cpu\": 80, \"memory\": 15 }' } }","title":"Example 2"},{"location":"Functions/Response/Json/#example-3","text":"The following example will read in a file, and write the contents as JSON to a web response within a route : Server { listen * : 8080 http route get '/data' { json -file './files/data.json' } }","title":"Example 3"},{"location":"Functions/Response/Json/#parameters","text":"Name Type Required Description Default Value hashtable/string false The value should either be a hashtable or string - the string can be either a path or raw JSON. It will be converted to JSON, if not raw, and attached to the web response null File switch false If passed, the value should be a string that's a path to a JSON file false","title":"Parameters"},{"location":"Functions/Response/Redirect/","text":"Redirect Description The redirect function allows you to specify a URL to which to redirect the enduser. You can either specify a raw or relative URL, or alter the current request URI's port/protocol - such as redirecting from HTTP to HTTPS. Examples Example 1 The following example will redirect the enduser to https://google.com : Server { listen * : 8080 http route get '/google' { redirect -url 'https://google.com' } } Example 2 Assuming the current request URI is http://localhost:8080 , then the following example will redirect the enduser to http://localhost:8090 : Server { listen * : 8080 http route get '/' { redirect -port 8090 } } Example 3 Assuming the current request URI is http://localhost:8080 , then the following example will redirect the enduser to https://localhost:8080 : Server { listen * : 8080 http route get '/' { redirect -protocol https } } Example 4 The following example will redirect every method and route to https: Server { listen * : 8080 http route * * { redirect -protocol https } } Parameters Name Type Required Description Default Url string false The raw, or relative, URL to which the enduser should be redirected empty Port int false If no URL is supplied, then the redirect will be based on the current request URI's port. This parameter will override the current port of the request URI 0 Protocol string false If no URL is supplied, then the redirect will be based on the current request URI's protocol. This parameter will override the current protocol of the request URI (Values: Empty, HTTP, HTTPS) empty Moved switch false If flagged, the redirect will be done as a 301 Moved status, rather than a 302 Redirect false","title":"Redirect"},{"location":"Functions/Response/Redirect/#redirect","text":"","title":"Redirect"},{"location":"Functions/Response/Redirect/#description","text":"The redirect function allows you to specify a URL to which to redirect the enduser. You can either specify a raw or relative URL, or alter the current request URI's port/protocol - such as redirecting from HTTP to HTTPS.","title":"Description"},{"location":"Functions/Response/Redirect/#examples","text":"","title":"Examples"},{"location":"Functions/Response/Redirect/#example-1","text":"The following example will redirect the enduser to https://google.com : Server { listen * : 8080 http route get '/google' { redirect -url 'https://google.com' } }","title":"Example 1"},{"location":"Functions/Response/Redirect/#example-2","text":"Assuming the current request URI is http://localhost:8080 , then the following example will redirect the enduser to http://localhost:8090 : Server { listen * : 8080 http route get '/' { redirect -port 8090 } }","title":"Example 2"},{"location":"Functions/Response/Redirect/#example-3","text":"Assuming the current request URI is http://localhost:8080 , then the following example will redirect the enduser to https://localhost:8080 : Server { listen * : 8080 http route get '/' { redirect -protocol https } }","title":"Example 3"},{"location":"Functions/Response/Redirect/#example-4","text":"The following example will redirect every method and route to https: Server { listen * : 8080 http route * * { redirect -protocol https } }","title":"Example 4"},{"location":"Functions/Response/Redirect/#parameters","text":"Name Type Required Description Default Url string false The raw, or relative, URL to which the enduser should be redirected empty Port int false If no URL is supplied, then the redirect will be based on the current request URI's port. This parameter will override the current port of the request URI 0 Protocol string false If no URL is supplied, then the redirect will be based on the current request URI's protocol. This parameter will override the current protocol of the request URI (Values: Empty, HTTP, HTTPS) empty Moved switch false If flagged, the redirect will be done as a 301 Moved status, rather than a 302 Redirect false","title":"Parameters"},{"location":"Functions/Response/Status/","text":"Status Description The status function allows you to specify a specific status code, and optional a status description. Examples Example 1 The following example sets the status code of the response to be 404: Server { listen * : 8080 http route get '/missing' { status 404 } } Example 2 The following example sets the status code and description of the response to be 500: Server { listen * : 8080 http route get '/error' { status 500 'Oh no! Something went wrong!' } } Parameters Name Type Required Description Default Code int true The status code to set on the web response 0 Description string false The status description to set on the response empty","title":"Status"},{"location":"Functions/Response/Status/#status","text":"","title":"Status"},{"location":"Functions/Response/Status/#description","text":"The status function allows you to specify a specific status code, and optional a status description.","title":"Description"},{"location":"Functions/Response/Status/#examples","text":"","title":"Examples"},{"location":"Functions/Response/Status/#example-1","text":"The following example sets the status code of the response to be 404: Server { listen * : 8080 http route get '/missing' { status 404 } }","title":"Example 1"},{"location":"Functions/Response/Status/#example-2","text":"The following example sets the status code and description of the response to be 500: Server { listen * : 8080 http route get '/error' { status 500 'Oh no! Something went wrong!' } }","title":"Example 2"},{"location":"Functions/Response/Status/#parameters","text":"Name Type Required Description Default Code int true The status code to set on the web response 0 Description string false The status description to set on the response empty","title":"Parameters"},{"location":"Functions/Response/View/","text":"View Description The view function allows you to render any of the view files that you place within the /views directory. When you call view , Pode will automatically look within this directory. Pode uses a View Engine to either render HTML, Pode, or other types. Default is HTML, and you can change it to Pode by using the engine function. Examples Example 1 The following example will render the index.html view when you navigate to http://localhost:8080 : Server { listen * : 8080 http route get '/' { view 'index' } } Example 2 The following example will render the index.pode view when you navigate to http://localhost:8080 : Server { listen * : 8080 http engine pode route get '/' { view 'index' } } Example 3 The following example will render the index.pode view when you navigate to http://localhost:8080 , it will also supply dynamic data - in this case, the current date: The dynamic data can be used in your pode view via $($data.date) Server { listen * : 8080 http engine pode route get '/' { view 'index' -d @{ 'date' = [DateTime] :: Now } } } Parameters Name Type Required Description Default Path string true The path to the view to render, relative to your /views directory null data hashtable false A hashtable of dynamic data that will be supplied to .pode , and other third-party template engine, view files @{}","title":"View"},{"location":"Functions/Response/View/#view","text":"","title":"View"},{"location":"Functions/Response/View/#description","text":"The view function allows you to render any of the view files that you place within the /views directory. When you call view , Pode will automatically look within this directory. Pode uses a View Engine to either render HTML, Pode, or other types. Default is HTML, and you can change it to Pode by using the engine function.","title":"Description"},{"location":"Functions/Response/View/#examples","text":"","title":"Examples"},{"location":"Functions/Response/View/#example-1","text":"The following example will render the index.html view when you navigate to http://localhost:8080 : Server { listen * : 8080 http route get '/' { view 'index' } }","title":"Example 1"},{"location":"Functions/Response/View/#example-2","text":"The following example will render the index.pode view when you navigate to http://localhost:8080 : Server { listen * : 8080 http engine pode route get '/' { view 'index' } }","title":"Example 2"},{"location":"Functions/Response/View/#example-3","text":"The following example will render the index.pode view when you navigate to http://localhost:8080 , it will also supply dynamic data - in this case, the current date: The dynamic data can be used in your pode view via $($data.date) Server { listen * : 8080 http engine pode route get '/' { view 'index' -d @{ 'date' = [DateTime] :: Now } } }","title":"Example 3"},{"location":"Functions/Response/View/#parameters","text":"Name Type Required Description Default Path string true The path to the view to render, relative to your /views directory null data hashtable false A hashtable of dynamic data that will be supplied to .pode , and other third-party template engine, view files @{}","title":"Parameters"},{"location":"Functions/Response/Xml/","text":"Xml Description The xml function converts a hashtable , or reads in a file, and converts it to XML; the XML value is then written to the web response. You can also supply raw XML data as the value to write. Examples Example 1 The following example will convert a hashtable to XML and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { xml @{ 'cpu' = 80 ; 'memory' = 15 ; } } } Example 2 The following example will write raw XML data to a web response within a route : Server { listen * : 8080 http route get '/info' { xml '<root><users><user>Rick</user><user>Morty</user></users></root>' } } Example 3 The following example will read in a file, and write the contents as XML to a web response within a route : Server { listen * : 8080 http route get '/data' { xml -file './files/data.xml' } } Parameters Name Type Required Description Default Value hashtable/string true The value should either be a hashtable or string - the string can be either a path or raw XML. It will be converted to XML, if not raw, and attached to the web response null File switch false If passed, the above value should be a string that's a path to an XML file false","title":"Xml"},{"location":"Functions/Response/Xml/#xml","text":"","title":"Xml"},{"location":"Functions/Response/Xml/#description","text":"The xml function converts a hashtable , or reads in a file, and converts it to XML; the XML value is then written to the web response. You can also supply raw XML data as the value to write.","title":"Description"},{"location":"Functions/Response/Xml/#examples","text":"","title":"Examples"},{"location":"Functions/Response/Xml/#example-1","text":"The following example will convert a hashtable to XML and write it to a web response within a route : Server { listen * : 8080 http route get '/info' { xml @{ 'cpu' = 80 ; 'memory' = 15 ; } } }","title":"Example 1"},{"location":"Functions/Response/Xml/#example-2","text":"The following example will write raw XML data to a web response within a route : Server { listen * : 8080 http route get '/info' { xml '<root><users><user>Rick</user><user>Morty</user></users></root>' } }","title":"Example 2"},{"location":"Functions/Response/Xml/#example-3","text":"The following example will read in a file, and write the contents as XML to a web response within a route : Server { listen * : 8080 http route get '/data' { xml -file './files/data.xml' } }","title":"Example 3"},{"location":"Functions/Response/Xml/#parameters","text":"Name Type Required Description Default Value hashtable/string true The value should either be a hashtable or string - the string can be either a path or raw XML. It will be converted to XML, if not raw, and attached to the web response null File switch false If passed, the above value should be a string that's a path to an XML file false","title":"Parameters"},{"location":"Functions/Utility/Dispose/","text":"Dispose Description The dispose function takes a disposable object and will optionally close the object, and then dispose of the object. Examples Example 1 The following example takes a StreamReader , and then closes and disposes of the object: Server { $reader = [System.IO.StreamReader] :: new ( $stream ) # logic that uses the reader dispose $reader -close } Parameters Name Type Required Description Default InputObject IDisposable true A disposable object that will be optionally closed, and then disposed null Close switch false If passed, the object will first be closed before being disposed false CheckNetwork switch false If passed, any exceptions thrown will be checked; if they are one of the validated network errors the exception will be ignored false Info The network errors ignored by the -CheckNetwork flag are: network name is no longer available nonexistent network connection broken pipe","title":"Dispose"},{"location":"Functions/Utility/Dispose/#dispose","text":"","title":"Dispose"},{"location":"Functions/Utility/Dispose/#description","text":"The dispose function takes a disposable object and will optionally close the object, and then dispose of the object.","title":"Description"},{"location":"Functions/Utility/Dispose/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/Dispose/#example-1","text":"The following example takes a StreamReader , and then closes and disposes of the object: Server { $reader = [System.IO.StreamReader] :: new ( $stream ) # logic that uses the reader dispose $reader -close }","title":"Example 1"},{"location":"Functions/Utility/Dispose/#parameters","text":"Name Type Required Description Default InputObject IDisposable true A disposable object that will be optionally closed, and then disposed null Close switch false If passed, the object will first be closed before being disposed false CheckNetwork switch false If passed, any exceptions thrown will be checked; if they are one of the validated network errors the exception will be ignored false Info The network errors ignored by the -CheckNetwork flag are: network name is no longer available nonexistent network connection broken pipe","title":"Parameters"},{"location":"Functions/Utility/Include/","text":"Include Description The include function can only be used within a .pode view file; it allows you to include other views (html/pode/other) into a main view. This way you can have shared partial views (like headers, footers or navigation), and include them into your main views. Examples Example 1 The following example will include a header partial view file into below example index.pode file: <!-- /views/index.pode --> < html > $(include shared/head) < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > <!-- /views/shared/head.pode --> < head > < title > Include Example </ title > </ head > Example 2 The following example will include the header partial view file, but this time will supply some dynamic data: <!-- /views/index.pode --> < html > $(include shared/head -d @{ 'PageName' = 'Index' }) < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > <!-- /views/shared/head.pode --> < head > < title > Page: $($data.PageName) </ title > </ head > Parameters Name Type Required Description Default Path string true The path to the view that should be included, relative to the /views directory empty Data hashtable false A hashtable of dynamic data that will be supplied to .pode , and other third-party template engine, view files @{}","title":"Include"},{"location":"Functions/Utility/Include/#include","text":"","title":"Include"},{"location":"Functions/Utility/Include/#description","text":"The include function can only be used within a .pode view file; it allows you to include other views (html/pode/other) into a main view. This way you can have shared partial views (like headers, footers or navigation), and include them into your main views.","title":"Description"},{"location":"Functions/Utility/Include/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/Include/#example-1","text":"The following example will include a header partial view file into below example index.pode file: <!-- /views/index.pode --> < html > $(include shared/head) < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > <!-- /views/shared/head.pode --> < head > < title > Include Example </ title > </ head >","title":"Example 1"},{"location":"Functions/Utility/Include/#example-2","text":"The following example will include the header partial view file, but this time will supply some dynamic data: <!-- /views/index.pode --> < html > $(include shared/head -d @{ 'PageName' = 'Index' }) < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > <!-- /views/shared/head.pode --> < head > < title > Page: $($data.PageName) </ title > </ head >","title":"Example 2"},{"location":"Functions/Utility/Include/#parameters","text":"Name Type Required Description Default Path string true The path to the view that should be included, relative to the /views directory empty Data hashtable false A hashtable of dynamic data that will be supplied to .pode , and other third-party template engine, view files @{}","title":"Parameters"},{"location":"Functions/Utility/Lock/","text":"Lock Description The lock function takes an object that will be locked so that it is threadsafe. The supplied ScriptBlock will be invoked within the scope of the locked object. Tip The session object supplied to a route , timer , schedule and logger each contain a .Lockable resource that can be supplied to the lock function. Examples Example 1 The following example will lock an object, and increment a counter on the session and write it to the response in a threadsafe scope: Server { listen * : 8080 http route get '/count' { param ( $s ) lock $s . Lockable { $s . Session . Data . Views ++ json @{ 'Views' = $s . Session . Data . Views } } } } Parameters Name Type Required Description Default InputObject object true The object to lock, so that it is threadsafe within the supplied ScriptBlock null ScriptBlock scriptblock true The logic that will utilise the locked object null","title":"Lock"},{"location":"Functions/Utility/Lock/#lock","text":"","title":"Lock"},{"location":"Functions/Utility/Lock/#description","text":"The lock function takes an object that will be locked so that it is threadsafe. The supplied ScriptBlock will be invoked within the scope of the locked object. Tip The session object supplied to a route , timer , schedule and logger each contain a .Lockable resource that can be supplied to the lock function.","title":"Description"},{"location":"Functions/Utility/Lock/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/Lock/#example-1","text":"The following example will lock an object, and increment a counter on the session and write it to the response in a threadsafe scope: Server { listen * : 8080 http route get '/count' { param ( $s ) lock $s . Lockable { $s . Session . Data . Views ++ json @{ 'Views' = $s . Session . Data . Views } } } }","title":"Example 1"},{"location":"Functions/Utility/Lock/#parameters","text":"Name Type Required Description Default InputObject object true The object to lock, so that it is threadsafe within the supplied ScriptBlock null ScriptBlock scriptblock true The logic that will utilise the locked object null","title":"Parameters"},{"location":"Functions/Utility/State/","text":"State Description The state function allows you to set/get objects on a shared state that exists across all runspaces; this is because functions like route and timer all run within separate runspaces - meaning normally you can't create a variable in a timer and then access that variable in a route . The state function overcomes this by letting you create a variable in a timer and set it against the shared state, then you can retrieve that variable from the state in a route . Tip It's wise to use the state function in conjunction with the lock function, so as to ensure thread safety between runspaces. The session object supplied to a route , timer , schedule and logger each contain a .Lockable resource that can be supplied to the lock function. Warning If you omit the use of lock , you will run into errors due to multi-threading. Only omit if you are absolutely confident you do not need locking. (ie: you set in state once and then only ever retrieve, never updating the variable). Examples Example 1 The following example is uses a timer to create and update a hashtable , and then retrieve that variable in a route : Server { listen * : 8080 http timer 'forever' 2 { param ( $session ) $hash = $null # create a lock on a pode lockable resource for safety lock $session . Lockable { # first, attempt to get the hashtable from the state $hash = ( state get 'hash' ) # if it doesn't exist yet, set it against the state if ( $hash -eq $null ) { $hash = ( state set 'hash' @{}) $hash [ 'values' ] = @() } # add a random number to the hash, that will be reflected in the state $hash [ 'values' ] += ( Get-Random -Minimum 0 -Maximum 10 ) } } route get '/state' { param ( $session ) # create another lock on the same lockable resource lock $session . Lockable { # get the hashtable defined in the timer above, and return it as json $hash = ( state get 'hash' ) json $hash } } } Parameters Name Type Required Description Default Action string true The action to perform on the shared state for the variable (Values: Get, Set, Remove) empty Name string true The name of the variable within the shared state empty Object object false Should only be supplied for an action of set . This is the value for the variable in the shared state null","title":"State"},{"location":"Functions/Utility/State/#state","text":"","title":"State"},{"location":"Functions/Utility/State/#description","text":"The state function allows you to set/get objects on a shared state that exists across all runspaces; this is because functions like route and timer all run within separate runspaces - meaning normally you can't create a variable in a timer and then access that variable in a route . The state function overcomes this by letting you create a variable in a timer and set it against the shared state, then you can retrieve that variable from the state in a route . Tip It's wise to use the state function in conjunction with the lock function, so as to ensure thread safety between runspaces. The session object supplied to a route , timer , schedule and logger each contain a .Lockable resource that can be supplied to the lock function. Warning If you omit the use of lock , you will run into errors due to multi-threading. Only omit if you are absolutely confident you do not need locking. (ie: you set in state once and then only ever retrieve, never updating the variable).","title":"Description"},{"location":"Functions/Utility/State/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/State/#example-1","text":"The following example is uses a timer to create and update a hashtable , and then retrieve that variable in a route : Server { listen * : 8080 http timer 'forever' 2 { param ( $session ) $hash = $null # create a lock on a pode lockable resource for safety lock $session . Lockable { # first, attempt to get the hashtable from the state $hash = ( state get 'hash' ) # if it doesn't exist yet, set it against the state if ( $hash -eq $null ) { $hash = ( state set 'hash' @{}) $hash [ 'values' ] = @() } # add a random number to the hash, that will be reflected in the state $hash [ 'values' ] += ( Get-Random -Minimum 0 -Maximum 10 ) } } route get '/state' { param ( $session ) # create another lock on the same lockable resource lock $session . Lockable { # get the hashtable defined in the timer above, and return it as json $hash = ( state get 'hash' ) json $hash } } }","title":"Example 1"},{"location":"Functions/Utility/State/#parameters","text":"Name Type Required Description Default Action string true The action to perform on the shared state for the variable (Values: Get, Set, Remove) empty Name string true The name of the variable within the shared state empty Object object false Should only be supplied for an action of set . This is the value for the variable in the shared state null","title":"Parameters"},{"location":"Functions/Utility/Stopwatch/","text":"Stopwatch Description The stopwatch function lets you wrap logic in a scriptblock, and have the amount of time the logic took to execute outputted to the CLI. Examples Example 1 The following example will wrap a stopwatch around reading in files and converting them to JSON: Server { stopwatch 'files' { Get-ChildItem 'c:/temp/*.json' | Foreach -Object { $content = Get-Content -Raw $_ $json = $content | ConvertFrom-Json } } } The above will run, and output something similar to the below, on the CLI: [Stopwatch]: 00:00:08.136788 [files] Parameters Name Type Required Description Default Name string true The name of the logic the stopwatch is wrapped around empty ScriptBlock scriptblock true The logic the stopwatch should time null","title":"Stopwatch"},{"location":"Functions/Utility/Stopwatch/#stopwatch","text":"","title":"Stopwatch"},{"location":"Functions/Utility/Stopwatch/#description","text":"The stopwatch function lets you wrap logic in a scriptblock, and have the amount of time the logic took to execute outputted to the CLI.","title":"Description"},{"location":"Functions/Utility/Stopwatch/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/Stopwatch/#example-1","text":"The following example will wrap a stopwatch around reading in files and converting them to JSON: Server { stopwatch 'files' { Get-ChildItem 'c:/temp/*.json' | Foreach -Object { $content = Get-Content -Raw $_ $json = $content | ConvertFrom-Json } } } The above will run, and output something similar to the below, on the CLI: [Stopwatch]: 00:00:08.136788 [files]","title":"Example 1"},{"location":"Functions/Utility/Stopwatch/#parameters","text":"Name Type Required Description Default Name string true The name of the logic the stopwatch is wrapped around empty ScriptBlock scriptblock true The logic the stopwatch should time null","title":"Parameters"},{"location":"Functions/Utility/Stream/","text":"Stream Description The stream function allows you to use streams, utilise them, and then automatically dispose of the stream object for you. Examples Example 1 The following example opens a StreamReader , reads in the content of the stream, and then automatically disposes of the stream for you. The content is then placed into the $data variable: Server { $data = stream ( [System.IO.StreamReader] :: new ( $stream )) { return $args [ 0 ]. ReadToEnd () } } Parameters Name Type Required Description Default InputObject IDisposable true A disposable object that will be used, and then disposed. This works much the same as using in C# .NET null ScriptBlock scriptblock true The logic that will utilise the disposable stream object, of which the stream itself is passed as an argument to the scriptblock null","title":"Stream"},{"location":"Functions/Utility/Stream/#stream","text":"","title":"Stream"},{"location":"Functions/Utility/Stream/#description","text":"The stream function allows you to use streams, utilise them, and then automatically dispose of the stream object for you.","title":"Description"},{"location":"Functions/Utility/Stream/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/Stream/#example-1","text":"The following example opens a StreamReader , reads in the content of the stream, and then automatically disposes of the stream for you. The content is then placed into the $data variable: Server { $data = stream ( [System.IO.StreamReader] :: new ( $stream )) { return $args [ 0 ]. ReadToEnd () } }","title":"Example 1"},{"location":"Functions/Utility/Stream/#parameters","text":"Name Type Required Description Default InputObject IDisposable true A disposable object that will be used, and then disposed. This works much the same as using in C# .NET null ScriptBlock scriptblock true The logic that will utilise the disposable stream object, of which the stream itself is passed as an argument to the scriptblock null","title":"Parameters"},{"location":"Functions/Utility/Tcp/","text":"Tcp Description The tcp function allows you to read/write messages to/from a TCP stream. By default Pode's TCP server stream is used, but you can specify a custom TCP stream to read/write. Examples Example 1 The following example will write a message onto the TCP stream: Server { listen * : 30 tcp handler tcp { tcp write 'Hello, world!' } } Example 2 The following example will read a message from the TCP stream: Server { listen * : 30 tcp handler tcp { $msg = ( tcp read ) } } Parameters Name Type Required Description Default Action string true The action to perform on the TCP stream (Values: Write, Read) empty Message string false A message to write on the TCP stream empty Client object false A custom other TCP stream, otherwise the global stream will be used global stream","title":"Tcp"},{"location":"Functions/Utility/Tcp/#tcp","text":"","title":"Tcp"},{"location":"Functions/Utility/Tcp/#description","text":"The tcp function allows you to read/write messages to/from a TCP stream. By default Pode's TCP server stream is used, but you can specify a custom TCP stream to read/write.","title":"Description"},{"location":"Functions/Utility/Tcp/#examples","text":"","title":"Examples"},{"location":"Functions/Utility/Tcp/#example-1","text":"The following example will write a message onto the TCP stream: Server { listen * : 30 tcp handler tcp { tcp write 'Hello, world!' } }","title":"Example 1"},{"location":"Functions/Utility/Tcp/#example-2","text":"The following example will read a message from the TCP stream: Server { listen * : 30 tcp handler tcp { $msg = ( tcp read ) } }","title":"Example 2"},{"location":"Functions/Utility/Tcp/#parameters","text":"Name Type Required Description Default Action string true The action to perform on the TCP stream (Values: Write, Read) empty Message string false A message to write on the TCP stream empty Client object false A custom other TCP stream, otherwise the global stream will be used global stream","title":"Parameters"},{"location":"Getting-Started/CLI/","text":"CLI Pode has some commands that you can utilise from the CLI - when your in a PowerShell terminal, or pwsh session. These commands help you to initialise, start, test, build, or install any packages for your repo/server. All of these commands are centered around the package.json format - similar to that of Node.js and Yarn. Info At the moment, Pode only uses the start , test , build and install properties of the scripts section in your package.json . You can still have others, like dependencies for Yarn Commands Build The build command will run the script found in the package.json file, at the scripts/build value: pode builid Init The init command will help you create a new package.json file from scratch. It will ask a few questions, such as author/name/etc, and then create the file for you: pode init Tip By default, Pode will pre-populate the test , build and install values using yarn , psake and pester respectively Install The install command will run the script found in the package.json file, at the scripts/install value: pode install Start The start command will run the script found in the package.json file, at the scripts/start value. If this value is not set, then this command will instead run the value under main : pode start Test The test command will run the script found in the package.json file, at the scripts/test value: pode test Package File The following is an example of a package.json file: { \"name\" : \"example\" , \"description\" : \"\" , \"version\" : \"1.0.0\" , \"main\" : \"./server.ps1\" , \"scripts\" : { \"start\" : \"./server.ps1\" , \"test\" : \"invoke-pester ./tests/*.ps1\" , \"install\" : \"yarn install --force --ignore-scripts --modules-folder pode_modules\" , \"build\" : \"psake\" }, \"author\" : \"Rick Sanchez\" , \"license\" : \"MIT\" }","title":"CLI"},{"location":"Getting-Started/CLI/#cli","text":"Pode has some commands that you can utilise from the CLI - when your in a PowerShell terminal, or pwsh session. These commands help you to initialise, start, test, build, or install any packages for your repo/server. All of these commands are centered around the package.json format - similar to that of Node.js and Yarn. Info At the moment, Pode only uses the start , test , build and install properties of the scripts section in your package.json . You can still have others, like dependencies for Yarn","title":"CLI"},{"location":"Getting-Started/CLI/#commands","text":"","title":"Commands"},{"location":"Getting-Started/CLI/#build","text":"The build command will run the script found in the package.json file, at the scripts/build value: pode builid","title":"Build"},{"location":"Getting-Started/CLI/#init","text":"The init command will help you create a new package.json file from scratch. It will ask a few questions, such as author/name/etc, and then create the file for you: pode init Tip By default, Pode will pre-populate the test , build and install values using yarn , psake and pester respectively","title":"Init"},{"location":"Getting-Started/CLI/#install","text":"The install command will run the script found in the package.json file, at the scripts/install value: pode install","title":"Install"},{"location":"Getting-Started/CLI/#start","text":"The start command will run the script found in the package.json file, at the scripts/start value. If this value is not set, then this command will instead run the value under main : pode start","title":"Start"},{"location":"Getting-Started/CLI/#test","text":"The test command will run the script found in the package.json file, at the scripts/test value: pode test","title":"Test"},{"location":"Getting-Started/CLI/#package-file","text":"The following is an example of a package.json file: { \"name\" : \"example\" , \"description\" : \"\" , \"version\" : \"1.0.0\" , \"main\" : \"./server.ps1\" , \"scripts\" : { \"start\" : \"./server.ps1\" , \"test\" : \"invoke-pester ./tests/*.ps1\" , \"install\" : \"yarn install --force --ignore-scripts --modules-folder pode_modules\" , \"build\" : \"psake\" }, \"author\" : \"Rick Sanchez\" , \"license\" : \"MIT\" }","title":"Package File"},{"location":"Getting-Started/Docker/","text":"Docker Pode has a Docker container that you can use, by calling docker pull badgerati/pode you can pull down the latest image. The image itself uses PowerShell Core on the Ubuntu Xenial OS. Dockerfile An example of using the Pode container in your Dockerfile could be as follows: Info The server script used below can be found in the examples/web-pages-docker.ps1 # pull down the pode image FROM badgerati/pode # copy over the local files to the container COPY . /usr/src/app/ # expose the port EXPOSE 8085 # run the server CMD [ \"pwsh\", \"-c\", \"cd /usr/src/app; ./web-pages-docker.ps1\" ] Build and Run To build and run the above Dockerfile, you can use the following commands: docker build -t pode/example docker run -p 8085 :8085 -d pode/example Info The Dockerfile above is the same Dockerfile in the examples/ directory Now try navigating to localhost:8085 (or calling curl localhost:8085 ) and you should be greeted with a \"Hello, world!\" page.","title":"Docker"},{"location":"Getting-Started/Docker/#docker","text":"Pode has a Docker container that you can use, by calling docker pull badgerati/pode you can pull down the latest image. The image itself uses PowerShell Core on the Ubuntu Xenial OS.","title":"Docker"},{"location":"Getting-Started/Docker/#dockerfile","text":"An example of using the Pode container in your Dockerfile could be as follows: Info The server script used below can be found in the examples/web-pages-docker.ps1 # pull down the pode image FROM badgerati/pode # copy over the local files to the container COPY . /usr/src/app/ # expose the port EXPOSE 8085 # run the server CMD [ \"pwsh\", \"-c\", \"cd /usr/src/app; ./web-pages-docker.ps1\" ]","title":"Dockerfile"},{"location":"Getting-Started/Docker/#build-and-run","text":"To build and run the above Dockerfile, you can use the following commands: docker build -t pode/example docker run -p 8085 :8085 -d pode/example Info The Dockerfile above is the same Dockerfile in the examples/ directory Now try navigating to localhost:8085 (or calling curl localhost:8085 ) and you should be greeted with a \"Hello, world!\" page.","title":"Build and Run"},{"location":"Getting-Started/Frontend/","text":"Frontend You can host web-pages using Pode, and to help you can also use package managers like yarn to install frontend libraries - like bootstrap. Using Yarn The following will install Yarn onto your machine: choco install yarn -y yarn init Once installed, you can use Yarn to download frontend libraries. The libraries will be added to a package.json file - which if you're using the Pode CLI, you'll already have in place. To install frontend libraries, you could use the following: yarn add bootstrap yarn add lodash Build via Pode Once you've added some libraries you can use pode install to trigger yarn . This will tell yarn to install the packages to a pode_modules directory. Info Other useful packages could include gulp , jquery , moment , etc.","title":"Frontend"},{"location":"Getting-Started/Frontend/#frontend","text":"You can host web-pages using Pode, and to help you can also use package managers like yarn to install frontend libraries - like bootstrap.","title":"Frontend"},{"location":"Getting-Started/Frontend/#using-yarn","text":"The following will install Yarn onto your machine: choco install yarn -y yarn init Once installed, you can use Yarn to download frontend libraries. The libraries will be added to a package.json file - which if you're using the Pode CLI, you'll already have in place. To install frontend libraries, you could use the following: yarn add bootstrap yarn add lodash","title":"Using Yarn"},{"location":"Getting-Started/Frontend/#build-via-pode","text":"Once you've added some libraries you can use pode install to trigger yarn . This will tell yarn to install the packages to a pode_modules directory. Info Other useful packages could include gulp , jquery , moment , etc.","title":"Build via Pode"},{"location":"Getting-Started/Installation/","text":"Installation Pode is a PowerShell module that can be installed from either Chocolatey, PowerShell Gallery, or Docker. Once installed, you can import the module into your PowerShell scripts. Chocolatey To install Pode via Chocolatey, the following command can be used: choco install pode PowerShell Gallery To install Pode from the PowerShell Gallery, you can use the following: Install-Module -Name Pode Docker Pode can run on *nix environments, therefore it only makes sense for there to be a Docker container for you to use! The container uses PowerShell Core on an Ubuntu Xenial container. To pull down the Pode container you can do: docker pull badgerati / pode Using the Module After you have installed the module, you can then import it into your server scripts: Import-Module Pode","title":"Installation"},{"location":"Getting-Started/Installation/#installation","text":"Pode is a PowerShell module that can be installed from either Chocolatey, PowerShell Gallery, or Docker. Once installed, you can import the module into your PowerShell scripts.","title":"Installation"},{"location":"Getting-Started/Installation/#chocolatey","text":"To install Pode via Chocolatey, the following command can be used: choco install pode","title":"Chocolatey"},{"location":"Getting-Started/Installation/#powershell-gallery","text":"To install Pode from the PowerShell Gallery, you can use the following: Install-Module -Name Pode","title":"PowerShell Gallery"},{"location":"Getting-Started/Installation/#docker","text":"Pode can run on *nix environments, therefore it only makes sense for there to be a Docker container for you to use! The container uses PowerShell Core on an Ubuntu Xenial container. To pull down the Pode container you can do: docker pull badgerati / pode","title":"Docker"},{"location":"Getting-Started/Installation/#using-the-module","text":"After you have installed the module, you can then import it into your server scripts: Import-Module Pode","title":"Using the Module"},{"location":"Tutorials/Basics/","text":"Basics Pode at its heart is a PowerShell module, in order to use Pode you'll need to start off by importing it into your scripts: Import-Module Pode After that, all of your main server logic must be wrapped in a Server block: Import-Module Pode Server { # attach to port 8080 listen * : 8080 http # logic for routes, timers, schedules, etc } Warning You can only have one Server declared in your script The above Server will start a basic HTTP listener on port 8080. To start the server you can either: Directly run the ./server.ps1 script, or If you've created a package.json file, ensure the ./server.ps1 script is set as your main or scripts/start , then just run pode start (more here ) Tip Once Pode has started, you can exit out at any time using Ctrl+C . You can also restart the server by using Ctrl+R .","title":"Basics"},{"location":"Tutorials/Basics/#basics","text":"Pode at its heart is a PowerShell module, in order to use Pode you'll need to start off by importing it into your scripts: Import-Module Pode After that, all of your main server logic must be wrapped in a Server block: Import-Module Pode Server { # attach to port 8080 listen * : 8080 http # logic for routes, timers, schedules, etc } Warning You can only have one Server declared in your script The above Server will start a basic HTTP listener on port 8080. To start the server you can either: Directly run the ./server.ps1 script, or If you've created a package.json file, ensure the ./server.ps1 script is set as your main or scripts/start , then just run pode start (more here ) Tip Once Pode has started, you can exit out at any time using Ctrl+C . You can also restart the server by using Ctrl+R .","title":"Basics"},{"location":"Tutorials/CronExpressions/","text":"Cron Expressions Schedules in Pode use cron expressions to define when they trigger. This page is a brief overview of the expressions supported by Pode. Basic Pode supports all basic features of cron expressions in the following format: <min> <hour> <day-of-month> <month> <day-of-week> For example, if you wanted to run a schedule that triggers every midnight on a Tuesday, the following would work: 0 0 * * TUE Whereas if you wanted a schedule to trigger on the 15th of each month, at 1am: 0 1 15 * * * Predefined The following table outlines some of the predefined cron expressions supported by Pode; you can use these in place of normal cron expressions: Predefined Expression @minutely * * * * * @hourly 0 * * * * @daily 0 0 * * * @weekly 0 0 * * 0 @monthly 0 0 1 * * @quaterly 0 0 1 1,4,8,7,10 @yearly 0 0 1 1 * @annually 0 0 1 1 * @twice-hourly 0,30 * * * * @twice-daily 0,12 0 * * * @twice-weekly 0 0 * * 0,4 @twice-monthly 0 0 1,15 * * @twice-yearly 0 0 1 1,6 * @twice-annually 0 0 1 1,6 * Advanced Pode does have some support for advanced cron features, including its own placeholder: R . R : using this on an atom will use a random value between that atom's constraints, and when the expression is triggered the atom is re-randomised - you can force an initial trigger value using /R . For example: 30/R * * * * will trigger on 30mins, then a random minute afterwards; whereas using R * * * * will always trigger on a random minute between 0-59.","title":"Cron Expressions"},{"location":"Tutorials/CronExpressions/#cron-expressions","text":"Schedules in Pode use cron expressions to define when they trigger. This page is a brief overview of the expressions supported by Pode.","title":"Cron Expressions"},{"location":"Tutorials/CronExpressions/#basic","text":"Pode supports all basic features of cron expressions in the following format: <min> <hour> <day-of-month> <month> <day-of-week> For example, if you wanted to run a schedule that triggers every midnight on a Tuesday, the following would work: 0 0 * * TUE Whereas if you wanted a schedule to trigger on the 15th of each month, at 1am: 0 1 15 * * *","title":"Basic"},{"location":"Tutorials/CronExpressions/#predefined","text":"The following table outlines some of the predefined cron expressions supported by Pode; you can use these in place of normal cron expressions: Predefined Expression @minutely * * * * * @hourly 0 * * * * @daily 0 0 * * * @weekly 0 0 * * 0 @monthly 0 0 1 * * @quaterly 0 0 1 1,4,8,7,10 @yearly 0 0 1 1 * @annually 0 0 1 1 * @twice-hourly 0,30 * * * * @twice-daily 0,12 0 * * * @twice-weekly 0 0 * * 0,4 @twice-monthly 0 0 1,15 * * @twice-yearly 0 0 1 1,6 * @twice-annually 0 0 1 1,6 *","title":"Predefined"},{"location":"Tutorials/CronExpressions/#advanced","text":"Pode does have some support for advanced cron features, including its own placeholder: R . R : using this on an atom will use a random value between that atom's constraints, and when the expression is triggered the atom is re-randomised - you can force an initial trigger value using /R . For example: 30/R * * * * will trigger on 30mins, then a random minute afterwards; whereas using R * * * * will always trigger on a random minute between 0-59.","title":"Advanced"},{"location":"Tutorials/FileMonitor/","text":"File Monitor Note For docker you'll need to use any of the Pode tags labeled \"-ps.6.1.0-preview\". Pode has inbuilt file monitoring which can trigger an internal server restart if it detects file changes within the same directory as your Pode script. To enable the monitoring supply the -FileMonitor switch to your Server : Server { # logic } -FileMonitor Once enabled, Pode will actively monitor all file changes within the directory of your script. Ie, if your script was at C:/Apps/Pode/server.ps1 , then Pode will monitor the C:/Apps/Pode directory and sub-directories for changes. When a change is detected, Pode will wait a couple of seconds before triggering the restart; this is so multiple rapid changes don't trigger multiple restarts. The changes that are being monitored by Pode are: Updates Creation Deletion Info If you change the main server script itself, those changes will not be picked up. It's best to import/dot-source other modules/scripts into your Server scriptblock, as the internal restart re-executes this scriptblock. If you do make changes to the main server script, you'll need to terminate and restart the server.","title":"File Monitor"},{"location":"Tutorials/FileMonitor/#file-monitor","text":"Note For docker you'll need to use any of the Pode tags labeled \"-ps.6.1.0-preview\". Pode has inbuilt file monitoring which can trigger an internal server restart if it detects file changes within the same directory as your Pode script. To enable the monitoring supply the -FileMonitor switch to your Server : Server { # logic } -FileMonitor Once enabled, Pode will actively monitor all file changes within the directory of your script. Ie, if your script was at C:/Apps/Pode/server.ps1 , then Pode will monitor the C:/Apps/Pode directory and sub-directories for changes. When a change is detected, Pode will wait a couple of seconds before triggering the restart; this is so multiple rapid changes don't trigger multiple restarts. The changes that are being monitored by Pode are: Updates Creation Deletion Info If you change the main server script itself, those changes will not be picked up. It's best to import/dot-source other modules/scripts into your Server scriptblock, as the internal restart re-executes this scriptblock. If you do make changes to the main server script, you'll need to terminate and restart the server.","title":"File Monitor"},{"location":"Tutorials/Threading/","text":"Threading By default Pode deals with incoming request synchronously in a single thread. You can increase the number of threads/runspaces that Pode uses to handle requests by using the -Threads parameter on your Server : Server -Threads 2 { # logic } The number of threads supplied only applies to Web, SMTP, and TCP servers. If -Threads is not supplied, or is <=0 then the number of threads is forced to the default of 1.","title":"Threading"},{"location":"Tutorials/Threading/#threading","text":"By default Pode deals with incoming request synchronously in a single thread. You can increase the number of threads/runspaces that Pode uses to handle requests by using the -Threads parameter on your Server : Server -Threads 2 { # logic } The number of threads supplied only applies to Web, SMTP, and TCP servers. If -Threads is not supplied, or is <=0 then the number of threads is forced to the default of 1.","title":"Threading"},{"location":"Tutorials/Authentication/Basic/","text":"Basic Authentication Basic authentication is when you pass an encoded username:password value on the header of your requests: @{ 'Authorization' = 'Basic <base64 encoded username:password>' } . Setup To setup and start using Basic authentication in Pode you can set auth use basic in your server script, the validator script you need to supply will have the username/password passed as arguments to the scriptblock: Server { auth use basic -v { param ( $username , $password ) # check if the user is valid return @{ 'user' = $user } } } By default, Pode will check if the request's header contains an Authorization key, and whether the value of that key starts with Basic . The auth use action can be supplied options via -o to override the start name of the value, as well as the encoding that Pode uses. For example, to use ASCII encoding rather than the default ISO-8859-1 you could do: Server { auth use basic -v { # check } -o @{ 'Encoding' = 'ASCII' } } More options can be seen further below. Validating Once configured you can start using Basic authentication to validate incoming requests. You can either configure the validation to happen on every route as global middleware , or as custom route middleware. The following will use Basic authentication to validate every request on every route : Server { middleware ( auth check basic ) } Whereas the following example will use Basic authentication to only validate requests on specific a route : Server { route get '/info' ( auth check basic ) { # logic } } Full Example The following full example of Basic authentication will setup and configure authentication, validate that a users username/password is valid, and then validate on a specific route : Server { listen * : 8080 http # setup basic authentication to validate a user auth use basic -v { param ( $username , $password ) # here you'd check a real user storage, this is just for example if ( $username -eq 'morty' -and $password -eq 'pickle' ) { return @{ 'user' = @{ 'ID' = 'M0R7Y302' 'Name' = 'Morty' ; 'Type' = 'Human' ; } } } return $null } # check the request on this route against the authentication route get '/cpu' ( auth check basic ) { json @{ 'cpu' = 82 } } # this route will not be validated against the authentication route get '/memory' { json @{ 'memory' = 14 } } } Use Options Name Description Default Encoding Defines which encoding to use when decoding the Authorization header ISO-8859-1 Name Defines the name part of the header, in front of the encoded sting, such as the Basic part of Basic <username:password> Basic","title":"Basic"},{"location":"Tutorials/Authentication/Basic/#basic-authentication","text":"Basic authentication is when you pass an encoded username:password value on the header of your requests: @{ 'Authorization' = 'Basic <base64 encoded username:password>' } .","title":"Basic Authentication"},{"location":"Tutorials/Authentication/Basic/#setup","text":"To setup and start using Basic authentication in Pode you can set auth use basic in your server script, the validator script you need to supply will have the username/password passed as arguments to the scriptblock: Server { auth use basic -v { param ( $username , $password ) # check if the user is valid return @{ 'user' = $user } } } By default, Pode will check if the request's header contains an Authorization key, and whether the value of that key starts with Basic . The auth use action can be supplied options via -o to override the start name of the value, as well as the encoding that Pode uses. For example, to use ASCII encoding rather than the default ISO-8859-1 you could do: Server { auth use basic -v { # check } -o @{ 'Encoding' = 'ASCII' } } More options can be seen further below.","title":"Setup"},{"location":"Tutorials/Authentication/Basic/#validating","text":"Once configured you can start using Basic authentication to validate incoming requests. You can either configure the validation to happen on every route as global middleware , or as custom route middleware. The following will use Basic authentication to validate every request on every route : Server { middleware ( auth check basic ) } Whereas the following example will use Basic authentication to only validate requests on specific a route : Server { route get '/info' ( auth check basic ) { # logic } }","title":"Validating"},{"location":"Tutorials/Authentication/Basic/#full-example","text":"The following full example of Basic authentication will setup and configure authentication, validate that a users username/password is valid, and then validate on a specific route : Server { listen * : 8080 http # setup basic authentication to validate a user auth use basic -v { param ( $username , $password ) # here you'd check a real user storage, this is just for example if ( $username -eq 'morty' -and $password -eq 'pickle' ) { return @{ 'user' = @{ 'ID' = 'M0R7Y302' 'Name' = 'Morty' ; 'Type' = 'Human' ; } } } return $null } # check the request on this route against the authentication route get '/cpu' ( auth check basic ) { json @{ 'cpu' = 82 } } # this route will not be validated against the authentication route get '/memory' { json @{ 'memory' = 14 } } }","title":"Full Example"},{"location":"Tutorials/Authentication/Basic/#use-options","text":"Name Description Default Encoding Defines which encoding to use when decoding the Authorization header ISO-8859-1 Name Defines the name part of the header, in front of the encoded sting, such as the Basic part of Basic <username:password> Basic","title":"Use Options"},{"location":"Tutorials/Authentication/Custom/","text":"Custom Authentication Custom authentication works much like the inbuilt types, but allows you to specify your own parsing logic, as well as any custom options that might be required. Setup and Parsing To setup and start using Custom authentication in Pode you can set auth use -c <name> in you server script. The <name> can be anything you want, even the name of an inbuilt method (it will still use your custom logic!). Let's say we wanted something similar to Form authentication but it requires a third piece of information: ClientName . To setup Custom authentication for this method, you'll need to specify the parsing scriptblock under -p , as well as the validator script too. The parsing script will be passed the current request session (containing the Request/Response objects, much like a route ). In this script you can parse the request payload/headers for any credential information that needs validating. Once sourced, the data returned from the script should be either a hashtable or an array ; this data will then splatted onto the validator scriptblock ( info ): Server { # here we're calling the custom method \"client\" auth use -c client -p { # the current request session, and auth method options supplied param ( $session , $opts ) # get client/user/pass field names to get from payload $clientField = ( coalesce $opts . ClientField 'client' ) $userField = ( coalesce $opts . UsernameField 'username' ) $passField = ( coalesce $opts . PasswordField 'password' ) # get the client/user/pass from the post data $client = $session . Data . $clientField $username = $session . Data . $userField $password = $session . Data . $passField # return the data, to be passed to the validator script return @( $client , $username , $password ) } ` -v { param ( $client , $username , $password ) # check if the client is valid return @{ 'user' = $user } } } Validating Once configured you can start using the Custom authentication to validate incoming requests. You can either configure the validation to happen on every route as global middleware , or as custom route middleware. The following will use Custom authentication to validate every request on every route : Server { middleware ( auth check client ) } Whereas the following example will use Custom authentication to only validate requests on specific a route : Server { route get '/info' ( auth check client ) { # logic } } Full Example The following full example of Custom authentication will setup and configure authentication, validate that a users client/username/password is valid, and then validate on a specific route : Server { listen * : 8080 http # here we're calling the custom method \"client\" auth use -c client -p { # the current request session, and auth method options supplied param ( $session , $opts ) # get client/user/pass field names to get from payload $clientField = ( coalesce $opts . ClientField 'client' ) $userField = ( coalesce $opts . UsernameField 'username' ) $passField = ( coalesce $opts . PasswordField 'password' ) # get the client/user/pass from the post data $client = $session . Data . $clientField $username = $session . Data . $userField $password = $session . Data . $passField # return the data, to be passed to the validator script return @( $client , $username , $password ) } ` -v { param ( $client , $username , $password ) # check if the client is valid return @{ 'user' = $user } } # check the request on this route against the authentication route get '/cpu' ( auth check client ) { json @{ 'cpu' = 82 } } # this route will not be validated against the authentication route get '/memory' { json @{ 'memory' = 14 } } } Below is an example HTML page that would POST the client/username/password to the server above: < form action = \"/login\" method = \"post\" > < div > < label > Client: </ label > < input type = \"text\" name = \"client\" /> </ div > < div > < label > Username: </ label > < input type = \"text\" name = \"username\" /> </ div > < div > < label > Password: </ label > < input type = \"password\" name = \"password\" /> </ div > < div > < input type = \"submit\" value = \"Login\" /> </ div > </ form > Use Options Info There are no use options for custom types, unless you define your own.","title":"Custom"},{"location":"Tutorials/Authentication/Custom/#custom-authentication","text":"Custom authentication works much like the inbuilt types, but allows you to specify your own parsing logic, as well as any custom options that might be required.","title":"Custom Authentication"},{"location":"Tutorials/Authentication/Custom/#setup-and-parsing","text":"To setup and start using Custom authentication in Pode you can set auth use -c <name> in you server script. The <name> can be anything you want, even the name of an inbuilt method (it will still use your custom logic!). Let's say we wanted something similar to Form authentication but it requires a third piece of information: ClientName . To setup Custom authentication for this method, you'll need to specify the parsing scriptblock under -p , as well as the validator script too. The parsing script will be passed the current request session (containing the Request/Response objects, much like a route ). In this script you can parse the request payload/headers for any credential information that needs validating. Once sourced, the data returned from the script should be either a hashtable or an array ; this data will then splatted onto the validator scriptblock ( info ): Server { # here we're calling the custom method \"client\" auth use -c client -p { # the current request session, and auth method options supplied param ( $session , $opts ) # get client/user/pass field names to get from payload $clientField = ( coalesce $opts . ClientField 'client' ) $userField = ( coalesce $opts . UsernameField 'username' ) $passField = ( coalesce $opts . PasswordField 'password' ) # get the client/user/pass from the post data $client = $session . Data . $clientField $username = $session . Data . $userField $password = $session . Data . $passField # return the data, to be passed to the validator script return @( $client , $username , $password ) } ` -v { param ( $client , $username , $password ) # check if the client is valid return @{ 'user' = $user } } }","title":"Setup and Parsing"},{"location":"Tutorials/Authentication/Custom/#validating","text":"Once configured you can start using the Custom authentication to validate incoming requests. You can either configure the validation to happen on every route as global middleware , or as custom route middleware. The following will use Custom authentication to validate every request on every route : Server { middleware ( auth check client ) } Whereas the following example will use Custom authentication to only validate requests on specific a route : Server { route get '/info' ( auth check client ) { # logic } }","title":"Validating"},{"location":"Tutorials/Authentication/Custom/#full-example","text":"The following full example of Custom authentication will setup and configure authentication, validate that a users client/username/password is valid, and then validate on a specific route : Server { listen * : 8080 http # here we're calling the custom method \"client\" auth use -c client -p { # the current request session, and auth method options supplied param ( $session , $opts ) # get client/user/pass field names to get from payload $clientField = ( coalesce $opts . ClientField 'client' ) $userField = ( coalesce $opts . UsernameField 'username' ) $passField = ( coalesce $opts . PasswordField 'password' ) # get the client/user/pass from the post data $client = $session . Data . $clientField $username = $session . Data . $userField $password = $session . Data . $passField # return the data, to be passed to the validator script return @( $client , $username , $password ) } ` -v { param ( $client , $username , $password ) # check if the client is valid return @{ 'user' = $user } } # check the request on this route against the authentication route get '/cpu' ( auth check client ) { json @{ 'cpu' = 82 } } # this route will not be validated against the authentication route get '/memory' { json @{ 'memory' = 14 } } } Below is an example HTML page that would POST the client/username/password to the server above: < form action = \"/login\" method = \"post\" > < div > < label > Client: </ label > < input type = \"text\" name = \"client\" /> </ div > < div > < label > Username: </ label > < input type = \"text\" name = \"username\" /> </ div > < div > < label > Password: </ label > < input type = \"password\" name = \"password\" /> </ div > < div > < input type = \"submit\" value = \"Login\" /> </ div > </ form >","title":"Full Example"},{"location":"Tutorials/Authentication/Custom/#use-options","text":"Info There are no use options for custom types, unless you define your own.","title":"Use Options"},{"location":"Tutorials/Authentication/Form/","text":"Form Authentication Form authentication is for when you're using a <form> in HTML, and you submit the form. The method expects a username and password to be passed from the form input fields. Setup To setup and start using Form authentication in Pode you specify auth use form in your server script, the validator script you need to supply will have the username/password supplied as arguments to the scriptblock: Server { auth use form -v { param ( $username , $password ) # check if the user is valid return @{ 'user' = $user } } } By default, Pode will check if the request's payload (from POST) contains a username and password field. The auth use action can be supplied options via -o to override the names of these fields for anything custom. For example, to look for the field email rather than rather than the default username you could do: Server { auth use form -v { # check } -o @{ 'UsernameField' = 'email' } } More options can be seen further below. Validating Once configured you can start using Form authentication to validate incoming requests. You can either configure the validation to happen on every route as global middleware , or as custom route middleware. The following will use Form authentication to validate every request on every route : Server { middleware ( auth check form ) } Whereas the following example will use Form authentication to only validate requests on specific a route : Server { route get '/info' ( auth check form ) { # logic } } Full Example The following full example of Form authentication will setup and configure authentication, validate that a users username/password is valid, and then validate on a specific route : Server { listen * : 8080 http # setup form authentication to validate a user auth use form -v { param ( $username , $password ) # here you'd check a real user storage, this is just for example if ( $username -eq 'morty' -and $password -eq 'pickle' ) { return @{ 'user' = @{ 'ID' = 'M0R7Y302' 'Name' = 'Morty' ; 'Type' = 'Human' ; } } } return $null } # check the request on this route against the authentication route get '/cpu' ( auth check form ) { json @{ 'cpu' = 82 } } # this route will not be validated against the authentication route get '/memory' { json @{ 'memory' = 14 } } } Below is an example HTML page that would POST the username/password to the server above: < form action = \"/login\" method = \"post\" > < div > < label > Username: </ label > < input type = \"text\" name = \"username\" /> </ div > < div > < label > Password: </ label > < input type = \"password\" name = \"password\" /> </ div > < div > < input type = \"submit\" value = \"Login\" /> </ div > </ form > Use Options Name Description Default UsernameField Defines the name of field which the username will be passed in from the <form> username PasswordField Defines the name of field which the password will be passed in from the <form> password","title":"Form"},{"location":"Tutorials/Authentication/Form/#form-authentication","text":"Form authentication is for when you're using a <form> in HTML, and you submit the form. The method expects a username and password to be passed from the form input fields.","title":"Form Authentication"},{"location":"Tutorials/Authentication/Form/#setup","text":"To setup and start using Form authentication in Pode you specify auth use form in your server script, the validator script you need to supply will have the username/password supplied as arguments to the scriptblock: Server { auth use form -v { param ( $username , $password ) # check if the user is valid return @{ 'user' = $user } } } By default, Pode will check if the request's payload (from POST) contains a username and password field. The auth use action can be supplied options via -o to override the names of these fields for anything custom. For example, to look for the field email rather than rather than the default username you could do: Server { auth use form -v { # check } -o @{ 'UsernameField' = 'email' } } More options can be seen further below.","title":"Setup"},{"location":"Tutorials/Authentication/Form/#validating","text":"Once configured you can start using Form authentication to validate incoming requests. You can either configure the validation to happen on every route as global middleware , or as custom route middleware. The following will use Form authentication to validate every request on every route : Server { middleware ( auth check form ) } Whereas the following example will use Form authentication to only validate requests on specific a route : Server { route get '/info' ( auth check form ) { # logic } }","title":"Validating"},{"location":"Tutorials/Authentication/Form/#full-example","text":"The following full example of Form authentication will setup and configure authentication, validate that a users username/password is valid, and then validate on a specific route : Server { listen * : 8080 http # setup form authentication to validate a user auth use form -v { param ( $username , $password ) # here you'd check a real user storage, this is just for example if ( $username -eq 'morty' -and $password -eq 'pickle' ) { return @{ 'user' = @{ 'ID' = 'M0R7Y302' 'Name' = 'Morty' ; 'Type' = 'Human' ; } } } return $null } # check the request on this route against the authentication route get '/cpu' ( auth check form ) { json @{ 'cpu' = 82 } } # this route will not be validated against the authentication route get '/memory' { json @{ 'memory' = 14 } } } Below is an example HTML page that would POST the username/password to the server above: < form action = \"/login\" method = \"post\" > < div > < label > Username: </ label > < input type = \"text\" name = \"username\" /> </ div > < div > < label > Password: </ label > < input type = \"password\" name = \"password\" /> </ div > < div > < input type = \"submit\" value = \"Login\" /> </ div > </ form >","title":"Full Example"},{"location":"Tutorials/Authentication/Form/#use-options","text":"Name Description Default UsernameField Defines the name of field which the username will be passed in from the <form> username PasswordField Defines the name of field which the password will be passed in from the <form> password","title":"Use Options"},{"location":"Tutorials/Authentication/Overview/","text":"Authentication Overview Authentication can either be sessionless (requiring validation on every request), or session-persistent (only requiring validation once, and then checks against a session signed-cookie). Info To use session-persistent authentication you will also need to use session middleware. To setup and use authentication in Pode you need to use the auth function and middleware. The auth function has two actions: use and check which are detailed below: Actions Use The auth use action allows you to specify and configure which authentication methods your server will use; you can have many methods configured, defining which one to validate against on the auth check action. The make-up of the use action is: auth use < name > -validator {} [ -options @{}] [ -parser {}] [ -custom ] # or shorthand: auth use < name > -v {} [ -o @{}] [ -p {}] [ -c ] A quick example of using the use action for Basic authentication is as follows: Server { auth use basic -v { param ( $username , $pass ) # logic to check user return @{ 'user' = $user } } } The <name> of the authentication method specified should be a valid inbuilt method (such as Basic or Form), unless you have stated that the method is custom ( -c ). The validator ( -v ) script is used to find a user, checking if they exist and the password is correct (or checking if they exist in some data store). If the validator passes, then a user needs to be returned from the script via @{ 'user' = $user } - if $null or a null user is returned then the validator script is assumed to have failed. Some auth methods also have options ( -o ) that can be supplied as a hashtable, such as field name or encoding overrides. Available options will vary between authentication methods, and can be seen on their tutorial pages, such as Basic . If a custom ( -c ) authentication method is used, you must supply a parser ( -p ) script which will parse payloads/headers for credentials and then return this data as an array - which will then be supplied to the validator ( -v ) script. Check The auth check action allows you to define which authentication method to validate a request against. The action returns a valid middleware script, meaning you can either use this action on specific route definitions, or globally for all routes as middleware . If this action fails, then a 401 response is returned. The make-up of the check action is: auth check < name > [ -options @{}] # or shorthand: auth check < name > [ -o @{}] A quick example of using the check action against Basic authentication is as follows. The first example sets up the check as global middleware, whereas the second example sets up the check as custom route middleware: Server { # 1. apply the auth check as global middleware middleware ( auth check basic ) # 2. or, apply auth check as custom route middleware route get '/users' ( auth check basic ) { # route logic } } On success, this action will then allow the route logic to be invoked. If session middleware has been configured then an authenticated session is also created for future requests, using a signed session-cookie. When the user makes another call using the same authenticated session and that cookie is passed, then the auth check action will detect the already authenticated session and skip the validator script. If you're using sessions and you don't want the auth check to check the session, or store the user against the session, then pass -o @{ 'Session' = $false } to the auth check call. Check Parameters The following table contains options that you can supply to an auth check -o @{} call - these are all optional: Name Description Default FailureUrl The URL to redirect to should authentication fail empty SuccessUrl The URL to redirect to should authenticationh succeed empty Session If true, check if the session already has an authenticated user; storing the user in the session if they are authenticated true Login If true, check the authentication status in the session and redirect to the SuccessUrl if the user is authenticated. Otherwise proceed to the page with no authentication required false Logout If true, purge the session and redirect to the FailureUrl false Info The Login option allows you to have authentication on your login pages, such that if there is no user in a current session then the login page displays - rather then being 401'd. Whereas if there is an authenticated user in the session it will auto-redirect to the SuccessUrl .","title":"Overview"},{"location":"Tutorials/Authentication/Overview/#authentication-overview","text":"Authentication can either be sessionless (requiring validation on every request), or session-persistent (only requiring validation once, and then checks against a session signed-cookie). Info To use session-persistent authentication you will also need to use session middleware. To setup and use authentication in Pode you need to use the auth function and middleware. The auth function has two actions: use and check which are detailed below:","title":"Authentication Overview"},{"location":"Tutorials/Authentication/Overview/#actions","text":"","title":"Actions"},{"location":"Tutorials/Authentication/Overview/#use","text":"The auth use action allows you to specify and configure which authentication methods your server will use; you can have many methods configured, defining which one to validate against on the auth check action. The make-up of the use action is: auth use < name > -validator {} [ -options @{}] [ -parser {}] [ -custom ] # or shorthand: auth use < name > -v {} [ -o @{}] [ -p {}] [ -c ] A quick example of using the use action for Basic authentication is as follows: Server { auth use basic -v { param ( $username , $pass ) # logic to check user return @{ 'user' = $user } } } The <name> of the authentication method specified should be a valid inbuilt method (such as Basic or Form), unless you have stated that the method is custom ( -c ). The validator ( -v ) script is used to find a user, checking if they exist and the password is correct (or checking if they exist in some data store). If the validator passes, then a user needs to be returned from the script via @{ 'user' = $user } - if $null or a null user is returned then the validator script is assumed to have failed. Some auth methods also have options ( -o ) that can be supplied as a hashtable, such as field name or encoding overrides. Available options will vary between authentication methods, and can be seen on their tutorial pages, such as Basic . If a custom ( -c ) authentication method is used, you must supply a parser ( -p ) script which will parse payloads/headers for credentials and then return this data as an array - which will then be supplied to the validator ( -v ) script.","title":"Use"},{"location":"Tutorials/Authentication/Overview/#check","text":"The auth check action allows you to define which authentication method to validate a request against. The action returns a valid middleware script, meaning you can either use this action on specific route definitions, or globally for all routes as middleware . If this action fails, then a 401 response is returned. The make-up of the check action is: auth check < name > [ -options @{}] # or shorthand: auth check < name > [ -o @{}] A quick example of using the check action against Basic authentication is as follows. The first example sets up the check as global middleware, whereas the second example sets up the check as custom route middleware: Server { # 1. apply the auth check as global middleware middleware ( auth check basic ) # 2. or, apply auth check as custom route middleware route get '/users' ( auth check basic ) { # route logic } } On success, this action will then allow the route logic to be invoked. If session middleware has been configured then an authenticated session is also created for future requests, using a signed session-cookie. When the user makes another call using the same authenticated session and that cookie is passed, then the auth check action will detect the already authenticated session and skip the validator script. If you're using sessions and you don't want the auth check to check the session, or store the user against the session, then pass -o @{ 'Session' = $false } to the auth check call.","title":"Check"},{"location":"Tutorials/Authentication/Overview/#check-parameters","text":"The following table contains options that you can supply to an auth check -o @{} call - these are all optional: Name Description Default FailureUrl The URL to redirect to should authentication fail empty SuccessUrl The URL to redirect to should authenticationh succeed empty Session If true, check if the session already has an authenticated user; storing the user in the session if they are authenticated true Login If true, check the authentication status in the session and redirect to the SuccessUrl if the user is authenticated. Otherwise proceed to the page with no authentication required false Logout If true, purge the session and redirect to the FailureUrl false Info The Login option allows you to have authentication on your login pages, such that if there is no user in a current session then the login page displays - rather then being 401'd. Whereas if there is an authenticated user in the session it will auto-redirect to the SuccessUrl .","title":"Check Parameters"},{"location":"Tutorials/ViewEngines/Pode/","text":"Pode Pode has an inbuilt dynamic file type of .pode , which allow you to write normal file but use PowerShell within them. For view files the naming convention is just index.pode or about.pode . However for non-view files in the /public directory the convention is style.css.pode - which includes the files base file type. Views Using Pode to render dynamic view files is mostly just using normal HTML, but with the insertion of PowerShell - in fact, you could write pure HTML in a .pode file and it will still work. The difference is that you're able to embed PowerShell logic into the file, which allows you to dynamically generate HTML. To use .pode files for views, you will need to place them within the /views directory; then you'll need to set the View Engine to be Pode. Once set, you can just write view responses as per normal: Server { listen * : 8080 http # set the engine to use and render Pode files engine pode # render the index.pode in the /views directory route get '/' { view 'index' } } Info Any PowerShell in a .pode files will need to be wrapped in $(...) and each line must end with a semi-colon. Below is a basic example of a .pode view file, which just writes the current date to the browser: <!-- /views/index.pode --> < html > < head > < title > Current Date </ title > </ head > < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > Any data supplied to the view function when rendering .pode files will make them far more dynamic. The data supplied to view must be a hashtable , and can be referenced from within the file by using the $data argument. For example, say you need to render a search page which is a list of accounts filtered by some query; then your basic server script could look like the following: Server { listen * : 8080 http # set the engine to use and render .pode files engine pode # render the search.pode view route get '/' { param ( $session ) # some logic to get accounts $query = $session . Query [ 'query' ] $accounts = Find-Account -Query $query # render the file view 'search' -Data @{ 'query' = $query ; 'accounts' = $accounts ; } } } You can see that we're supplying the found accounts to the view function as a hashtable . Next, we see the search.pode view file which generates the HTML: <!-- /views/search.pode --> < html > < head > < title > Search </ title > </ head > < body > < h1 > Search </ h1 > Query: $($data.query;) < div > $(foreach ($account in $data.accounts) { \" < div > Name: $($account.Name) </ div >< hr /> \"; }) </ div > </ body > </ html > Remember, you can access supplied data by using $data This next quick example allows you to include content from another view: <!-- /views/index.pode --> < html > $(include shared/head) < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > <!-- /views/shared/head.pode --> < head > < title > Include Example </ title > </ head > Non-Views The rules for using .pode files for other non-view file types, like css/js files, work exactly like the above view files but they're placed within the /public directory instead of the /views directory. You also need to specify the actual file type in the extension, for example: /public/styles/main.css.pode /public/scripts/main.js.pode Here you'll see the main extension is .pode , but you need to specify a sub-extension of the main file type such as .css - this helps Pode work out the main content type when writing to the response. Below is a .css.pode file that will render the page in purple on even seconds, or red on odd seconds: /* /public/styles/main.css.pode */ body { $( $date = [DateTime]::UtcNow ; if ($date.Second % 2 -eq 0) { \" background-color : rebeccapurple ; \" ; } else { \" background-color : red ; \" ; } ) } To load the above .css.pode file in a view file: <!-- /views/index.pode --> < html > < head > < link rel = \"stylesheet\" href = \"styles/main.css.pode\" > </ head > < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html >","title":"Pode"},{"location":"Tutorials/ViewEngines/Pode/#pode","text":"Pode has an inbuilt dynamic file type of .pode , which allow you to write normal file but use PowerShell within them. For view files the naming convention is just index.pode or about.pode . However for non-view files in the /public directory the convention is style.css.pode - which includes the files base file type.","title":"Pode"},{"location":"Tutorials/ViewEngines/Pode/#views","text":"Using Pode to render dynamic view files is mostly just using normal HTML, but with the insertion of PowerShell - in fact, you could write pure HTML in a .pode file and it will still work. The difference is that you're able to embed PowerShell logic into the file, which allows you to dynamically generate HTML. To use .pode files for views, you will need to place them within the /views directory; then you'll need to set the View Engine to be Pode. Once set, you can just write view responses as per normal: Server { listen * : 8080 http # set the engine to use and render Pode files engine pode # render the index.pode in the /views directory route get '/' { view 'index' } } Info Any PowerShell in a .pode files will need to be wrapped in $(...) and each line must end with a semi-colon. Below is a basic example of a .pode view file, which just writes the current date to the browser: <!-- /views/index.pode --> < html > < head > < title > Current Date </ title > </ head > < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > Any data supplied to the view function when rendering .pode files will make them far more dynamic. The data supplied to view must be a hashtable , and can be referenced from within the file by using the $data argument. For example, say you need to render a search page which is a list of accounts filtered by some query; then your basic server script could look like the following: Server { listen * : 8080 http # set the engine to use and render .pode files engine pode # render the search.pode view route get '/' { param ( $session ) # some logic to get accounts $query = $session . Query [ 'query' ] $accounts = Find-Account -Query $query # render the file view 'search' -Data @{ 'query' = $query ; 'accounts' = $accounts ; } } } You can see that we're supplying the found accounts to the view function as a hashtable . Next, we see the search.pode view file which generates the HTML: <!-- /views/search.pode --> < html > < head > < title > Search </ title > </ head > < body > < h1 > Search </ h1 > Query: $($data.query;) < div > $(foreach ($account in $data.accounts) { \" < div > Name: $($account.Name) </ div >< hr /> \"; }) </ div > </ body > </ html > Remember, you can access supplied data by using $data This next quick example allows you to include content from another view: <!-- /views/index.pode --> < html > $(include shared/head) < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html > <!-- /views/shared/head.pode --> < head > < title > Include Example </ title > </ head >","title":"Views"},{"location":"Tutorials/ViewEngines/Pode/#non-views","text":"The rules for using .pode files for other non-view file types, like css/js files, work exactly like the above view files but they're placed within the /public directory instead of the /views directory. You also need to specify the actual file type in the extension, for example: /public/styles/main.css.pode /public/scripts/main.js.pode Here you'll see the main extension is .pode , but you need to specify a sub-extension of the main file type such as .css - this helps Pode work out the main content type when writing to the response. Below is a .css.pode file that will render the page in purple on even seconds, or red on odd seconds: /* /public/styles/main.css.pode */ body { $( $date = [DateTime]::UtcNow ; if ($date.Second % 2 -eq 0) { \" background-color : rebeccapurple ; \" ; } else { \" background-color : red ; \" ; } ) } To load the above .css.pode file in a view file: <!-- /views/index.pode --> < html > < head > < link rel = \"stylesheet\" href = \"styles/main.css.pode\" > </ head > < body > < span > $([DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss');) </ span > </ body > </ html >","title":"Non-Views"},{"location":"Tutorials/ViewEngines/ThirdParty/","text":"Third Party Pode also supports the use of third-party view engines, for example you could use the EPS template engine. To do this, you'll need to supply a custom scriptblock to the engine function which tells Pode how use the third-party engine. The scriptblock will be supplied with two arguments: $path : The path to the view/public file that needs generating $data : Any data that was supplied to the view function If you did use EPS , then the following example would work: Server { listen * : 8080 http # set the engine to use and render EPS files # (could be index.eps, or for content scripts.css.eps) engine eps { param ( $path , $data ) return ( Invoke-EpsTemplate -Path $path -Binding $data ) } # render the index.eps view route get '/' { view 'index' } }","title":"Third Party"},{"location":"Tutorials/ViewEngines/ThirdParty/#third-party","text":"Pode also supports the use of third-party view engines, for example you could use the EPS template engine. To do this, you'll need to supply a custom scriptblock to the engine function which tells Pode how use the third-party engine. The scriptblock will be supplied with two arguments: $path : The path to the view/public file that needs generating $data : Any data that was supplied to the view function If you did use EPS , then the following example would work: Server { listen * : 8080 http # set the engine to use and render EPS files # (could be index.eps, or for content scripts.css.eps) engine eps { param ( $path , $data ) return ( Invoke-EpsTemplate -Path $path -Binding $data ) } # render the index.eps view route get '/' { view 'index' } }","title":"Third Party"}]}